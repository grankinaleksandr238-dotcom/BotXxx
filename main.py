# ==================== –ß–ê–°–¢–¨ 1: –ò–ú–ü–û–†–¢–´, –ù–ê–°–¢–†–û–ô–ö–ò, –ë–î, –ö–ï–®–ò–†–û–í–ê–ù–ò–ï, –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ====================
# –§–ò–ù–ê–õ–¨–ù–ê–Ø –í–ï–†–°–ò–Ø –° –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï–ú –í–°–ï–• –í–´–Ø–í–õ–ï–ù–ù–´–• –ù–ï–î–û–ß–Å–¢–û–í
# - –ö–æ–Ω—Ç—Ä–æ–ª—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º allow_negative
# - add_exp –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—Å—Ç –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–æ—Å–ª–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
# - –ü–æ–ª–Ω–∞—è –º–∏–≥—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –ø–æ–ª–µ–π –¥–∞—Ç –Ω–∞ TIMESTAMP
# - –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–ª–∞–Ω—Å–∞ –≤ create_bitcoin_order –≤–Ω—É—Ç—Ä–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
# - –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫ –≤ get_setting_int
# - –£—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å –º–∏–≥—Ä–∞—Ü–∏–∏ –∫ –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–º –¥–∞–Ω–Ω—ã–º

import asyncio
import logging
import random
import os
import time
import string
import csv
import io
import json
import hashlib
import sys
from datetime import datetime, timedelta, date
from typing import Dict, List, Optional, Tuple, Any, Union
from collections import defaultdict
from functools import lru_cache, wraps

import asyncpg
from aiogram import Bot, Dispatcher, types, BaseMiddleware
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import (
    ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup,
    InlineKeyboardButton, CallbackQuery, Message, BufferedInputFile,
    ChatPermissions, ContentType
)
from aiogram.exceptions import (
    TelegramBadRequest, TelegramForbiddenError, TelegramRetryAfter,
    TelegramAPIError
)
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder

# ==================== –ù–ê–°–¢–†–û–ô–ö–ò ====================
BOT_TOKEN = os.getenv("BOT_TOKEN")
if not BOT_TOKEN:
    raise ValueError("‚ùå BOT_TOKEN –Ω–µ –∑–∞–¥–∞–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")

SUPER_ADMINS_STR = os.getenv("SUPER_ADMINS", "")
# –í–†–ï–ú–ï–ù–ù–û –¥–æ–±–∞–≤–ª—è–µ–º —Å–≤–æ–π ID –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ
SUPER_ADMINS = [8127013147]  # <- –¢–í–û–ô ID!

# ===== –í–†–ï–ú–ï–ù–ù–ê–Ø –ü–†–û–í–ï–†–ö–ê =====
print(f"‚ö°Ô∏è –°–£–ü–ï–†-–ê–î–ú–ò–ù–´ –ó–ê–ì–†–£–ñ–ï–ù–´: {SUPER_ADMINS}")
print(f"‚ö°Ô∏è –¢–í–û–ô ID –í –°–ü–ò–°–ö–ï: {8127013147 in SUPER_ADMINS}")
# ===============================

# –ï—Å–ª–∏ –µ—Å—Ç—å –µ—â–µ ID –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è, –¥–æ–±–∞–≤–ª—è–µ–º –∏ –∏—Ö
if SUPER_ADMINS_STR:
    SUPER_ADMINS.extend([int(x.strip()) for x in SUPER_ADMINS_STR.split(",") if x.strip()])

DATABASE_URL = os.getenv("DATABASE_URL")
if not DATABASE_URL:
    raise ValueError("‚ùå DATABASE_URL –Ω–µ –∑–∞–¥–∞–Ω. –°–æ–∑–¥–∞–π—Ç–µ PostgreSQL –±–∞–∑—É.")

# –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: Redis –¥–ª—è –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
REDIS_URL = os.getenv("REDIS_URL")
redis_client = None
if REDIS_URL:
    try:
        import aioredis
        redis_client = aioredis.from_url(REDIS_URL, decode_responses=True)
        logging.info("‚úÖ Redis –ø–æ–¥–∫–ª—é—á–µ–Ω")
    except ImportError:
        logging.warning("‚ö†Ô∏è aioredis –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ Redis –æ—Ç–∫–ª—é—á–µ–Ω–æ")
    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Redis: {e}")

# ==================== –°–û–ó–î–ê–ù–ò–ï –ë–û–¢–ê ====================
bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
storage = MemoryStorage()
dp = Dispatcher(storage=storage)

# ==================== –ö–ï–®–ò–†–û–í–ê–ù–ò–ï –° –ü–†–û–í–ï–†–ö–û–ô –ù–ê –ù–ê–õ–ò–ß–ò–ï REDIS ====================
async def redis_get(key: str) -> Optional[str]:
    """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ Redis."""
    if redis_client is None:
        return None
    try:
        return await redis_client.get(key)
    except Exception as e:
        logging.error(f"Redis get error for key {key}: {e}")
        return None

async def redis_set(key: str, value: str, ttl: int = 60):
    """–ë–µ–∑–æ–ø–∞—Å–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–Ω–∞—á–µ–Ω–∏—è –≤ Redis."""
    if redis_client is None:
        return
    try:
        await redis_client.setex(key, ttl, value)
    except Exception as e:
        logging.error(f"Redis set error for key {key}: {e}")

async def redis_delete(key: str):
    """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ –∫–ª—é—á–∞ –∏–∑ Redis."""
    if redis_client is None:
        return
    try:
        await redis_client.delete(key)
    except Exception as e:
        logging.error(f"Redis delete error for key {key}: {e}")

# ==================== –ë–õ–û–ö–ò–†–û–í–ö–ò –° FALLBACK –ù–ê –ë–î ====================
async def acquire_lock(lock_name: str, timeout: int = 10) -> bool:
    """
    –ü—ã—Ç–∞–µ—Ç—Å—è –∑–∞—Ö–≤–∞—Ç–∏—Ç—å –±–ª–æ–∫–∏—Ä–æ–≤–∫—É.
    –ï—Å–ª–∏ Redis –¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –µ–≥–æ.
    –ò–Ω–∞—á–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç advisory lock PostgreSQL.
    """
    if redis_client is not None:
        try:
            lock_key = f"lock:{lock_name}"
            result = await redis_client.setnx(lock_key, "1")
            if result:
                await redis_client.expire(lock_key, timeout)
                return True
            return False
        except Exception as e:
            logging.error(f"Redis acquire_lock error for {lock_name}: {e}")
            # fallback to DB

    # Fallback –Ω–∞ PostgreSQL advisory lock
    try:
        async with db_pool.acquire() as conn:
            lock_id = hash(lock_name) % (2**63 - 1)
            locked = await conn.fetchval("SELECT pg_try_advisory_lock($1)", lock_id)
            return locked
    except Exception as e:
        logging.error(f"DB acquire_lock error for {lock_name}: {e}")
        # –ü—Ä–∏ –æ—à–∏–±–∫–µ —Ä–∞–∑—Ä–µ—à–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ (fallback)
        return True

async def release_lock(lock_name: str):
    """–û—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∫—É."""
    if redis_client is not None:
        try:
            await redis_client.delete(f"lock:{lock_name}")
        except Exception as e:
            logging.error(f"Redis release_lock error for {lock_name}: {e}")
    else:
        try:
            async with db_pool.acquire() as conn:
                lock_id = hash(lock_name) % (2**63 - 1)
                await conn.execute("SELECT pg_advisory_unlock($1)", lock_id)
        except Exception as e:
            logging.error(f"DB release_lock error for {lock_name}: {e}")

# ==================== –ù–ê–°–¢–†–û–ô–ö–ò –ü–û –£–ú–û–õ–ß–ê–ù–ò–Æ ====================
DEFAULT_SETTINGS = {
    # ----- –ö–†–ê–ñ–ê -----
    "random_attack_cost": "0",
    "targeted_attack_cost": "50",
    "theft_cooldown_minutes": "30",
    "theft_success_chance": "40",
    "theft_defense_chance": "20",
    "theft_defense_penalty": "10",
    "min_theft_amount": "5",
    "max_theft_amount": "15",

    # ----- –ö–ê–ó–ò–ù–û -----
    "casino_win_chance": "40.0",
    "casino_min_bet": "1",
    "casino_max_bet": "1000",
    "min_level_casino": "1",
    "slots_win_probability": "25.0",
    "slots_multiplier_three": "3.0",
    "slots_multiplier_diamond": "5.0",
    "slots_multiplier_seven": "10.0",
    "roulette_number_multiplier": "36.0",
    "roulette_green_multiplier": "18.0",
    "roulette_color_multiplier": "2.0",
    "roulette_win_chance": "47.3",

    # ----- –£–í–ï–î–û–ú–õ–ï–ù–ò–Ø -----
    "chat_notify_big_win": "1",
    "chat_notify_big_purchase": "1",
    "chat_notify_giveaway": "1",

    # ----- –ü–û–î–ì–û–ù -----
    "gift_amount": "30",
    "gift_limit_per_day": "3",
    "gift_global_limit_per_user": "4",
    "gift_cooldown": "60",

    # ----- –†–ï–§–ï–†–ê–õ–´ -----
    "referral_bonus": "50",
    "referral_reputation": "2",
    "referral_required_thefts": "15",

    # ----- –û–ü–´–¢ -----
    "exp_per_dice_win": "3",
    "exp_per_dice_lose": "1",
    "exp_per_guess_win": "4",
    "exp_per_guess_lose": "1",
    "exp_per_slots_win": "6",
    "exp_per_slots_lose": "2",
    "exp_per_roulette_win": "5",
    "exp_per_roulette_lose": "1",
    "exp_per_theft_success": "8",
    "exp_per_theft_fail": "2",
    "exp_per_theft_defense": "5",
    "exp_per_heist_participation": "10",
    "exp_per_betray_success": "5",
    "exp_per_betray_fail": "1",
    "exp_per_smuggle": "10",
    "exp_per_jail": "5",

    # ----- –£–†–û–í–ù–ò -----
    "level_multiplier": "100",
    "level_reward_coins": "30",
    "level_reward_reputation": "3",
    "level_reward_coins_increment": "5",
    "level_reward_reputation_increment": "1",

    # ----- –†–ï–ü–£–¢–ê–¶–ò–Ø -----
    "reputation_theft_bonus": "0.5",
    "reputation_defense_bonus": "0.5",
    "reputation_max_bonus_percent": "30",

    # ----- –°–¢–ê–¢–´ –ó–ê –£–†–û–í–ï–ù–¨ -----
    "stat_strength_per_level": "1",
    "stat_agility_per_level": "1",
    "stat_defense_per_level": "1",

    # ----- –ö–ò–î–ê–õ–û–í–û (PVP) -----
    "betray_base_chance": "20",
    "betray_steal_percent": "30",
    "betray_fail_penalty_percent": "10",
    "betray_cooldown_minutes": "60",
    "betray_max_chance": "50",

    # ----- –ù–ê–õ–Å–¢–´ -----
    "heist_min_interval_minutes": "70",
    "heist_max_interval_minutes": "70",
    "heist_join_minutes": "10",
    "heist_split_minutes": "5",
    "heist_min_pot": "50",
    "heist_max_pot": "200",
    "heist_btc_chance": "10",
    "heist_min_btc": "0.001",
    "heist_max_btc": "0.01",
    "heist_cooldown_minutes": "30",
    "heist_participant_cooldown_hours": "1",
    "heist_share_min": "5",
    "heist_share_max": "10",

    # ----- –ë–ò–ó–ù–ï–°–´ -----
    "business_upgrade_cost_per_level": "10",
    "business_collect_interval_minutes": "30",
    "business_max_storage_hours": "24",
    "business_max_businesses": "6",
    "business_lifetime_hours_default": "720",

    # ----- –ë–ò–¢–ö–û–ò–ù–´ -----
    "bitcoin_per_theft": "1",
    "bitcoin_per_heist_participation": "0",
    "bitcoin_per_betray_success": "0",

    # ----- –ë–ò–¢–ö–û–ò–ù-–ë–ò–†–ñ–ê -----
    "exchange_min_price": "1",
    "exchange_max_price": "1000",
    "exchange_commission_percent": "0",
    "exchange_commission_side": "seller",
    "exchange_commission_destination": "burn",
    "exchange_min_amount_btc": "0.001",

    # ----- –ö–û–ù–¢–†–ê–ë–ê–ù–î–ê -----
    "smuggle_base_amount": "0.001",
    "smuggle_cooldown_minutes": "60",
    "smuggle_fail_penalty_minutes": "30",
    "smuggle_success_chance": "55",
    "smuggle_caught_chance": "30",
    "smuggle_lost_chance": "15",
    "smuggle_min_duration": "30",
    "smuggle_max_duration": "120",

    # ----- –¢–Æ–†–¨–ú–ê -----
    "jail_min_duration": "30",
    "jail_max_duration": "90",
    "jail_success_chance": "30",
    "jail_auth_min": "1",
    "jail_auth_max": "3",
    "jail_cooldown_hours": "1",

    # ----- –û–ß–ò–°–¢–ö–ê –õ–û–ì–û–í -----
    "cleanup_days_heists": "30",
    "cleanup_days_purchases": "30",
    "cleanup_days_giveaways": "30",
    "cleanup_days_user_tasks": "30",
    "cleanup_days_smuggle": "30",
    "cleanup_days_bitcoin_orders": "30",

    # ----- –ê–í–¢–û–£–î–ê–õ–ï–ù–ò–ï -----
    "auto_delete_commands_seconds": "30",

    # ----- –°–¢–ê–†–¢–û–í–´–ô –ë–û–ù–£–° -----
    "new_user_bonus": "50",

    # ----- –ì–õ–û–ë–ê–õ–¨–ù–´–ô –ê–ù–¢–ò-–°–ü–ê–ú –ö–£–õ–î–ê–£–ù -----
    "global_cooldown_seconds": "3",
    "global_chat_cooldown_hours": "1",

    # ----- –õ–ò–ú–ò–¢ –ù–ê –í–í–û–î –ß–ò–°–ï–õ -----
    "max_input_number": "1000000",

    # ----- –ü–†–û–ö–ê–ß–ö–ê –ù–ê–í–´–ö–û–í -----
    "skill_share_cost_per_level": "50",
    "skill_luck_cost_per_level": "40",
    "skill_betray_cost_per_level": "60",
    "skill_share_bonus_per_level": "2",
    "skill_luck_bonus_per_level": "3",
    "skill_betray_bonus_per_level": "4",
    "skill_max_level": "10",

    # ----- –ó–ê–î–ê–ù–ò–Ø -----
    "task_subscribe_check_interval": "3600",

    # ----- –ü–†–û–ú–û–ö–û–î–´ -----
    "promocode_max_uses_default": "1",
}

# ==================== –¢–ò–ü–´ –ë–ò–ó–ù–ï–°–û–í ====================
BUSINESS_TYPES = [
    {
        "id": 1,
        "name": "–õ–∞—Ä—ë–∫",
        "emoji": "ü•§",
        "base_price_btc": 50,
        "base_income_per_hour": 0.5,
        "description": "–ú–∞–ª–µ–Ω—å–∫–∏–π –ª–∞—Ä—ë–∫ —É –º–µ—Ç—Ä–æ. –¢–æ—Ä–≥—É–µ—Ç –≥–∞–∑–∏—Ä–æ–≤–∫–æ–π –∏ —á–∏–ø—Å–∞–º–∏.",
        "max_level": 3,
        "image_key": "business_kiosk",
        "lifetime_hours": 720
    },
    {
        "id": 2,
        "name": "–ö–∏–æ—Å–∫",
        "emoji": "üè™",
        "base_price_btc": 120,
        "base_income_per_hour": 1.5,
        "description": "–ü—Ä–æ–¥–∞—ë—Ç –ø—Ä–µ—Å—Å—É, —Å–∏–≥–∞—Ä–µ—Ç—ã –∏ –º–µ–ª–æ—á—ë–≤–∫—É.",
        "max_level": 3,
        "image_key": "business_shop",
        "lifetime_hours": 720
    },
    {
        "id": 3,
        "name": "–ú–∞–≥–∞–∑–∏–Ω",
        "emoji": "üè¨",
        "base_price_btc": 250,
        "base_income_per_hour": 3.0,
        "description": "–ü—Ä–æ–¥—É–∫—Ç–æ–≤—ã–π –º–∞–≥–∞–∑–∏–Ω —Å–æ —Å—Ç–∞–±–∏–ª—å–Ω—ã–º –¥–æ—Ö–æ–¥–æ–º.",
        "max_level": 3,
        "image_key": "business_supermarket",
        "lifetime_hours": 720
    },
    {
        "id": 4,
        "name": "–†–µ—Å—Ç–æ—Ä–∞–Ω",
        "emoji": "üçΩÔ∏è",
        "base_price_btc": 500,
        "base_income_per_hour": 5.0,
        "description": "–≠–ª–∏—Ç–Ω—ã–π —Ä–µ—Å—Ç–æ—Ä–∞–Ω —Å –±–æ–≥–∞—Ç—ã–º–∏ –ø–æ—Å–µ—Ç–∏—Ç–µ–ª—è–º–∏.",
        "max_level": 3,
        "image_key": "business_restaurant",
        "lifetime_hours": 720
    },
    {
        "id": 5,
        "name": "–û—Ç–µ–ª—å",
        "emoji": "üè®",
        "base_price_btc": 800,
        "base_income_per_hour": 7.5,
        "description": "–®–∏–∫–∞—Ä–Ω—ã–π –æ—Ç–µ–ª—å –¥–ª—è —Å–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω—ã—Ö –≥–æ—Å—Ç–µ–π.",
        "max_level": 3,
        "image_key": "business_hotel",
        "lifetime_hours": 720
    },
    {
        "id": 6,
        "name": "–ù–µ—Ñ—Ç—è–Ω–∞—è –≤—ã—à–∫–∞",
        "emoji": "üõ¢Ô∏è",
        "base_price_btc": 1200,
        "base_income_per_hour": 10.0,
        "description": "–°–æ–±—Å—Ç–≤–µ–Ω–Ω–∞—è –Ω–µ—Ñ—Ç—è–Ω–∞—è –≤—ã—à–∫–∞. –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –ø—Ä–æ—Ñ–∏—Ç!",
        "max_level": 3,
        "image_key": "business_oil",
        "lifetime_hours": 720
    }
]

# ==================== –ü–†–ï–î–û–ü–†–ï–î–ï–õ–Å–ù–ù–´–ï –ö–õ–Æ–ß–ò –ú–ï–î–ò–ê ====================
MEDIA_KEYS = [
    "welcome", "profile", "casino", "shop", "theft", "referral", "tasks", "giveaway",
    "exchange", "admin", "admin_users", "admin_shop", "admin_giveaway", "admin_channels",
    "admin_promo", "admin_business", "admin_exchange", "admin_media", "admin_chats",
    "admin_settings", "admin_tasks",
    "heist_incassator", "heist_bank", "heist_crypto", "heist_narko", "heist_weapon",
    "smuggle_start", "smuggle_success", "smuggle_fail",
    "jail_start", "jail_success", "jail_fail",
    "business_kiosk", "business_shop", "business_supermarket", "business_restaurant", "business_hotel", "business_oil"
]

# ==================== –ö–û–ù–°–¢–ê–ù–¢–´ ====================
ITEMS_PER_PAGE = 10
BIG_WIN_THRESHOLD = 100
BIG_PURCHASE_THRESHOLD = 100

PERMISSIONS_LIST = [
    "manage_users",
    "manage_shop",
    "manage_giveaways",
    "manage_channels",
    "manage_chats",
    "manage_promocodes",
    "manage_media",
    "manage_businesses",
    "manage_exchange",
    "view_stats",
    "broadcast",
    "edit_settings",
    "cleanup",
    "manage_admins",
]

# ==================== –¢–ò–ü–´ –°–û–ë–´–¢–ò–ô (–ù–ê–õ–Å–¢–û–í) ====================
HEIST_TYPES = {
    "incassator": {
        "name": "üöê –ò–Ω–∫–∞—Å—Å–∞—Ç–æ—Ä",
        "keyword": "–§–ê–†–¢",
        "phrases_start": [
            "üü° –ò–Ω–∫–∞—Å—Å–∞—Ç–æ—Ä—Å–∫–∞—è –º–∞—à–∏–Ω–∞, –ø–æ–ª–Ω–∞—è –¥–µ–Ω–µ–≥, –ø—Ä–æ–µ–∑–∂–∞–µ—Ç —á–µ—Ä–µ–∑ –≥–æ—Ä–æ–¥! –ö—Ç–æ —Å –Ω–∞–º–∏? –ü–∏—à–∏ **–§–ê–†–¢** –≤ —Ç–µ—á–µ–Ω–∏–µ {minutes} –º–∏–Ω—É—Ç!",
            "üí∞ –ë—Ä–æ–Ω–µ–≤–∏–∫ —Å –¥–µ–Ω—å–≥–∞–º–∏ –Ω–∞–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –∫ —Ü–µ–Ω—Ç—Ä—É! –ì–æ–≤–æ—Ä—è—Ç, —Ç–∞–º —Ü–µ–ª–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ! –ü–∏—à–∏ **–§–ê–†–¢**",
            "üöê –°–ª—ã—à–∞–ª–∏ –Ω–æ–≤–æ—Å—Ç—å? –ò–Ω–∫–∞—Å—Å–∞—Ç–æ—Ä—ã –≤–µ–∑—É—Ç –∑–∞—Ä–ø–ª–∞—Ç—É –¥–ª—è –≤—Å–µ–≥–æ –≥–æ—Ä–æ–¥–∞! –ü–∏—à–∏ **–§–ê–†–¢** –∏ –ø–æ–≥–Ω–∞–ª–∏!",
            "üí∏ –ù–∞—à —á–µ–ª–æ–≤–µ–∫ —Å–ª–∏–ª –º–∞—Ä—à—Ä—É—Ç –∏–Ω–∫–∞—Å—Å–∞—Ç–æ—Ä–æ–≤! –¢–∞–º –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –º–Ω–æ–≥–æ! –ü–∏—à–∏ **–§–ê–†–¢**",
            "üü° –ë—Ä–æ–Ω—è —Å–ª–∞–±–∞—è, –æ—Ö—Ä–∞–Ω–∞ —Å–ª–µ–ø–∞—è! –õ–µ–≥–∫–∏–µ –¥–µ–Ω—å–≥–∏! –ü–∏—à–∏ **–§–ê–†–¢**",
            "üî´ –ò–Ω–∫–∞—Å—Å–∞—Ç–æ—Ä—ã –æ—Å—Ç–∞–Ω–æ–≤–∏–ª–∏—Å—å —É –ª–∞—Ä—å–∫–∞ –∑–∞ –ø–∏—Ä–æ–∂–∫–∞–º–∏. –î–æ–±—ã—á–∞ –±—É–¥–µ—Ç –ª—ë–≥–∫–æ–π! –ü–∏—à–∏ **–§–ê–†–¢**",
            "üöî –ü–æ–ª–∏—Ü–∏—è –∑–∞–Ω—è—Ç–∞ –æ–±–ª–∞–≤–æ–π, —Å–µ–π—á–∞—Å —Å–∞–º–æ–µ –≤—Ä–µ–º—è! –ü–∏—à–∏ **–§–ê–†–¢**"
        ],
        "phrases_join": [
            "‚úÖ {name} –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ –Ω–∞–ª—ë—Ç—É!",
            "üî´ {name} –≤ –¥–µ–ª–µ!",
            "üí™ {name} –∑–∞—Ä—è–¥–∏–ª —Å—Ç–≤–æ–ª –∏ –≥–æ—Ç–æ–≤ —Ä–≤–∞—Ç—å!",
            "üòé {name} –≤—Ç–∏—Ä–∞–µ—Ç—Å—è –≤ –¥–æ–≤–µ—Ä–∏–µ –∫ –æ—Ö—Ä–∞–Ω–µ..."
        ],
        "phrases_split": [
            "üî™ –î–µ–ª–µ–∂ –¥–æ–±—ã—á–∏! –£ —Ç–µ–±—è {minutes} –º–∏–Ω—É—Ç, —á—Ç–æ–±—ã –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è –∫–∏–Ω—É—Ç—å –ø–æ–¥–µ–ª—å–Ω–∏–∫–æ–≤! –ñ–º–∏ –∫–Ω–æ–ø–∫—É –≤ –õ–°!",
            "üí∞ –î–µ–Ω—å–≥–∏ –Ω–∞ —Å—Ç–æ–ª–µ, –∫–∞–∂–¥—ã–π —Ö–æ—á–µ—Ç —É—Ä–≤–∞—Ç—å –∫—É—Å–æ–∫ –ø–æ–∂–∏—Ä–Ω–µ–µ! –í—ã–±–∏—Ä–∞–π –≤ –ª–∏—á–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏—è—Ö!",
            "‚öîÔ∏è –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Ä–∞—Å–ø–∏–ª! –ü—Ä–æ–≤–µ—Ä—å –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –±–æ—Ç–æ–º!"
        ],
        "phrases_betray_attempt": [
            "üî™ {name} —Ä–µ—à–∞–µ—Ç –∫–∏–Ω—É—Ç—å –∫–æ–≥–æ-—Ç–æ –∏–∑ —Å–≤–æ–∏—Ö... –ë–∞—Ä–∞–±–∞–Ω–Ω–∞—è –¥—Ä–æ–±—å...",
            "üòà {name} –∑–∞–¥—É–º–∞–ª –Ω–µ–¥–æ–±—Ä–æ–µ, —Ö–æ—á–µ—Ç –æ–±—á–∏—Å—Ç–∏—Ç—å –∫–∞—Ä–º–∞–Ω—ã –ø–æ–¥–µ–ª—å–Ω–∏–∫–æ–≤!",
            "üÉè {name} –¥–æ—Å—Ç–∞—ë—Ç –∫—Ä–∞–ø–ª—ë–Ω—ã–µ –∫–∞—Ä—Ç—ã –∏ –∏—â–µ—Ç –∂–µ—Ä—Ç–≤—É..."
        ],
        "phrases_betray_success": [
            "üî™ {name} (@{username}) –∫–∏–Ω—É–ª {target} –∏ —É—Ä–≤–∞–ª +{amount}$! –•–∞-—Ö–∞, –±–µ–¥–Ω—è–≥–∞ –¥–∞–∂–µ –Ω–µ –ø–æ–Ω—è–ª, —á—Ç–æ –ø—Ä–æ–∏–∑–æ—à–ª–æ!",
            "üÉè {name} (@{username}) –ø–æ–¥—Å—Ç–∞–≤–∏–ª {target} –ø–æ–¥ –º–µ–Ω—Ç–æ–≤ –∏ –∑–∞–±—Ä–∞–ª –µ–≥–æ –¥–æ–ª—é. +{amount}$! {target} —Ç–µ–ø–µ—Ä—å –≤ –±–µ–≥–∞—Ö!",
            "üòà {name} (@{username}) —É–±–µ–¥–∏–ª {target}, —á—Ç–æ –æ–Ω–∏ —Å–æ—é–∑–Ω–∏–∫–∏, –∏ –æ–±—á–∏—Å—Ç–∏–ª –µ–≥–æ –∫–∞—Ä–º–∞–Ω—ã. +{amount}$! –î–æ–≤–µ—Ä–∏–µ ‚Äî –æ–ø–∞—Å–Ω–∞—è —à—Ç—É–∫–∞!",
            "üí∏ {name} (@{username}) —Å–∫–∞–∑–∞–ª {target}, —á—Ç–æ –¥–µ–Ω—å–≥–∏ –Ω—É–∂–Ω–æ —Å–ø—Ä—è—Ç–∞—Ç—å, –∏‚Ä¶ —Å–ø—Ä—è—Ç–∞–ª –∏—Ö –≤ —Å–≤–æ–π –∫–∞—Ä–º–∞–Ω. +{amount}$!",
            "ü§° {name} (@{username}) –ø–µ—Ä–µ–æ–¥–µ–ª—Å—è –±–∞–±—É—à–∫–æ–π –∏ –≤—ã–ø—Ä–æ—Å–∏–ª —É {target} –µ–≥–æ –¥–æ–ª—é ¬´–Ω–∞ –º–æ–ª–æ—á–∫–æ¬ª. +{amount}$!",
            "üé≠ {name} (@{username}) —Ä–∞–∑—ã–≥—Ä–∞–ª —Ü–µ–ª—ã–π —Å–ø–µ–∫—Ç–∞–∫–ª—å, –∏ {target} —Å–∞–º –æ—Ç–¥–∞–ª –µ–º—É –¥–µ–Ω—å–≥–∏. +{amount}$! –û—Å–∫–∞—Ä –∑–∞ –ª—É—á—à—É—é –º—É–∂—Å–∫—É—é —Ä–æ–ª—å!"
        ],
        "phrases_betray_fail": [
            "üòÖ {name} (@{username}) –ø–æ–ø—ã—Ç–∞–ª—Å—è –∫–∏–Ω—É—Ç—å {target}, –Ω–æ –∑–∞–ø—É—Ç–∞–ª—Å—è –≤ —Å–≤–æ–∏—Ö –∂–µ —à—Ç–∞–Ω–∞—Ö –∏ –ø–æ—Ç–µ—Ä—è–ª {amount}$",
            "ü§° {name} (@{username}) —Ö–æ—Ç–µ–ª –æ–±–º–∞–Ω—É—Ç—å {target}, –Ω–æ —Ç–æ—Ç –æ–∫–∞–∑–∞–ª—Å—è —Ö–∏—Ç—Ä–µ–µ. –®—Ç—Ä–∞—Ñ {amount}$",
            "üíî {name} (@{username}) –Ω–µ—É–¥–∞—á–Ω–æ –ø–æ–¥—Å—Ç–∞–≤–∏–ª—Å—è –∏ —Ç–µ–ø–µ—Ä—å –¥–æ–ª–∂–µ–Ω {target} {amount}$",
            "üòÇ {name} (@{username}) —Å–ø–æ—Ç–∫–Ω—É–ª—Å—è –æ –ø–æ—Ä–æ–≥ –∏ –≤—Å–µ –¥–µ–Ω—å–≥–∏ –≤—ã—Å—ã–ø–∞–ª–∏—Å—å –Ω–∞ –ø–æ–ª. {target} –ø–æ–¥–æ–±—Ä–∞–ª {amount}$!",
            "üêî {name} (@{username}) —Ç–∞–∫ –∏—Å–ø—É–≥–∞–ª—Å—è, —á—Ç–æ –∑–∞–∫—É–¥–∞—Ö—Ç–∞–ª –∏ –ø—Ä–∏–≤–ª—ë–∫ –≤–Ω–∏–º–∞–Ω–∏–µ –ø–æ–ª–∏—Ü–∏–∏. –ü—Ä–∏—à–ª–æ—Å—å –æ—Ç–∫—É–ø–∞—Ç—å—Å—è {amount}$.",
            "üçå {name} (@{username}) –ø–æ—Å–∫–æ–ª—å–∑–Ω—É–ª—Å—è –Ω–∞ –±–∞–Ω–∞–Ω–æ–≤–æ–π –∫–æ–∂—É—Ä–µ –∏ —É—Ä–æ–Ω–∏–ª {amount}$. {target} –ø–æ–¥–æ–±—Ä–∞–ª –∏ –¥–æ–≤–æ–ª—å–Ω–æ —É–ª—ã–±–∞–µ—Ç—Å—è."
        ],
        "phrases_result": [
            "üèÅ –ù–∞–ª—ë—Ç –∑–∞–≤–µ—Ä—à—ë–Ω! –£—á–∞—Å—Ç–Ω–∏–∫–∏ –ø–æ–¥–µ–ª–∏–ª–∏ –¥–æ–±—ã—á—É!\nüèÜ –¢–æ–ø –≤–æ—Ä–æ–≤:\n{top}",
            "üí∞ –í—Å–µ —Ü–µ–ª—ã, –¥–µ–Ω—å–≥–∏ –ø–æ–¥–µ–ª–µ–Ω—ã. –î–æ –Ω–æ–≤—ã—Ö –≤—Å—Ç—Ä–µ—á!\nüëë –õ—É—á—à–∏–µ: {top}",
            "üéâ –£—Ä–∞! –ú—ã —Å–ø—Ä–∞–≤–∏–ª–∏—Å—å! –ö–∞–∂–¥—ã–π –ø–æ–ª—É—á–∏–ª —Å–≤–æ—ë.\nüèÖ –ë–æ–ª—å—à–µ –≤—Å–µ—Ö —É—Ä–≤–∞–ª(–∏): {top}"
        ]
    },
    "bank": {
        "name": "üè¶ –ë–∞–Ω–∫",
        "keyword": "–ì–†–ê–ë–ò–ú",
        "phrases_start": [
            "üî¥ –ë–∞–Ω–∫–æ–≤—Å–∫–∏–π –±—Ä–æ–Ω–µ–≤–∏–∫ –∑–∞—Å—Ç—Ä—è–ª –≤ –ø—Ä–æ–±–∫–µ! –ö—É—á–∞ –¥–µ–Ω–µ–≥ –≤–Ω—É—Ç—Ä–∏! –ü–∏—à–∏ **–ì–†–ê–ë–ò–ú**",
            "üè¶ –û–≥—Ä–∞–±–ª–µ–Ω–∏–µ –≤–µ–∫–∞! –ì–æ–≤–æ—Ä—è—Ç, —Ç–∞–º –º–∏–ª–ª–∏–æ–Ω—ã! –ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Å—è, –ø–∏—à–∏ **–ì–†–ê–ë–ò–ú**",
            "üí∞ –ë–∞–Ω–∫ —Ç–æ–ª—å–∫–æ —á—Ç–æ –ø–æ–ª—É—á–∏–ª –∫—Ä—É–ø–Ω—É—é —Å—É–º–º—É! –£—Å–ø–µ–≤–∞–π! –ü–∏—à–∏ **–ì–†–ê–ë–ò–ú**",
            "üî¥ –°–∏–≥–Ω–∞–ª–∏–∑–∞—Ü–∏—è —Å–ª–æ–º–∞–Ω–∞, –æ—Ö—Ä–∞–Ω–∞ –≤ –æ—Ç–ø—É—Å–∫–µ! –õ–µ–≥–∫–∏–µ –¥–µ–Ω—å–≥–∏! –ü–∏—à–∏ **–ì–†–ê–ë–ò–ú**",
            "üè¶ –î–µ–Ω—å–≥–∏ —Å–∞–º–∏ –ø–ª—ã–≤—É—Ç –≤ —Ä—É–∫–∏! –ü–∏—à–∏ **–ì–†–ê–ë–ò–ú**"
        ],
        "phrases_join": [
            "‚úÖ {name} –≤ –¥–µ–ª–µ!",
            "üî´ {name} –∑–∞—Ä—è–¥–∏–ª –æ–±—Ä–µ–∑ –∏ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è",
            "üïµÔ∏è {name} —É–∂–µ –≤–Ω—É—Ç—Ä–∏!"
        ],
        "phrases_split": [
            "üî™ –î–µ–ª–∏–º –±–∞–±–∫–∏! –£ —Ç–µ–±—è {minutes} –º–∏–Ω—É—Ç –Ω–∞ –∫–∏–¥–∞–ª–æ–≤–æ! –°–º–æ—Ç—Ä–∏ –õ–°!"
        ],
        "phrases_betray_attempt": [
            "üî™ {name} –ø—Ä–∏–º–µ—Ä—è–µ—Ç—Å—è, –∫–æ–≥–æ –±—ã –∫–∏–Ω—É—Ç—å...",
            "üòè {name} —Ö–∏—Ç—Ä–æ —É–ª—ã–±–∞–µ—Ç—Å—è –∏ –∑–∞–Ω–æ—Å–∏—Ç —Ä—É–∫—É –Ω–∞–¥ —á—É–∂–æ–π –¥–æ–ª–µ–π..."
        ],
        "phrases_betray_success": [
            "üî™ {name} (@{username}) –∫–∏–Ω—É–ª {target} –Ω–∞ {amount}$! –¢–æ—Ç –≤ —à–æ–∫–µ!",
            "üíº {name} (@{username}) –ø—Ä–µ–¥–ª–æ–∂–∏–ª {target} ¬´–ø–æ–¥–µ—Ä–∂–∞—Ç—å¬ª –µ–≥–æ –¥–æ–ª—é –∏ –∏—Å—á–µ–∑ —Å {amount}$!",
            "üé© {name} (@{username}) —Ñ–æ–∫—É—Å–Ω–∏–∫! {target} –Ω–µ –∑–∞–º–µ—Ç–∏–ª, –∫–∞–∫ {amount}$ –ø–µ—Ä–µ–∫–æ—á–µ–≤–∞–ª–∏ –≤ —á—É–∂–æ–π –∫–∞—Ä–º–∞–Ω."
        ],
        "phrases_betray_fail": [
            "üòÖ {name} (@{username}) –æ–±–ª–∞–∂–∞–ª—Å—è –∏ –ø–æ—Ç–µ—Ä—è–ª {amount}$",
            "ü§ï {name} (@{username}) –ø–æ–ª—É—á–∏–ª –ø–æ –≥–æ–ª–æ–≤–µ –æ—Ç {target} –∏ –ª–∏—à–∏–ª—Å—è {amount}$",
            "ü´£ {name} (@{username}) —Ç–∞–∫ –¥–æ–ª–≥–æ —Ü–µ–ª–∏–ª—Å—è, —á—Ç–æ {target} —Å–∞–º —É –Ω–µ–≥–æ —É–∫—Ä–∞–ª {amount}$"
        ],
        "phrases_result": [
            "üèÅ –ù–∞–ª—ë—Ç –Ω–∞ –±–∞–Ω–∫ –∑–∞–≤–µ—Ä—à—ë–Ω!\nüèÜ –õ—É—á—à–∏–µ: {top}",
        ]
    },
    "crypto": {
        "name": "‚Çø –ö—Ä–∏–ø—Ç–æ–º–∞—Ç",
        "keyword": "–ö–†–ò–ü–¢–ê",
        "phrases_start": [
            "üü¢ –ù–æ–≤—ã–π –∫—Ä–∏–ø—Ç–æ–º–∞—Ç –≤ –≥–æ—Ä–æ–¥–µ! –ì–æ–≤–æ—Ä—è—Ç, —Ç–∞–º –ø–æ–ª–Ω–æ –±–∏—Ç–∫–æ–∏–Ω–æ–≤! –ö—Ç–æ —É—Å–ø–µ–µ—Ç –≤–≤–µ—Å—Ç–∏ –∫–æ–¥ **–ö–†–ò–ü–¢–ê** - —Å–Ω–∏–º–∞–µ—Ç –±–æ–Ω—É—Å!",
            "‚Çø –ë–∏—Ç–∫–æ–∏–Ω-—Ç–µ—Ä–º–∏–Ω–∞–ª –Ω–µ –∑–∞—â–∏—â—ë–Ω! –ü–∏—à–∏ **–ö–†–ò–ü–¢–ê**, –ø–æ–∫–∞ –µ–≥–æ –Ω–µ –æ–ø—É—Å—Ç–æ—à–∏–ª–∏",
            "üíé –°—Ä–æ—á–Ω–æ! –£—è–∑–≤–∏–º–æ—Å—Ç—å –≤ –∫—Ä–∏–ø—Ç–æ–æ–±–º–µ–Ω–Ω–∏–∫–µ! –ü–∏—à–∏ **–ö–†–ò–ü–¢–ê**",
            "üü¢ –ö—Ä–∏–ø—Ç–æ–ª–æ–º–∫–∞! –£—Å–ø–µ–≤–∞–π –ø–∏—Å–∞—Ç—å **–ö–†–ò–ü–¢–ê**",
            "‚Çø –ë–∏—Ç–∫–æ–∏–Ω—ã —Å–∞–º–∏ –ª–µ–∑—É—Ç –≤ —Ä—É–∫–∏! –ü–∏—à–∏ **–ö–†–ò–ü–¢–ê**"
        ],
        "phrases_join": [
            "‚úÖ {name} –≤ —Ç–µ–º–µ!",
            "üíª {name} –≤–∑–ª–æ–º–∞–ª —Ç–µ—Ä–º–∏–Ω–∞–ª!"
        ],
        "phrases_split": [
            "üî™ –î–µ–ª–∏–º –∫—Ä–∏–ø—Ç—É! –£ —Ç–µ–±—è {minutes} –º–∏–Ω—É—Ç –Ω–∞ –∫–∏–¥–∞–ª–æ–≤–æ! –ñ–¥–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –±–æ—Ç–∞."
        ],
        "phrases_betray_attempt": [
            "üî™ {name} –ø—ã—Ç–∞–µ—Ç—Å—è –ø–µ—Ä–µ–ø–∏—Å–∞—Ç—å —Å–º–∞—Ä—Ç-–∫–æ–Ω—Ç—Ä–∞–∫—Ç –≤ —Å–≤–æ—é –ø–æ–ª—å–∑—É..."
        ],
        "phrases_betray_success": [
            "üî™ {name} (@{username}) –∫–∏–Ω—É–ª {target} –∏ —É—Ä–≤–∞–ª {amount}$ –≤ BTC! –¢–µ–ø–µ—Ä—å —É {target} –æ–¥–Ω–∏ —Å–ª—ë–∑—ã.",
            "üí∏ {name} (@{username}) —É–±–µ–¥–∏–ª {target}, —á—Ç–æ –∫—Ä–∏–ø—Ç–∞ —É–ø–∞–¥–µ—Ç, –∏ —Ç–æ—Ç –ø—Ä–æ–¥–∞–ª —Å–≤–æ–∏ –º–æ–Ω–µ—Ç—ã {name} –∑–∞ –±–µ—Å—Ü–µ–Ω–æ–∫. +{amount}$"
        ],
        "phrases_betray_fail": [
            "üòÖ {name} (@{username}) –ø–æ—Ç–µ—Ä—è–ª {amount}$ –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ –∫–∏–¥–∫–∞",
            "üñ•Ô∏è {name} (@{username}) –∑–∞–±—ã–ª –ø–∞—Ä–æ–ª—å –æ—Ç –∫–æ—à–µ–ª—å–∫–∞ –∏ –ø–æ—Ç–µ—Ä—è–ª {amount}$"
        ],
        "phrases_result": [
            "üèÅ –ö—Ä–∏–ø—Ç–æ–Ω–∞–ª—ë—Ç –∑–∞–≤–µ—Ä—à—ë–Ω!\nüèÜ –õ–∏–¥–µ—Ä—ã: {top}",
        ]
    },
    "narko": {
        "name": "üíä –ù–∞—Ä–∫–æ–ª–∞–±–æ—Ä–∞—Ç–æ—Ä–∏—è",
        "keyword": "–ù–ê–Å–ú",
        "phrases_start": [
            "üü£ –ù–∞–µ—Ö–∞–ª–∏ –Ω–∞ –Ω–∞—Ä–∫–æ–ª–∞–±–æ—Ä–∞—Ç–æ—Ä–∏—é! –¢–∞–º —Ü–µ–ª—ã–π —Å–∫–ª–∞–¥ —Ç–æ–≤–∞—Ä–∞! –ó–∞–±–∏—Ä–∞–µ–º –≤—Å—ë! –ü–∏—à–∏ **–ù–ê–Å–ú**",
            "üíä –ö–æ–Ω–∫—É—Ä–µ–Ω—Ç—ã –æ—Å—Ç–∞–≤–∏–ª–∏ —Å–∫–ª–∞–¥ –±–µ–∑ –æ—Ö—Ä–∞–Ω—ã! –ü–∏—à–∏ **–ù–ê–Å–ú**, –±—ã—Å—Ç—Ä–æ!",
            "üß™ –õ–∞–±–æ—Ä–∞—Ç–æ—Ä–∏—è —Å–∏–Ω—Ç–µ–∑–∞! –ì–æ–≤–æ—Ä—è—Ç, —Ç–∞–º –≥–æ—Ä—ã –¥–µ–Ω–µ–≥! –ö—Ç–æ —É—Å–ø–µ–µ—Ç –Ω–∞–ø–∏—Å–∞—Ç—å **–ù–ê–Å–ú** - –ø–æ–ª—É—á–∏—Ç –¥–æ–ª—é",
            "üü£ –•–∏–º–∏–∫–∏ —Ä–∞–∑–±–µ–∂–∞–ª–∏—Å—å, —Ç–æ–≤–∞—Ä –æ—Å—Ç–∞–ª—Å—è! –ü–∏—à–∏ **–ù–ê–Å–ú**",
            "üíä –ö—Ä–∏—Å—Ç–∞–ª–ª—ã —á–∏—Å—Ç–µ–π—à–∏–µ! –ü–∏—à–∏ **–ù–ê–Å–ú**"
        ],
        "phrases_join": [
            "‚úÖ {name} –Ω—é—Ö–Ω—É–ª –∏ –≤ –¥–µ–ª–µ!",
            "üíâ {name} –ø–æ–¥ –∫–∞–π—Ñ–æ–º, –Ω–æ –≤ –¥–µ–ª–µ!"
        ],
        "phrases_split": [
            "üî™ –î–µ–ª–∏–º —Ç–æ–≤–∞—Ä! –£ —Ç–µ–±—è {minutes} –º–∏–Ω—É—Ç! –ñ–¥–∏ –∫–Ω–æ–ø–∫–∏ –≤ –õ–°."
        ],
        "phrases_betray_attempt": [
            "üî™ {name} –ø–æ–¥–º–µ—à–∏–≤–∞–µ—Ç —á—Ç–æ-—Ç–æ –≤ –∫–æ—Ñ–µ –ø–æ–¥–µ–ª—å–Ω–∏–∫–∞–º..."
        ],
        "phrases_betray_success": [
            "üî™ {name} (@{username}) –ø–æ–¥—Å—Ç–∞–≤–∏–ª {target} –º–µ–Ω—Ç–∞–º –∏ –∑–∞–±—Ä–∞–ª –µ–≥–æ –¥–æ–ª—é +{amount}$",
            "ü•¥ {name} (@{username}) —É–±–µ–¥–∏–ª {target}, —á—Ç–æ —ç—Ç–æ –Ω–µ –µ–≥–æ –¥–æ–ª—è, –∞ –º—É–∫–∞. {target} –ø–æ–≤–µ—Ä–∏–ª –∏ –æ—Ç–¥–∞–ª {amount}$"
        ],
        "phrases_betray_fail": [
            "üòÖ {name} (@{username}) –ø–µ—Ä–µ–ø—É—Ç–∞–ª –º–µ—à–∫–∏ –∏ –ø–æ—Ç–µ—Ä—è–ª {amount}$",
            "ü§¢ {name} (@{username}) —Ç–∞–∫ –Ω–∞–Ω—é—Ö–∞–ª—Å—è, —á—Ç–æ —Å–∞–º –æ—Ç–¥–∞–ª {target} {amount}$"
        ],
        "phrases_result": [
            "üèÅ –õ–∞–±–æ—Ä–∞—Ç–æ—Ä–∏—è —Ä–∞–∑–≥—Ä–∞–±–ª–µ–Ω–∞!\nüèÜ –¢–æ–ø –¥–æ–±—ã—Ç—á–∏–∫–æ–≤: {top}",
        ]
    },
    "weapon": {
        "name": "üî´ –û—Ä—É–∂–µ–π–Ω—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä",
        "keyword": "–°–¢–í–û–õ",
        "phrases_start": [
            "üî´ –û—Ä—É–∂–µ–π–Ω—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —É–ø–∞–ª —Å –≥—Ä—É–∑–æ–≤–∏–∫–∞! –¢–∞–º —Å—Ç–≤–æ–ª–æ–≤ –Ω–∞ –º–∏–ª–ª–∏–æ–Ω! –ö—Ç–æ —É—Å–ø–µ–µ—Ç –Ω–∞–ø–∏—Å–∞—Ç—å **–°–¢–í–û–õ** - –ø–æ–ª—É—á–∏—Ç –≤—Å—ë!",
            "üí• –ö–æ–Ω—Ñ–∏—Å–∫–∞—Ç! –û—Ä—É–∂–∏–µ –±–µ–∑ –ø—Ä–∏—Å–º–æ—Ç—Ä–∞! –ü–∏—à–∏ **–°–¢–í–û–õ**",
            "‚ö°Ô∏è –°—Ä–æ—á–Ω–æ! –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å –æ—Ä—É–∂–∏–µ–º! –ü–∏—à–∏ **–°–¢–í–û–õ**",
            "üî´ –ê–≤—Ç–æ–º–∞—Ç—ã –ø–æ —Ü–µ–Ω–µ –ø–∏—Ä–æ–∂–∫–æ–≤! –ü–∏—à–∏ **–°–¢–í–û–õ**",
            "üí£ –Ø—â–∏–∫ —Å —Ç—Ä–æ—Ç–∏–ª–æ–º! –ü–∏—à–∏ **–°–¢–í–û–õ**, –ø–æ–∫–∞ –Ω–µ –ø–æ–∑–¥–Ω–æ"
        ],
        "phrases_join": [
            "‚úÖ {name} –≤–æ–æ—Ä—É–∂–∏–ª—Å—è –∏ –≥–æ—Ç–æ–≤!",
            "üíÇ {name} –∑–∞—Ö–≤–∞—Ç–∏–ª —è—â–∏–∫ —Å –ø–∞—Ç—Ä–æ–Ω–∞–º–∏!"
        ],
        "phrases_split": [
            "üî™ –î–µ–ª–∏–º —Å—Ç–≤–æ–ª—ã! –£ —Ç–µ–±—è {minutes} –º–∏–Ω—É—Ç! –û—Ç–∫—Ä—ã–≤–∞–π –õ–°."
        ],
        "phrases_betray_attempt": [
            "üî™ {name} –ø–µ—Ä–µ–¥—ë—Ä–≥–∏–≤–∞–µ—Ç –∑–∞—Ç–≤–æ—Ä, —Ü–µ–ª—è—Å—å –≤ –ø–æ–¥–µ–ª—å–Ω–∏–∫–æ–≤..."
        ],
        "phrases_betray_success": [
            "üî™ {name} (@{username}) –∫–∏–Ω—É–ª {target} –Ω–∞ {amount}$ –∏ –¥–∞–ª –µ–º—É –ø–∏–Ω–∫–∞!",
            "üí• {name} (@{username}) –≤—ã—Å—Ç—Ä–µ–ª–∏–ª –≤ –≤–æ–∑–¥—É—Ö, {target} –∏—Å–ø—É–≥–∞–ª—Å—è –∏ –æ—Ç–¥–∞–ª {amount}$"
        ],
        "phrases_betray_fail": [
            "üòÖ {name} (@{username}) –ø—Ä–æ—Å—Ç—Ä–µ–ª–∏–ª —Å–µ–±–µ –Ω–æ–≥—É –∏ –ø–æ—Ç–µ—Ä—è–ª {amount}$",
            "üî´ {name} (@{username}) —Ç–∞–∫ —Ü–µ–ª–∏–ª—Å—è, —á—Ç–æ –≤—ã—Ä–æ–Ω–∏–ª {amount}$ –∏ {target} –ø–æ–¥–æ–±—Ä–∞–ª"
        ],
        "phrases_result": [
            "üèÅ –û—Ä—É–∂–∏–µ –ø—Ä–æ–¥–∞–Ω–æ!\nüèÜ –õ—É—á—à–∏–µ –≤–æ—Ä—ã: {top}",
        ]
    }
}

# ==================== –§–†–ê–ó–´ –î–õ–Ø –ö–û–ù–¢–†–ê–ë–ê–ù–î–´ ====================
SMUGGLE_START_PHRASES = [
    "üõ•Ô∏è {name}, —Ç—ã –æ—Ç–ø—Ä–∞–≤–ª—è–µ—à—å—Å—è –≤ –∫–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥–Ω—ã–π —Ä–µ–π—Å —Å –≥—Ä—É–∑–æ–º {cargo}. –í–µ—Ä–Ω—ë—à—å—Å—è —á–µ—Ä–µ–∑ {duration} –º–∏–Ω. –£–¥–∞—á–∏, –º–æ—Ä—è–∫!",
    "‚õµ {name}, —Ç–≤–æ—è –ª–æ–¥–∫–∞ –≥–æ—Ç–æ–≤–∞. –ì—Ä—É–∑: {cargo}. –í–µ—Ç–µ—Ä –ø–æ–ø—É—Ç–Ω—ã–π, –≤–µ—Ä–Ω—ë—à—å—Å—è —á–µ—Ä–µ–∑ {duration} –º–∏–Ω.",
    "üö§ {name}, —Ç—ã —Ç–∞–π–Ω–æ –≥—Ä—É–∑–∏—à—å {cargo} –Ω–∞ –∫–∞—Ç–µ—Ä. –ü–æ–≥—Ä–∞–Ω–∏—á–Ω–∏–∫–∏ –Ω–µ –¥—Ä–µ–º–ª—é—Ç, –Ω–æ —Ç—ã —Ä–∏—Å–∫–æ–≤—ã–π. –†–µ–∑—É–ª—å—Ç–∞—Ç —á–µ—Ä–µ–∑ {duration} –º–∏–Ω.",
    "üì¶ {name}, —Ç—ã —Å–ø—Ä—è—Ç–∞–ª {cargo} –≤ –¥–≤–æ–π–Ω–æ–º –¥–Ω–µ. –í—ã—Ö–æ–¥–∏ –≤ –º–æ—Ä–µ, —Ä–µ–∑—É–ª—å—Ç–∞—Ç —á–µ—Ä–µ–∑ {duration} –º–∏–Ω.",
    "‚öì {name}, —Ç–≤–æ–π –º–∞—Ä—à—Ä—É—Ç –ø—Ä–æ–ª–µ–≥–∞–µ—Ç —á–µ—Ä–µ–∑ –æ–ø–∞—Å–Ω—ã–µ –≤–æ–¥—ã. –ì—Ä—É–∑: {cargo}. –£–¥–∞—á–∏! –ñ–¥–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —á–µ—Ä–µ–∑ {duration} –º–∏–Ω.",
    "üö£ {name}, —Ç—ã –≤–∑—è–ª –Ω–∞–¥—É–≤–Ω—É—é –ª–æ–¥–∫—É –∏ {cargo}. –ì–ª–∞–≤–Ω–æ–µ ‚Äì –Ω–µ –ø—Ä–æ—Ç–∫–Ω–∏. –í–µ—Ä–Ω—ë—à—å—Å—è —á–µ—Ä–µ–∑ {duration} –º–∏–Ω.",
    "üõ∂ {name}, —Ç—ã –ø—Ä–∏—Ç–≤–æ—Ä–∏–ª—Å—è —Ä—ã–±–∞–∫–æ–º, –∞ –ø–æ–¥ —É–ª–æ–≤–æ–º {cargo}. –í–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ —á–µ—Ä–µ–∑ {duration} –º–∏–Ω.",
    "üöÅ {name}, —É —Ç–µ–±—è –µ—Å—Ç—å –≤–µ—Ä—Ç–æ–ª—ë—Ç! –ì—Ä—É–∑ {cargo} –ø–æ–¥–≤–µ—à–µ–Ω —Å–Ω–∏–∑—É. –ß–µ—Ä–µ–∑ {duration} –º–∏–Ω –±—É–¥–µ—à—å –Ω–∞ –º–µ—Å—Ç–µ."
]

SMUGGLE_SUCCESS_PHRASES = [
    "‚úÖ {name} (@{username}) –≤–∏—Ä—Ç—É–æ–∑–Ω–æ –æ–±–º–∞–Ω—É–ª –ø–æ–≥—Ä–∞–Ω–∏—á–Ω–∏–∫–æ–≤, –ø—Ä–∏—Ç–≤–æ—Ä–∏–≤—à–∏—Å—å —Ä—ã–±–æ–π. –î–æ–±—ã—á–∞: {amount} BTC.",
    "‚úÖ {name} (@{username}) –ø–æ–¥–∫—É–ø–∏–ª –∫–∞–ø–∏—Ç–∞–Ω–∞ —Å—Ç—Ä–∞–∂–∏ –±—É—Ç—ã–ª–∫–æ–π —Ä–æ–º–∞. –ü—Ä–∏–±—ã–ª—å: {amount} BTC.",
    "‚úÖ {name} (@{username}) –ø–µ—Ä–µ–æ–¥–µ–ª—Å—è –≤ –∂–µ–Ω—â–∏–Ω—É –∏ –ø—Ä–æ–Ω—ë—Å {cargo} –≤ –¥–∞–º—Å–∫–æ–π —Å—É–º–æ—á–∫–µ. –ó–∞—Ä–∞–±–æ—Ç–∞–Ω–æ: {amount} BTC.",
    "‚úÖ {name} (@{username}) –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª –ø–æ–¥–≤–æ–¥–Ω—É—é –ª–æ–¥–∫—É –∏–∑ –∫–∞—Ä—Ç–æ–Ω–∞. –ö–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥–∞ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–∞! +{amount} BTC.",
    "‚úÖ {name} (@{username}) –Ω–∞–∫–æ—Ä–º–∏–ª —Ç–∞–º–æ–∂–µ–Ω–Ω–∏–∫–æ–≤ –≥–∞–ª–ª—é—Ü–∏–Ω–æ–≥–µ–Ω–Ω—ã–º–∏ –≥—Ä–∏–±–∞–º–∏, –æ–Ω–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –∑–∞–º–µ—Ç–∏–ª–∏. –í—ã—Ä—É—á–∫–∞: {amount} BTC.",
    "‚úÖ {name} (@{username}) –ø—Ä–∏—Ç–≤–æ—Ä–∏–ª—Å—è –¥–µ–ª—å—Ñ–∏–Ω–æ–º –∏ –ø—Ä–æ–ø–ª—ã–ª –º–∏–º–æ —Ä–∞–¥–∞—Ä–æ–≤. –£–ª–æ–≤: {amount} BTC.",
    "‚úÖ {name} (@{username}) –∑–∞–∫–æ–ø–∞–ª {cargo} –≤ –ø–µ—Å–∫–µ, –∞ —Å–≤–µ—Ä—Ö—É –ø–æ—Å—Ç—Ä–æ–∏–ª –∑–∞–º–æ–∫. –û—Ç–ª–∏—á–Ω–∞—è –º–∞—Å–∫–∏—Ä–æ–≤–∫–∞! +{amount} BTC.",
    "‚úÖ {name} (@{username}) –ø–æ–¥–∫—É–ø–∏–ª –Ω–∞—á–∞–ª—å–Ω–∏–∫–∞ –ø–æ—Ä—Ç–∞ —è—â–∏–∫–æ–º –∫–æ–Ω—å—è–∫–∞. –¢–æ–≤–∞—Ä –Ω–∞ –º–µ—Å—Ç–µ. –ó–∞—Ä–∞–±–æ—Ç–∞–Ω–æ: {amount} BTC.",
    "‚úÖ {name} (@{username}) –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª –¥—Ä–µ—Å—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ç—é–ª–µ–Ω–µ–π –¥–ª—è –ø–µ—Ä–µ–ø—Ä–∞–≤–∫–∏. –¢–∞–º–æ–∂–Ω—è –≤ —à–æ–∫–µ! +{amount} BTC.",
    "‚úÖ {name} (@{username}) –ø—Ä–∏–∫–∏–Ω—É–ª—Å—è —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–º —Å–ø–µ—Ü—Å–≤—è–∑–∏ –∏ –±–µ—Å–ø—Ä–µ–ø—è—Ç—Å—Ç–≤–µ–Ω–Ω–æ –ø—Ä–æ–µ—Ö–∞–ª. –î–æ–±—ã—á–∞: {amount} BTC."
]

SMUGGLE_FAIL_PHRASES = [
    "‚ùå {name} (@{username}) –∑–∞–ø—É—Ç–∞–ª—Å—è –≤ —Å–µ—Ç—è—Ö –∏ –±—ã–ª –ø–æ–π–º–∞–Ω —Ä—ã–±–∞–∫–∞–º–∏. –ì—Ä—É–∑ –∫–æ–Ω—Ñ–∏—Å–∫–æ–≤–∞–Ω.",
    "‚ùå {name} (@{username}) –ø–æ–ø—ã—Ç–∞–ª—Å—è –ø–æ–¥–∫—É–ø–∏—Ç—å –ø–æ–≥—Ä–∞–Ω–∏—á–Ω–∏–∫–∞ –∂–≤–∞—á–∫–æ–π, –Ω–æ —Ç–æ—Ç –æ–∫–∞–∑–∞–ª—Å—è –ø—Ä–∏–Ω—Ü–∏–ø–∏–∞–ª—å–Ω—ã–º. –í—Å—ë –ø—Ä–æ–ø–∞–ª–æ.",
    "‚ùå {name} (@{username}) —É—Å–Ω—É–ª –≤ –ª–æ–¥–∫–µ –∏ –ø—Ä–∏–ø–ª—ã–ª –æ–±—Ä–∞—Ç–Ω–æ –∫ –±–µ—Ä–µ–≥—É. –ì—Ä—É–∑ —É–∫—Ä–∞–ª–∏ —á–∞–π–∫–∏.",
    "‚ùå {name} (@{username}) –ø–µ—Ä–µ–ø—É—Ç–∞–ª –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏ –ø—Ä–∏–ø–ª—ã–ª –≤ –æ—Ç–∫—Ä—ã—Ç–æ–µ –º–æ—Ä–µ –±–µ–∑ –≥–æ—Ä—é—á–µ–≥–æ. –°–ø–∞—Å–∞—Ç–µ–ª–∏ –Ω–∞—à–ª–∏, –Ω–æ –≥—Ä—É–∑ —É—Ç–æ–Ω—É–ª.",
    "‚ùå {name} (@{username}) —Ç–∞–∫ –±–æ—è–ª—Å—è, —á—Ç–æ –Ω–∞–ª–æ–∂–∏–ª –≤ —à—Ç–∞–Ω—ã, –∏ –∑–∞–ø–∞—Ö –ø—Ä–∏–≤–ª—ë–∫ —Å–æ–±–∞–∫-–∏—â–µ–µ–∫. –ö–æ–Ω—Ñ–∏—Å–∫–∞—Ü–∏—è.",
    "‚ùå {name} (@{username}) —Ä–µ—à–∏–ª –ø–ª—ã—Ç—å –Ω–∞ –Ω–∞–¥—É–≤–Ω–æ–π –ª–æ–¥–∫–µ, –Ω–æ –æ–Ω–∞ –ª–æ–ø–Ω—É–ª–∞. –í—Å–µ —É—Ç–æ–Ω—É–ª–æ.",
    "‚ùå {name} (@{username}) –ø–æ–ø—ã—Ç–∞–ª—Å—è –ø—Ä–æ–≤–µ–∑—Ç–∏ {cargo} –≤ –∂–µ–ª—É–¥–∫–µ, –Ω–æ –Ω–µ —Ä–∞—Å—Å—á–∏—Ç–∞–ª –¥–æ–∑—É. –°–∫–æ—Ä–∞—è —É–≤–µ–∑–ª–∞, —Ç–æ–≤–∞—Ä –∏–∑—ä—è—Ç.",
    "‚ùå {name} (@{username}) —Ö–≤–∞—Å—Ç–∞–ª—Å—è –≤ –±–∞—Ä–µ —Å–≤–æ–∏–º –ø–ª–∞–Ω–æ–º, –∏ –µ–≥–æ —Å–¥–∞–ª –±–∞—Ä–º–µ–Ω. –ì—Ä—É–∑ –∫–æ–Ω—Ñ–∏—Å–∫–æ–≤–∞–Ω.",
    "‚ùå {name} (@{username}) –ø–µ—Ä–µ–ø—É—Ç–∞–ª –º–µ—à–∫–∏ –∏ –≤–º–µ—Å—Ç–æ –∫–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥—ã –ø—Ä–∏–≤—ë–∑ –∫–∞—Ä—Ç–æ—à–∫—É. –ü–æ–∑–æ—Ä –∏ —É–±—ã—Ç–∫–∏.",
    "‚ùå {name} (@{username}) –ø–æ–ø–∞–ª –≤ —à—Ç–æ—Ä–º –∏ –≤—ã–±—Ä–æ—Å–∏–ª –≥—Ä—É–∑ –∑–∞ –±–æ—Ä—Ç, —á—Ç–æ–±—ã —Å–ø–∞—Å—Ç–∏—Å—å. –ù–∏—á–µ–≥–æ –Ω–µ –∑–∞—Ä–∞–±–æ—Ç–∞–ª."
]

# ==================== –§–†–ê–ó–´ –î–õ–Ø –¢–Æ–†–¨–ú–´ ====================
JAIL_START_PHRASES = [
    "üöî {name}, —Ç—ã –ø–æ–ø–∞–ª—Å—è –Ω–∞ –∫—Ä–∞–∂–µ –ø–∞—Ä—ã —è–∏—Ü! –°—É–¥—å—è –ø—Ä–∏–≥–æ–≤–æ—Ä–∏–ª —Ç–µ–±—è –∫ {duration} –º–∏–Ω—É—Ç–∞–º —Ç—é—Ä—å–º—ã. –°–∏–¥–∏ –∏ –¥—É–º–∞–π –æ –ø–æ–≤–µ–¥–µ–Ω–∏–∏!",
    "üîí {name}, —Ç—ã –ø–µ—Ä–µ—Ö–æ–¥–∏–ª –¥–æ—Ä–æ–≥—É –≤ –Ω–µ–ø–æ–ª–æ–∂–µ–Ω–Ω–æ–º –º–µ—Å—Ç–µ, –Ω–æ –ø–æ–ª–∏—Ü–µ–π—Å–∫–æ–º—É –Ω–µ –ø–æ–Ω—Ä–∞–≤–∏–ª–∞—Å—å —Ç–≤–æ—è —Ä–æ–∂–∞. {duration} –º–∏–Ω—É—Ç –∑–∞ —Ä–µ—à—ë—Ç–∫–æ–π!",
    "‚õìÔ∏è {name}, —Ç–µ–±—è –∑–∞–º–µ–ª–∏ –∑–∞ —Ä–∞—Å–ø–∏—Ç–∏–µ –ø–∏–≤–∞ —É –º–µ—Ç—Ä–æ. –°—Ä–æ–∫: {duration} –º–∏–Ω—É—Ç.",
    "üèõÔ∏è {name}, —Ç—ã –Ω–µ –∑–∞–ø–ª–∞—Ç–∏–ª –∑–∞ –ø—Ä–æ–µ–∑–¥, –∞ –∫–æ–≥–¥–∞ –∫–æ–Ω—Ç—Ä–æ–ª—ë—Ä —Å–¥–µ–ª–∞–ª –∑–∞–º–µ—á–∞–Ω–∏–µ, –ø–æ—Å–ª–∞–ª –µ–≥–æ. {duration} –º–∏–Ω—É—Ç –≤ –∫–∞–º–µ—Ä–µ.",
    "ü™ë {name}, —Ç–µ–±—è –æ–±–≤–∏–Ω–∏–ª–∏ –≤ –Ω–µ–ø–æ–¥–æ–±–∞—é—â–µ–º –≤–∏–¥–µ. –°—É–¥—å—è –∂–µ–Ω—â–∏–Ω–∞, –µ–π –Ω–µ –ø–æ–Ω—Ä–∞–≤–∏–ª—Å—è —Ç–≤–æ–π –≤–∑–≥–ª—è–¥. {duration} –º–∏–Ω—É—Ç.",
    "üö® {name}, —Ç—ã –ø–æ–ø—ã—Ç–∞–ª—Å—è –¥–∞—Ç—å –≤–∑—è—Ç–∫—É –≥–∞–∏—à–Ω–∏–∫—É –ø–∏—Ä–æ–∂–∫–æ–º. –°—Ä–æ–∫: {duration} –º–∏–Ω—É—Ç.",
    "‚öñÔ∏è {name}, —Ç—ã —É–∫—Ä–∞–ª —É –±–∞–±—É—à–∫–∏ –∫–æ—à–µ–ª—ë–∫, –Ω–æ –±–∞–±—É—à–∫–∞ –æ–∫–∞–∑–∞–ª–∞—Å—å –∂–µ–Ω–æ–π —Å—É–¥—å–∏. {duration} –º–∏–Ω—É—Ç —Ç—é—Ä—å–º—ã.",
    "üöì {name}, —Ç—ã –≥—Ä–æ–º–∫–æ —Å–º–µ—è–ª—Å—è –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫–µ. –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞—Ä—å –≤—ã–∑–≤–∞–ª–∞ –ø–æ–ª–∏—Ü–∏—é. {duration} –º–∏–Ω—É—Ç.",
    "üîê {name}, —Ç—ã –∑–∞–ø—É—Å—Ç–∏–ª —Å–∞–ª—é—Ç –≤–æ –¥–≤–æ—Ä–µ –≤ 3 —á–∞—Å–∞ –Ω–æ—á–∏. –°–æ—Å–µ–¥–∏ –≤—ã–∑–≤–∞–ª–∏ –Ω–∞—Ä—è–¥. {duration} –º–∏–Ω—É—Ç.",
    "ü¶∫ {name}, —Ç–µ–±—è –ø—Ä–∏–Ω—è–ª–∏ –∑–∞ –±–æ–º–∂–∞ –∏ –∑–∞–±—Ä–∞–ª–∏ –≤ –≤—ã—Ç—Ä–µ–∑–≤–∏—Ç–µ–ª—å. {duration} –º–∏–Ω—É—Ç.",
    "üëÆ {name}, —Ç—ã –ø—ã—Ç–∞–ª—Å—è —É–∫—Ä–∞—Å—Ç—å –ø–æ–ª–∏—Ü–µ–π—Å–∫—É—é –º–∞—à–∏–Ω—É, –Ω–æ –∑–∞–±—ã–ª, —á—Ç–æ –æ–Ω–∞ –Ω–∞ —Å–∏–≥–Ω–∞–ª–∏–∑–∞—Ü–∏–∏. –°—Ä–æ–∫ {duration} –º–∏–Ω.",
    "üöî {name}, —Ç–µ–±—è –ø–æ–π–º–∞–ª–∏ –Ω–∞ —Ç–æ—Ä–≥–æ–≤–ª–µ —Ñ–∞–ª—å—à–∏–≤—ã–º–∏ –∞–≤—Ç–æ–≥—Ä–∞—Ñ–∞–º–∏. {duration} –º–∏–Ω—É—Ç."
]

JAIL_SUCCESS_PHRASES = [
    "üéâ {name} (@{username}) —É—Å—Ç—Ä–æ–∏–ª –±—É–Ω—Ç –≤ —Ç—é—Ä—å–º–µ –∏ –∑–∞—Ö–≤–∞—Ç–∏–ª –≤–ª–∞—Å—Ç—å –≤ –∫–∞–º–µ—Ä–µ! –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üëë {name} (@{username}) –ø–æ–¥–∫—É–ø–∏–ª –Ω–∞–¥–∑–∏—Ä–∞—Ç–µ–ª—è –∏ —Ç–µ–ø–µ—Ä—å –∫–æ–º–∞–Ω–¥—É–µ—Ç –º–µ—Å—Ç–Ω—ã–º–∏. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üí™ {name} (@{username}) –Ω–∞–≤–∞–ª—è–ª —Å–º–æ—Ç—Ä—è—â–µ–º—É –∏ —Å—Ç–∞–ª –Ω–æ–≤—ã–º –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–æ–º. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üß† {name} (@{username}) –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞–ª –ø–æ–±–µ–≥, –Ω–æ –µ–≥–æ –ø–æ–π–º–∞–ª–∏, –æ–¥–Ω–∞–∫–æ –≤ —Ç—é—Ä—å–º–µ –µ–≥–æ –∑–∞—É–≤–∞–∂–∞–ª–∏. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üçó {name} (@{username}) –ø–æ–¥–µ–ª–∏–ª—Å—è –ø–∞–π–∫–æ–π —Å –Ω—É–∂–¥–∞—é—â–∏–º–∏—Å—è, —Ç–µ–ø–µ—Ä—å –µ–≥–æ —É–≤–∞–∂–∞—é—Ç. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üìö {name} (@{username}) –Ω–∞—É—á–∏–ª —Å–æ–∫–∞–º–µ—Ä–Ω–∏–∫–æ–≤ —á–∏—Ç–∞—Ç—å –∏ –ø–∏—Å–∞—Ç—å, –≤—Å–µ –≤ –≤–æ—Å—Ç–æ—Ä–≥–µ. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üé§ {name} (@{username}) —Å–ø–µ–ª –≤ —Ç—é—Ä–µ–º–Ω–æ–º —Ö–æ—Ä–µ —Ç–∞–∫, —á—Ç–æ –æ—Ö—Ä–∞–Ω–∞ –ø–ª–∞–∫–∞–ª–∞. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üèãÔ∏è {name} (@{username}) –æ—Ç–∂–∞–ª—Å—è 100 —Ä–∞–∑ –Ω–∞ –≥–ª–∞–∑–∞—Ö —É –≤—Å–µ—Ö, —Ç–µ–ø–µ—Ä—å –µ–≥–æ –±–æ—è—Ç—Å—è. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "‚öîÔ∏è {name} (@{username}) –ø–æ–±–µ–¥–∏–ª –≤ –ø–æ–¥–ø–æ–ª—å–Ω—ã—Ö –±–æ—è—Ö –±–µ–∑ –ø—Ä–∞–≤–∏–ª. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üé≠ {name} (@{username}) –ø–æ—Å—Ç–∞–≤–∏–ª —Å–ø–µ–∫—Ç–∞–∫–ª—å –≤ —Ç—é—Ä—å–º–µ, –≤—Å–µ –∞–ø–ª–æ–¥–∏—Ä–æ–≤–∞–ª–∏. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "ü§ù {name} (@{username}) –ø–æ–¥—Ä—É–∂–∏–ª—Å—è —Å –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞–º–∏, —Ç–µ–ø–µ—Ä—å –∑–∞ –Ω–µ–≥–æ –≥–æ—Ä–æ–π. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üí∞ {name} (@{username}) –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞–ª —Ç—é—Ä–µ–º–Ω—ã–π –±–∏–∑–Ω–µ—Å –ø–æ –ø—Ä–æ–¥–∞–∂–µ —á–∏—Ñ–∏—Ä–∞. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üé≤ {name} (@{username}) –≤—Å–µ—Ö –æ–±—ã–≥—Ä–∞–ª –≤ –∫–∞—Ä—Ç—ã, —Ç–µ–ø–µ—Ä—å –µ–º—É –¥–æ–ª–∂–Ω—ã. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üì¶ {name} (@{username}) –Ω–∞–ª–∞–¥–∏–ª –ø–æ—Å—Ç–∞–≤–∫–∏ –ø–µ—Ä–µ–¥–∞—á, –µ–≥–æ –∑–∞—É–≤–∞–∂–∞–ª–∏. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})"
]

JAIL_FAIL_PHRASES = [
    "üò¢ {name} (@{username}) –±—ã–ª –æ–±–æ—Å—Å–∞–Ω —Å–æ–∫–∞–º–µ—Ä–Ω–∏–∫–∞–º–∏ –∑–∞ —Ç–æ, —á—Ç–æ –Ω–µ –ø–æ–¥–µ–ª–∏–ª—Å—è –ø–∞–π–∫–æ–π. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç –Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üêî {name} (@{username}) —Å—Ç–∞–ª –≥–ª–∞–≤–Ω—ã–º –ø–µ—Ç—É—Ö–æ–º. –í—Å—è –∑–æ–Ω–∞ —Å–ª—ã—à–∞–ª–∞, –∫–∞–∫ –æ–Ω –∫—É–¥–∞—Ö—Ç–∞–ª. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üßπ {name} (@{username}) –ø—Ä–∏—Å–ª—É–∂–∏–≤–∞–ª –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏–∏, –º—ã–ª —Ç—É–∞–ª–µ—Ç—ã. –£–≤–∞–∂–µ–Ω–∏—è –Ω–µ –∑–∞—Å–ª—É–∂–∏–ª. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "ü•¥ {name} (@{username}) –ø–æ–ø—ã—Ç–∞–ª—Å—è —É–±–µ–∂–∞—Ç—å, –Ω–æ —Å–ø–æ—Ç–∫–Ω—É–ª—Å—è –∏ —É–ø–∞–ª –≤ –≤—ã–≥—Ä–µ–±–Ω—É—é —è–º—É. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "ü§° {name} (@{username}) —Ä–∞—Å—Å–∫–∞–∑—ã–≤–∞–ª –∞–Ω–µ–∫–¥–æ—Ç—ã, –Ω–æ –Ω–∏–∫—Ç–æ –Ω–µ —Å–º–µ—è–ª—Å—è, —Ç–æ–ª—å–∫–æ –±–∏–ª–∏. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üé™ {name} (@{username}) –ø—ã—Ç–∞–ª—Å—è –∏–∑–æ–±—Ä–∞–∂–∞—Ç—å —Ü–∏—Ä–∫, –Ω–æ –µ–≥–æ –∑–∞–∫–∏–¥–∞–ª–∏ —Ç—É—Ö–ª—ã–º–∏ —è–π—Ü–∞–º–∏. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "ü•© {name} (@{username}) —É–∫—Ä–∞–ª —É —Å–º–æ—Ç—Ä—è—â–µ–≥–æ –∫—É—Å–æ–∫ —Å–∞–ª–∞ –∏ –±—ã–ª –∂–µ—Å—Ç–æ–∫–æ –∏–∑–±–∏—Ç. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üìû {name} (@{username}) –∑–≤–æ–Ω–∏–ª –º–∞–º–µ –∏ –ø–ª–∞–∫–∞–ª, –Ω–∞–¥ –Ω–∏–º –≤—Å–µ —Å–º–µ—è–ª–∏—Å—å. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üï≥Ô∏è {name} (@{username}) —Å–ø—Ä—è—Ç–∞–ª—Å—è –≤ —Ç—É–∞–ª–µ—Ç–µ, –Ω–æ –µ–≥–æ –Ω–∞—à–ª–∏ –∏ –Ω–∞–∫–∞–∑–∞–ª–∏. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üé≠ {name} (@{username}) –ø—ã—Ç–∞–ª—Å—è –∏–≥—Ä–∞—Ç—å —Ä–æ–ª—å –∫—Ä—É—Ç–æ–≥–æ, –Ω–æ –µ–≥–æ —Ä–∞–∑–æ–±–ª–∞—á–∏–ª–∏. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üçº {name} (@{username}) —Ä–∞—Å–ø–ª–∞–∫–∞–ª—Å—è, –∫–æ–≥–¥–∞ –æ—Ç–æ–±—Ä–∞–ª–∏ —Ç–µ–ª–µ—Ñ–æ–Ω. –í—Å–µ –Ω–∞–∑—ã–≤–∞—é—Ç –µ–≥–æ –º–∞–ª—ã—à–∫–æ–π. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üöΩ {name} (@{username}) —É—Ä–æ–Ω–∏–ª –º—ã–ª–æ –∏ —Ä–µ—à–∏–ª –Ω–µ –ø–æ–¥–Ω–∏–º–∞—Ç—å, —Ç–µ–ø–µ—Ä—å –æ–Ω –º–µ—Å—Ç–Ω–∞—è –ª–µ–≥–µ–Ω–¥–∞. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üßº {name} (@{username}) –º—ã–ª—Å—è –≤ –¥—É—à–µ –¥–æ–ª—å—à–µ –≤—Å–µ—Ö, –µ–≥–æ –∏–∑–±–∏–ª–∏. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üìñ {name} (@{username}) —á–∏—Ç–∞–ª —É–≥–æ–ª–æ–≤–Ω—ã–π –∫–æ–¥–µ–∫—Å –≤—Å–ª—É—Ö, –≤—Å–µ —É—Å–Ω—É–ª–∏. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})"
]

# ==================== –ù–ê–°–¢–†–û–ô–ö–ê –õ–û–ì–ì–ï–†–ê ====================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
    handlers=[
        logging.FileHandler('bot_errors.log', encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)

# ==================== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ====================
db_pool = None
settings_cache = {}
settings_cache_lock = asyncio.Lock()  # –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫—ç—à–∞
last_settings_update = 0
channels_cache = []
last_channels_update = 0
confirmed_chats_cache = {}
last_confirmed_chats_update = 0

# ==================== –î–ï–ö–û–†–ê–¢–û–† –î–õ–Ø –ü–û–í–¢–û–†–ù–´–• –ü–û–ü–´–¢–û–ö –ü–†–ò –û–®–ò–ë–ö–ê–• –ë–î ====================
def db_retry(max_retries=3, delay=1):
    """–î–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–∞ –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å –ë–î."""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            for attempt in range(max_retries):
                try:
                    return await func(*args, **kwargs)
                except (asyncpg.exceptions.ConnectionDoesNotExistError,
                        asyncpg.exceptions.InterfaceError,
                        asyncpg.exceptions.ConnectionFailureError) as e:
                    logging.warning(f"–û—à–∏–±–∫–∞ –ë–î –≤ {func.__name__} (–ø–æ–ø—ã—Ç–∫–∞ {attempt+1}/{max_retries}): {e}")
                    if attempt == max_retries - 1:
                        raise
                    await asyncio.sleep(delay * (2 ** attempt))  # —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
                    await ensure_db_connection()
                except Exception as e:
                    # –î—Ä—É–≥–∏–µ –æ—à–∏–±–∫–∏ –Ω–µ –ø–æ–≤—Ç–æ—Ä—è–µ–º
                    raise
            return None  # –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –¥–æ—Å—Ç–∏–≥–∞–µ—Ç—Å—è
        return wrapper
    return decorator

# ==================== –ú–ò–î–õ–í–ê–†–¨ –î–õ–Ø –õ–ò–ß–ù–´–• –°–û–û–ë–©–ï–ù–ò–ô (–∞–Ω—Ç–∏-—Ñ–ª—É–¥) ====================
class ThrottlingMiddleware(BaseMiddleware):
    def __init__(self, rate_limit=1.0):
        self.rate_limit = rate_limit
        self.user_last_time = defaultdict(float)

    async def __call__(self, handler, event: Message, data: dict):
        if event.chat.type != 'private':
            return await handler(event, data)
        user_id = event.from_user.id
        if await is_super_admin(user_id):
            return await handler(event, data)
        now = time.time()
        if now - self.user_last_time[user_id] < self.rate_limit:
            try:
                await event.reply("‚è≥ –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤. –ü–æ–¥–æ–∂–¥–∏ —Å–µ–∫—É–Ω–¥—É.")
            except Exception:
                pass
            return
        self.user_last_time[user_id] = now
        if len(self.user_last_time) > 1000:
            cutoff = now - 3600
            self.user_last_time = defaultdict(float, {k:v for k,v in self.user_last_time.items() if v > cutoff})
        return await handler(event, data)

# ==================== –ú–ò–î–õ–í–ê–†–¨ –î–õ–Ø –ì–õ–û–ë–ê–õ–¨–ù–û–ì–û –ö–£–õ–î–ê–£–ù–ê –í –ß–ê–¢–ê–• ====================
class GlobalCooldownMiddleware(BaseMiddleware):
    async def __call__(self, handler, event: Message, data: dict):
        if event.chat.type == 'private':
            return await handler(event, data)
        user_id = event.from_user.id
        try:
            cooldown_hours = await get_setting_int("global_chat_cooldown_hours")
            ok, remaining = await check_global_cooldown(user_id, "chat_activity", cooldown_hours * 3600)
            if not ok:
                await auto_delete_command(event, f"‚è≥ –ì–ª–æ–±–∞–ª—å–Ω—ã–π –∫—É–ª–¥–∞—É–Ω! –¢—ã —Å–º–æ–∂–µ—à—å —Å–Ω–æ–≤–∞ —É—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å —á–µ—Ä–µ–∑ {format_time_remaining(remaining)}")
                return
        except Exception as e:
            logging.error(f"GlobalCooldownMiddleware error: {e}")
            # –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–ø—Ä–æ—Å, —á—Ç–æ–±—ã –Ω–µ –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å —Ä–∞–±–æ—Ç—É
            pass
        return await handler(event, data)

# –ú–∏–¥–ª–≤–∞—Ä–∏ –±—É–¥—É—Ç –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –≤ –∫–æ–Ω—Ü–µ —Ñ–∞–π–ª–∞ –ø–æ—Å–ª–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –≤—Å–µ—Ö —Ñ—É–Ω–∫—Ü–∏–π

# ==================== –§–£–ù–ö–¶–ò–ò –ü–†–û–í–ï–†–ö–ò –ü–†–ê–í ====================
async def is_admin(user_id: int) -> bool:
    return await is_super_admin(user_id) or await is_junior_admin(user_id)

@db_retry()
async def is_junior_admin(user_id: int) -> bool:
    async with db_pool.acquire() as conn:
        row = await conn.fetchval("SELECT user_id FROM admins WHERE user_id=$1", user_id)
    return row is not None

async def is_admin(user_id: int) -> bool:
    return await is_super_admin(user_id) or await is_junior_admin(user_id)

@db_retry()
async def has_permission(user_id: int, permission: str) -> bool:
    if await is_super_admin(user_id):
        return True
    async with db_pool.acquire() as conn:
        perms_json = await conn.fetchval("SELECT permissions FROM admins WHERE user_id=$1", user_id)
    if not perms_json:
        return False
    try:
        perms = json.loads(perms_json)
        return permission in perms
    except:
        return False

@db_retry()
async def get_admin_permissions(user_id: int) -> List[str]:
    if await is_super_admin(user_id):
        return PERMISSIONS_LIST.copy()
    async with db_pool.acquire() as conn:
        perms_json = await conn.fetchval("SELECT permissions FROM admins WHERE user_id=$1", user_id)
    if not perms_json:
        return []
    try:
        return json.loads(perms_json)
    except:
        return []

@db_retry()
async def update_admin_permissions(user_id: int, permissions: List[str]):
    async with db_pool.acquire() as conn:
        await conn.execute(
            "UPDATE admins SET permissions=$1 WHERE user_id=$2",
            json.dumps(permissions), user_id
        )

# ==================== –ë–ï–ó–û–ü–ê–°–ù–ê–Ø –û–¢–ü–†–ê–í–ö–ê ====================
async def safe_send_message(user_id: int, text: str, **kwargs):
    try:
        await bot.send_message(user_id, text, **kwargs)
    except TelegramBadRequest as e:
        logging.warning(f"Bad request for user {user_id}: {e}")
    except TelegramForbiddenError:
        logging.warning(f"Bot blocked by user {user_id}")
    except TelegramRetryAfter as e:
        logging.warning(f"Flood limit exceeded. Retry after {e.retry_after} seconds")
        await asyncio.sleep(e.retry_after)
        try:
            await bot.send_message(user_id, text, **kwargs)
        except Exception as ex:
            logging.warning(f"Still failed after retry: {ex}")
    except TelegramAPIError as e:
        logging.warning(f"Telegram API error for user {user_id}: {e}")
    except Exception as e:
        logging.warning(f"Failed to send message to {user_id}: {e}")

def safe_send_message_task(user_id: int, text: str, **kwargs):
    asyncio.create_task(safe_send_message(user_id, text, **kwargs))

async def safe_send_chat(chat_id: int, text: str, **kwargs):
    try:
        await bot.send_message(chat_id, text, **kwargs)
    except Exception as e:
        logging.error(f"Failed to send to chat {chat_id}: {e}")

# ==================== –ê–í–¢–û–£–î–ê–õ–ï–ù–ò–ï ====================
async def can_delete_message(chat_id: int, message: Message) -> bool:
    try:
        if chat_id > 0:
            return message.from_user.id == bot.id
        else:
            member = await bot.get_chat_member(chat_id, bot.id)
            return member.status in ['administrator', 'creator']
    except:
        return False

async def delete_after(message: Message, seconds: int):
    await asyncio.sleep(seconds)
    if await can_delete_message(message.chat.id, message):
        try:
            await message.delete()
        except (TelegramBadRequest, TelegramForbiddenError):
            pass
        except Exception:
            pass

async def auto_delete_reply(message: Message, text: str, delete_seconds: int = None, **kwargs):
    if delete_seconds is None:
        delete_seconds = int(await get_setting("auto_delete_commands_seconds"))
    sent = await message.reply(text, **kwargs)
    if message.chat.type != 'private':
        confirmed = await get_confirmed_chats()
        chat_data = confirmed.get(message.chat.id)
        if chat_data and not chat_data.get('auto_delete_enabled', True):
            return
    asyncio.create_task(delete_after(sent, delete_seconds))

async def auto_delete_message(message: Message, delete_seconds: int = None):
    if message.chat.type == 'private':
        return
    if delete_seconds is None:
        delete_seconds = int(await get_setting("auto_delete_commands_seconds"))
    confirmed = await get_confirmed_chats()
    chat_data = confirmed.get(message.chat.id)
    if chat_data and not chat_data.get('auto_delete_enabled', True):
        return
    asyncio.create_task(delete_after(message, delete_seconds))

async def auto_delete_command(message: Message, text: str = None, **kwargs):
    """–£–¥–∞–ª—è–µ—Ç –∫–æ–º–∞–Ω–¥—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –æ—Ç–≤–µ—Ç —Å –∞–≤—Ç–æ—É–¥–∞–ª–µ–Ω–∏–µ–º"""
    try:
        await message.delete()
    except:
        pass
    if text:
        delete_seconds = int(await get_setting("auto_delete_commands_seconds"))
        sent = await message.answer(text, **kwargs)
        asyncio.create_task(delete_after(sent, delete_seconds))

# ==================== –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï –ö –ë–î (–ò–°–ü–†–ê–í–õ–ï–ù–ù–û–ï) ====================
async def create_db_pool(retries: int = 10, delay: int = 5) -> bool:
    """–°–æ–∑–¥–∞–µ—Ç –ø—É–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π —Å –ë–î —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π URL –∏ —Ç–∞–π–º–∞—É—Ç–∞–º–∏."""
    global db_pool
    
    # –ö–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ URL —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
    database_url = DATABASE_URL
    if "?" in database_url:
        if "sslmode" not in database_url:
            database_url += "&sslmode=require"
    else:
        database_url += "?sslmode=require"
    
    for attempt in range(1, retries + 1):
        try:
            logging.info(f"–ü–æ–ø—ã—Ç–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î {attempt}/{retries}...")
            
            db_pool = await asyncpg.create_pool(
                database_url,
                min_size=2,
                max_size=10,
                command_timeout=60,
                max_queries=50000,
                max_inactive_connection_lifetime=300,
                timeout=30,
                statement_cache_size=0,
                max_cached_statement_lifetime=0,
                server_settings={
                    'application_name': 'malboro_bot',
                    'timezone': 'UTC'
                }
            )
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
            async with db_pool.acquire() as conn:
                await conn.execute("SELECT 1")
                version = await conn.fetchval("SELECT version()")
                logging.info(f"‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ PostgreSQL —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ. {version}")
            
            return True
            
        except asyncpg.exceptions.InvalidAuthorizationSpecificationError as e:
            logging.error(f"‚ùå –û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏: {e}. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏–Ω/–ø–∞—Ä–æ–ª—å –≤ DATABASE_URL")
            if attempt == retries:
                raise
            await asyncio.sleep(delay)
            
        except asyncpg.exceptions.CannotConnectNowError as e:
            logging.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ –ë–î: {e}. –í–æ–∑–º–æ–∂–Ω–æ, –ë–î –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞")
            if attempt == retries:
                raise
            await asyncio.sleep(delay)
            
        except (ConnectionRefusedError, OSError) as e:
            logging.error(f"‚ùå –°–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞: {e}. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Ö–æ—Å—Ç–∞ –ë–î")
            if attempt == retries:
                raise
            await asyncio.sleep(delay)
            
        except Exception as e:
            logging.error(f"‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î: {e}")
            if attempt == retries:
                raise
            await asyncio.sleep(delay)
    
    return False

async def ensure_db_connection():
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –ë–î –∏ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞–µ—Ç—Å—è –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏"""
    global db_pool
    
    if db_pool is None:
        logging.warning("db_pool is None, –ø—Ä–æ–±—É—é —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ")
        await create_db_pool()
        return
        
    try:
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º wait_for –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å Python <3.11
        async with db_pool.acquire() as conn:
            await asyncio.wait_for(conn.execute("SELECT 1"), timeout=5)
            logging.debug("–ü–∏–Ω–≥ –ë–î –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ")
    except asyncio.TimeoutError:
        logging.error("–¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å –ë–î")
        await recreate_db_pool()
    except Exception as e:
        logging.error(f"–ü–æ—Ç–µ—Ä—è–Ω–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –ë–î: {e}. –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞—é—Å—å...")
        await recreate_db_pool()

async def recreate_db_pool():
    """–ü–µ—Ä–µ—Å–æ–∑–¥–∞–µ—Ç –ø—É–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π —Å –ë–î"""
    global db_pool
    
    try:
        if db_pool:
            await db_pool.close()
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ —Å—Ç–∞—Ä–æ–≥–æ –ø—É–ª–∞: {e}")
    finally:
        db_pool = None
    
    await create_db_pool()

async def keep_db_alive():
    """–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ –ø–∏–Ω–≥—É–µ—Ç –ë–î —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫."""
    consecutive_failures = 0
    max_consecutive_failures = 5
    
    while True:
        try:
            await asyncio.sleep(30)
            
            if db_pool is None:
                logging.warning("db_pool is None –≤ keep_db_alive, –ø—Ä–æ–±—É—é –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å")
                await recreate_db_pool()
                consecutive_failures = 0
                continue
                
            await ensure_db_connection()
            consecutive_failures = 0
            
        except Exception as e:
            consecutive_failures += 1
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∏–Ω–≥–µ –ë–î (–ø–æ–ø—ã—Ç–∫–∞ {consecutive_failures}/{max_consecutive_failures}): {e}")
            
            if consecutive_failures >= max_consecutive_failures:
                logging.critical(f"–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –æ—à–∏–±–æ–∫ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î ({consecutive_failures}). –í–æ–∑–º–æ–∂–Ω–æ, –ë–î –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞.")
                consecutive_failures = max_consecutive_failures
            
            await asyncio.sleep(60)

# ==================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –¢–ê–ë–õ–ò–¶ –° –ü–û–õ–ù–û–ô –ú–ò–ì–†–ê–¶–ò–ï–ô –¢–ò–ü–û–í –î–ê–¢ ====================
async def migrate_date_columns(conn):
    """–ú–∏–≥—Ä–∏—Ä—É–µ—Ç –≤—Å–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –ø–æ–ª—è –¥–∞—Ç –Ω–∞ TIMESTAMP —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫."""
    migrations = [
        ("heists", "started_at"),
        ("heists", "join_until"),
        ("heists", "split_until"),
        ("users", "last_bonus"),
        ("users", "last_theft_time"),
        ("users", "last_gift_time"),
        ("smuggle_runs", "start_time"),
        ("smuggle_runs", "end_time"),
        ("jail_sentences", "start_time"),
        ("jail_sentences", "end_time"),
        ("giveaways", "end_date"),
        ("confirmed_chats", "last_heist_time"),
        ("smuggle_cooldowns", "cooldown_until"),
        ("user_tasks", "completed_at"),
        ("user_tasks", "expires_at"),
        ("purchases", "purchase_date"),
    ]

    for table, column in migrations:
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —Ç–∞–±–ª–∏—Ü–∞ –∏ –∫–æ–ª–æ–Ω–∫–∞
            col_type = await conn.fetchval("""
                SELECT data_type 
                FROM information_schema.columns 
                WHERE table_name=$1 AND column_name=$2
            """, table, column)
            if col_type == 'text':
                logging.info(f"–ú–∏–≥—Ä–∞—Ü–∏—è {table}.{column} –∏–∑ TEXT –≤ TIMESTAMP")
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º NULLIF –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø—É—Å—Ç—ã—Ö —Å—Ç—Ä–æ–∫ –∏ –Ω–µ–≤–∞–ª–∏–¥–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
                await conn.execute(f"""
                    ALTER TABLE {table} 
                    ALTER COLUMN {column} TYPE TIMESTAMP 
                    USING CASE 
                        WHEN {column} IS NULL OR {column} = '' THEN NULL
                        ELSE {column}::timestamp 
                    END
                """)
        except Exception as e:
            logging.warning(f"–ú–∏–≥—Ä–∞—Ü–∏—è {table}.{column} –Ω–µ —É–¥–∞–ª–∞—Å—å (–≤–æ–∑–º–æ–∂–Ω–æ, —Ç–∞–±–ª–∏—Ü–∞/–∫–æ–ª–æ–Ω–∫–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç): {e}")

    # –ò–Ω–¥–µ–∫—Å—ã –Ω–∞ TIMESTAMP –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤
    await conn.execute("CREATE INDEX IF NOT EXISTS idx_heists_join_until ON heists(join_until)")
    await conn.execute("CREATE INDEX IF NOT EXISTS idx_heists_split_until ON heists(split_until)")
    await conn.execute("CREATE INDEX IF NOT EXISTS idx_smuggle_runs_end ON smuggle_runs(end_time)")
    await conn.execute("CREATE INDEX IF NOT EXISTS idx_jail_sentences_end ON jail_sentences(end_time)")
    await conn.execute("CREATE INDEX IF NOT EXISTS idx_giveaways_end_date ON giveaways(end_date)")
    await conn.execute("CREATE INDEX IF NOT EXISTS idx_purchases_date ON purchases(purchase_date)")
    await conn.execute("CREATE INDEX IF NOT EXISTS idx_user_tasks_expires ON user_tasks(expires_at)")

@db_retry()
async def init_db():
    async with db_pool.acquire() as conn:
        # –¢–∞–±–ª–∏—Ü–∞ users —Å TIMESTAMP –ø–æ–ª—è–º–∏
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS users (
                user_id BIGINT PRIMARY KEY,
                username TEXT,
                first_name TEXT,
                joined_date TEXT,
                balance NUMERIC(12,2) DEFAULT 0,
                reputation INTEGER DEFAULT 0,
                total_spent NUMERIC(12,2) DEFAULT 0,
                negative_balance NUMERIC(12,2) DEFAULT 0,
                last_bonus TIMESTAMP,
                last_theft_time TIMESTAMP,
                theft_attempts INTEGER DEFAULT 0,
                theft_success INTEGER DEFAULT 0,
                theft_failed INTEGER DEFAULT 0,
                theft_protected INTEGER DEFAULT 0,
                casino_wins INTEGER DEFAULT 0,
                casino_losses INTEGER DEFAULT 0,
                dice_wins INTEGER DEFAULT 0,
                dice_losses INTEGER DEFAULT 0,
                guess_wins INTEGER DEFAULT 0,
                guess_losses INTEGER DEFAULT 0,
                slots_wins INTEGER DEFAULT 0,
                slots_losses INTEGER DEFAULT 0,
                roulette_wins INTEGER DEFAULT 0,
                roulette_losses INTEGER DEFAULT 0,
                exp INTEGER DEFAULT 0,
                level INTEGER DEFAULT 1,
                last_gift_time TIMESTAMP,
                gift_count_today INTEGER DEFAULT 0,
                global_authority INTEGER DEFAULT 0,
                smuggle_success INTEGER DEFAULT 0,
                smuggle_fail INTEGER DEFAULT 0,
                bitcoin_balance NUMERIC(12,4) DEFAULT 0,
                authority_balance INTEGER DEFAULT 0,
                skill_share INTEGER DEFAULT 0,
                skill_luck INTEGER DEFAULT 0,
                skill_betray INTEGER DEFAULT 0,
                heists_joined INTEGER DEFAULT 0,
                heists_betray_attempts INTEGER DEFAULT 0,
                heists_betray_success INTEGER DEFAULT 0,
                heists_betrayed_count INTEGER DEFAULT 0,
                heists_earned NUMERIC(12,2) DEFAULT 0,
                strength INTEGER DEFAULT 1,
                agility INTEGER DEFAULT 1,
                defense INTEGER DEFAULT 1
            )
        ''')

        # –¢–∞–±–ª–∏—Ü–∞ –±–∏–∑–Ω–µ—Å–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS user_businesses (
                id SERIAL PRIMARY KEY,
                user_id BIGINT NOT NULL,
                business_type_id INTEGER NOT NULL,
                level INTEGER DEFAULT 1,
                last_collection TIMESTAMP,
                accumulated INTEGER DEFAULT 0,
                purchased_at TIMESTAMP DEFAULT NOW(),
                expires_at TIMESTAMP,
                UNIQUE(user_id, business_type_id)
            )
        ''')

        # –¢–∞–±–ª–∏—Ü–∞ —Ç–∏–ø–æ–≤ –±–∏–∑–Ω–µ—Å–æ–≤
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS business_types (
                id SERIAL PRIMARY KEY,
                name TEXT UNIQUE NOT NULL,
                emoji TEXT NOT NULL,
                base_price_btc NUMERIC(10,2) NOT NULL,
                base_income_per_hour NUMERIC(10,2) NOT NULL,
                description TEXT,
                max_level INTEGER DEFAULT 3,
                available BOOLEAN DEFAULT TRUE,
                image_key TEXT,
                lifetime_hours INTEGER DEFAULT 720
            )
        ''')

        # –¢–∞–±–ª–∏—Ü–∞ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Å—Ç–∞–≤–æ–∫
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS user_last_bets (
                user_id BIGINT,
                game TEXT,
                bet_amount NUMERIC(12,2),
                bet_data JSONB,
                updated_at TIMESTAMP DEFAULT NOW(),
                PRIMARY KEY (user_id, game)
            )
        ''')

        # –¢–∞–±–ª–∏—Ü–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã—Ö —á–∞—Ç–æ–≤
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS confirmed_chats (
                chat_id BIGINT PRIMARY KEY,
                title TEXT,
                type TEXT,
                joined_date TEXT,
                confirmed_by BIGINT,
                confirmed_date TEXT,
                notify_enabled BOOLEAN DEFAULT TRUE,
                last_gift_date DATE,
                gift_count_today INTEGER DEFAULT 0,
                auto_delete_enabled BOOLEAN DEFAULT TRUE,
                last_heist_time TIMESTAMP,
                heist_count_today INTEGER DEFAULT 0
            )
        ''')

        # –ó–∞–ø—Ä–æ—Å—ã –Ω–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —á–∞—Ç–æ–≤
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS chat_confirmation_requests (
                chat_id BIGINT PRIMARY KEY,
                title TEXT,
                type TEXT,
                requested_by BIGINT,
                request_date TEXT,
                status TEXT DEFAULT 'pending'
            )
        ''')

        # –ö–∞–Ω–∞–ª—ã –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS channels (
                id SERIAL PRIMARY KEY,
                chat_id TEXT UNIQUE,
                title TEXT,
                invite_link TEXT
            )
        ''')

        # –†–µ—Ñ–µ—Ä–∞–ª—ã
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS referrals (
                id SERIAL PRIMARY KEY,
                referrer_id BIGINT,
                referred_id BIGINT UNIQUE,
                referred_date TEXT,
                reward_given BOOLEAN DEFAULT FALSE,
                clicks INTEGER DEFAULT 0,
                active BOOLEAN DEFAULT FALSE
            )
        ''')

        # –¢–æ–≤–∞—Ä—ã –º–∞–≥–∞–∑–∏–Ω–∞
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS shop_items (
                id SERIAL PRIMARY KEY,
                name TEXT,
                description TEXT,
                price NUMERIC(12,2),
                stock INTEGER DEFAULT -1,
                photo_file_id TEXT
            )
        ''')

        # –ü–æ–∫—É–ø–∫–∏
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS purchases (
                id SERIAL PRIMARY KEY,
                user_id BIGINT,
                item_id INTEGER,
                purchase_date TIMESTAMP DEFAULT NOW(),
                status TEXT DEFAULT 'pending',
                admin_comment TEXT
            )
        ''')

        # –ü—Ä–æ–º–æ–∫–æ–¥—ã
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS promocodes (
                code TEXT PRIMARY KEY,
                reward NUMERIC(12,2) NOT NULL,
                reward_type TEXT NOT NULL DEFAULT 'coins' CHECK (reward_type IN ('coins', 'bitcoin')),
                max_uses INTEGER DEFAULT 1,
                used_count INTEGER DEFAULT 0,
                created_at TEXT,
                created_by BIGINT
            )
        ''')

        # –ê–∫—Ç–∏–≤–∞—Ü–∏–∏ –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS promo_activations (
                user_id BIGINT,
                promo_code TEXT,
                activated_at TEXT,
                PRIMARY KEY (user_id, promo_code)
            )
        ''')

        # –†–æ–∑—ã–≥—Ä—ã—à–∏
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS giveaways (
                id SERIAL PRIMARY KEY,
                prize TEXT,
                description TEXT,
                end_date TIMESTAMP,
                media_file_id TEXT,
                media_type TEXT,
                status TEXT DEFAULT 'active',
                winner_id BIGINT,
                winners_count INTEGER DEFAULT 1,
                winners_list TEXT,
                notified BOOLEAN DEFAULT FALSE,
                min_participants INTEGER DEFAULT 0,
                condition_type TEXT DEFAULT 'time'  -- 'time' or 'participants'
            )
        ''')

        # –£—á–∞—Å—Ç–Ω–∏–∫–∏ —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS participants (
                user_id BIGINT,
                giveaway_id INTEGER,
                PRIMARY KEY (user_id, giveaway_id)
            )
        ''')

        # –ê–¥–º–∏–Ω—ã
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS admins (
                user_id BIGINT PRIMARY KEY,
                added_by BIGINT,
                added_date TEXT,
                permissions TEXT DEFAULT '[]'
            )
        ''')

        # –ó–∞–±–∞–Ω–µ–Ω–Ω—ã–µ
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS banned_users (
                user_id BIGINT PRIMARY KEY,
                banned_by BIGINT,
                banned_date TEXT,
                reason TEXT
            )
        ''')

        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS settings (
                key TEXT PRIMARY KEY,
                value TEXT
            )
        ''')

        # –ó–∞–¥–∞–Ω–∏—è
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS tasks (
                id SERIAL PRIMARY KEY,
                name TEXT,
                description TEXT,
                task_type TEXT,
                target_id TEXT,
                reward_coins NUMERIC(12,2) DEFAULT 0,
                reward_reputation INTEGER DEFAULT 0,
                required_days INTEGER DEFAULT 0,
                penalty_days INTEGER DEFAULT 0,
                created_by BIGINT,
                created_at TEXT,
                active BOOLEAN DEFAULT TRUE,
                max_completions INTEGER DEFAULT 1,
                completed_count INTEGER DEFAULT 0,
                media_file_id TEXT,
                media_type TEXT,
                button_link TEXT
            )
        ''')

        await conn.execute('''
            CREATE TABLE IF NOT EXISTS user_tasks (
                user_id BIGINT,
                task_id INTEGER,
                completed_at TIMESTAMP,
                expires_at TIMESTAMP,
                status TEXT DEFAULT 'completed',
                PRIMARY KEY (user_id, task_id)
            )
        ''')

        # –£—Ä–æ–≤–Ω–µ–≤—ã–µ –Ω–∞–≥—Ä–∞–¥—ã
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS level_rewards (
                level INTEGER PRIMARY KEY,
                coins NUMERIC(12,2),
                reputation INTEGER
            )
        ''')

        # –ù–∞–ª—ë—Ç—ã
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS heists (
                id SERIAL PRIMARY KEY,
                chat_id BIGINT NOT NULL,
                event_type TEXT NOT NULL,
                keyword TEXT NOT NULL,
                total_pot NUMERIC(12,2) NOT NULL,
                remaining_pot NUMERIC(12,2) NOT NULL,
                btc_pot NUMERIC(12,4) DEFAULT 0,
                started_at TIMESTAMP NOT NULL,
                join_until TIMESTAMP NOT NULL,
                split_until TIMESTAMP NOT NULL,
                status TEXT DEFAULT 'joining'
            )
        ''')

        await conn.execute('''
            CREATE TABLE IF NOT EXISTS heist_participants (
                heist_id INTEGER REFERENCES heists(id) ON DELETE CASCADE,
                user_id BIGINT NOT NULL,
                base_share NUMERIC(12,2) NOT NULL,
                current_share NUMERIC(12,2) NOT NULL,
                defense_bonus INTEGER DEFAULT 0,
                joined_at TIMESTAMP NOT NULL,
                betray_choice TEXT DEFAULT NULL,
                betray_target_id BIGINT DEFAULT NULL,
                PRIMARY KEY (heist_id, user_id)
            )
        ''')

        await conn.execute('''
            CREATE TABLE IF NOT EXISTS heist_betrayals (
                id SERIAL PRIMARY KEY,
                heist_id INTEGER REFERENCES heists(id) ON DELETE CASCADE,
                attacker_id BIGINT NOT NULL,
                target_id BIGINT NOT NULL,
                success BOOLEAN NOT NULL,
                amount NUMERIC(12,2) NOT NULL,
                created_at TIMESTAMP NOT NULL
            )
        ''')

        # –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –∫—É–ª–¥–∞—É–Ω—ã
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS global_cooldowns (
                user_id BIGINT,
                command TEXT,
                last_used TIMESTAMP,
                PRIMARY KEY (user_id, command)
            )
        ''')

        # –ö–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥–Ω—ã–µ —Ä–µ–π—Å—ã
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS smuggle_runs (
                id SERIAL PRIMARY KEY,
                user_id BIGINT NOT NULL,
                chat_id BIGINT,
                start_time TIMESTAMP NOT NULL,
                end_time TIMESTAMP NOT NULL,
                status TEXT DEFAULT 'in_progress',
                result TEXT,
                smuggle_amount NUMERIC(12,4) DEFAULT 0,
                notified BOOLEAN DEFAULT FALSE
            )
        ''')

        await conn.execute('''
            CREATE TABLE IF NOT EXISTS smuggle_cooldowns (
                user_id BIGINT PRIMARY KEY,
                cooldown_until TIMESTAMP
            )
        ''')

        # –¢—é—Ä–µ–º–Ω—ã–µ —Å—Ä–æ–∫–∏
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS jail_sentences (
                id SERIAL PRIMARY KEY,
                user_id BIGINT NOT NULL,
                chat_id BIGINT,
                start_time TIMESTAMP NOT NULL,
                end_time TIMESTAMP NOT NULL,
                status TEXT DEFAULT 'serving',
                result TEXT,
                auth_gained INTEGER DEFAULT 0,
                notified BOOLEAN DEFAULT FALSE,
                cell_number INTEGER DEFAULT NULL,
                article_number INTEGER DEFAULT NULL
            )
        ''')

        # –ë–∏—Ç–∫–æ–∏–Ω-–±–∏—Ä–∂–∏
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS bitcoin_orders (
                id SERIAL PRIMARY KEY,
                user_id BIGINT NOT NULL,
                type TEXT NOT NULL CHECK (type IN ('buy', 'sell')),
                amount NUMERIC(12,4) NOT NULL CHECK (amount > 0),
                price INTEGER NOT NULL CHECK (price >= 1),
                total_locked NUMERIC(12,4) NOT NULL,
                created_at TIMESTAMP DEFAULT NOW(),
                status TEXT DEFAULT 'active' CHECK (status IN ('active', 'completed', 'cancelled'))
            )
        ''')

        await conn.execute('''
            CREATE TABLE IF NOT EXISTS bitcoin_trades (
                id SERIAL PRIMARY KEY,
                buy_order_id INTEGER REFERENCES bitcoin_orders(id),
                sell_order_id INTEGER REFERENCES bitcoin_orders(id),
                amount NUMERIC(12,4) NOT NULL,
                price INTEGER NOT NULL,
                buyer_id BIGINT NOT NULL,
                seller_id BIGINT NOT NULL,
                traded_at TIMESTAMP DEFAULT NOW()
            )
        ''')

        # –ú–µ–¥–∏–∞—Ñ–∞–π–ª—ã
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS media (
                key TEXT PRIMARY KEY,
                file_id TEXT NOT NULL,
                description TEXT,
                updated_at TIMESTAMP DEFAULT NOW()
            )
        ''')

        # –ö–ª—é—á–∏ –¥–ª—è —Å–±—Ä–æ—Å–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS reset_keys (
                key TEXT PRIMARY KEY,
                user_id BIGINT NOT NULL,
                created_at TIMESTAMP DEFAULT NOW(),
                expires_at TIMESTAMP,
                used BOOLEAN DEFAULT FALSE
            )
        ''')

        # –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_users_balance ON users(balance DESC)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_users_username_lower ON users(LOWER(username))")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_purchases_user_id ON purchases(user_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_purchases_status ON purchases(status)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_giveaways_status ON giveaways(status)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_giveaways_end_date ON giveaways(end_date)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_user_tasks_expires ON user_tasks(expires_at)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_tasks_active ON tasks(active)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_referrals_referrer ON referrals(referrer_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_users_level ON users(level)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_confirmed_chats_chat ON confirmed_chats(chat_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_chat_requests_status ON chat_confirmation_requests(status)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_global_cooldowns_user ON global_cooldowns(user_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_global_cooldowns_last_used ON global_cooldowns(last_used)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_bitcoin_orders_user ON bitcoin_orders(user_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_bitcoin_orders_status ON bitcoin_orders(status)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_bitcoin_orders_type ON bitcoin_orders(type)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_smuggle_runs_user ON smuggle_runs(user_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_smuggle_runs_end ON smuggle_runs(end_time)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_user_businesses_user ON user_businesses(user_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_user_businesses_expires ON user_businesses(expires_at)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_heists_chat_status ON heists(chat_id, status)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_heists_join_until ON heists(join_until)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_heists_split_until ON heists(split_until)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_heist_participants_heist ON heist_participants(heist_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_heist_betrayals_heist ON heist_betrayals(heist_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_heist_participants_user ON heist_participants(user_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_jail_sentences_user ON jail_sentences(user_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_jail_sentences_end ON jail_sentences(end_time)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_bitcoin_orders_price ON bitcoin_orders(price, status)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_bitcoin_orders_created ON bitcoin_orders(created_at)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_reset_keys_expires ON reset_keys(expires_at)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_reset_keys_user ON reset_keys(user_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_users_reputation ON users(reputation DESC)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_users_bitcoin_balance ON users(bitcoin_balance DESC)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_users_level_desc ON users(level DESC)")

        # –ú–∏–≥—Ä–∞—Ü–∏—è —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö
        await migrate_date_columns(conn)

    await init_settings()
    await init_level_rewards()
    await init_business_types()
    await init_media_keys()

    logging.info("‚úÖ –¢–∞–±–ª–∏—Ü—ã –≤ PostgreSQL –ø—Ä–æ–≤–µ—Ä–µ–Ω—ã/–æ–±–Ω–æ–≤–ª–µ–Ω—ã")

@db_retry()
async def init_settings():
    async with db_pool.acquire() as conn:
        for key, value in DEFAULT_SETTINGS.items():
            await conn.execute(
                "INSERT INTO settings (key, value) VALUES ($1, $2) ON CONFLICT (key) DO NOTHING",
                key, value
            )

@db_retry()
async def init_level_rewards():
    async with db_pool.acquire() as conn:
        for lvl in range(1, 101):
            exists = await conn.fetchval("SELECT level FROM level_rewards WHERE level=$1", lvl)
            if not exists:
                coins = int(DEFAULT_SETTINGS["level_reward_coins"]) + (lvl-1) * int(DEFAULT_SETTINGS["level_reward_coins_increment"])
                rep = int(DEFAULT_SETTINGS["level_reward_reputation"]) + (lvl-1) * int(DEFAULT_SETTINGS["level_reward_reputation_increment"])
                await conn.execute(
                    "INSERT INTO level_rewards (level, coins, reputation) VALUES ($1, $2, $3)",
                    lvl, float(coins), rep
                )

@db_retry()
async def init_business_types():
    async with db_pool.acquire() as conn:
        for biz in BUSINESS_TYPES:
            await conn.execute(
                """INSERT INTO business_types 
                   (id, name, emoji, base_price_btc, base_income_per_hour, description, max_level, available, image_key, lifetime_hours) 
                   VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                   ON CONFLICT (id) DO UPDATE SET
                   name = EXCLUDED.name,
                   emoji = EXCLUDED.emoji,
                   base_price_btc = EXCLUDED.base_price_btc,
                   base_income_per_hour = EXCLUDED.base_income_per_hour,
                   description = EXCLUDED.description,
                   max_level = EXCLUDED.max_level,
                   available = EXCLUDED.available,
                   image_key = EXCLUDED.image_key,
                   lifetime_hours = EXCLUDED.lifetime_hours""",
                biz["id"], biz["name"], biz["emoji"], biz["base_price_btc"], 
                biz["base_income_per_hour"], biz["description"], biz["max_level"], 
                True, biz.get("image_key"), biz.get("lifetime_hours", 720)
            )

@db_retry()
async def init_media_keys():
    async with db_pool.acquire() as conn:
        for key in MEDIA_KEYS:
            await conn.execute(
                "INSERT INTO media (key, file_id, description) VALUES ($1, $2, $3) ON CONFLICT (key) DO NOTHING",
                key, "", f"–ú–µ–¥–∏–∞ –¥–ª—è {key}"
            )

# ==================== –†–ê–ë–û–¢–ê –° –ù–ê–°–¢–†–û–ô–ö–ê–ú–ò (—Å –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π) ====================
@db_retry()
async def get_setting(key: str) -> str:
    global settings_cache, last_settings_update
    now = time.time()
    async with settings_cache_lock:
        if now - last_settings_update > 60 or not settings_cache:
            async with db_pool.acquire() as conn:
                rows = await conn.fetch("SELECT key, value FROM settings")
                settings_cache = {row['key']: row['value'] for row in rows}
            last_settings_update = now
        value = settings_cache.get(key)
        if value is None:
            value = DEFAULT_SETTINGS.get(key, "")
            if value:
                async with db_pool.acquire() as conn:
                    await conn.execute(
                        "INSERT INTO settings (key, value) VALUES ($1, $2) ON CONFLICT (key) DO NOTHING",
                        key, value
                    )
                settings_cache[key] = value
    return value

async def get_setting_float(key: str) -> float:
    val = await get_setting(key)
    try:
        return float(val)
    except (ValueError, TypeError) as e:
        logging.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫—É {key}='{val}' –≤ float: {e}")
        return 0.0

async def get_setting_int(key: str) -> int:
    val = await get_setting(key)
    try:
        return int(val)
    except (ValueError, TypeError) as e:
        logging.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫—É {key}='{val}' –≤ int: {e}")
        return 0

@db_retry()
async def set_setting(key: str, value: str):
    async with db_pool.acquire() as conn:
        await conn.execute("UPDATE settings SET value=$1 WHERE key=$2", value, key)
    async with settings_cache_lock:
        settings_cache[key] = value
        global last_settings_update
        last_settings_update = 0

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ß–ê–¢–û–í –ò –ö–ê–ù–ê–õ–û–í ====================
@db_retry()
async def get_channels():
    global channels_cache, last_channels_update
    now = time.time()
    if now - last_channels_update > 300 or not channels_cache:
        async with db_pool.acquire() as conn:
            rows = await conn.fetch("SELECT chat_id, title, invite_link FROM channels")
            channels_cache = [(r['chat_id'], r['title'], r['invite_link']) for r in rows]
        last_channels_update = now
    return channels_cache

@db_retry()
async def get_confirmed_chats(force_update=False) -> Dict[int, dict]:
    global confirmed_chats_cache, last_confirmed_chats_update
    now = time.time()
    if force_update or now - last_confirmed_chats_update > 300 or not confirmed_chats_cache:
        async with db_pool.acquire() as conn:
            rows = await conn.fetch("SELECT * FROM confirmed_chats")
            confirmed_chats_cache = {row['chat_id']: dict(row) for row in rows}
        last_confirmed_chats_update = now
    return confirmed_chats_cache

async def is_chat_confirmed(chat_id: int) -> bool:
    confirmed = await get_confirmed_chats()
    return chat_id in confirmed

@db_retry()
async def add_confirmed_chat(chat_id: int, title: str, chat_type: str, confirmed_by: int):
    async with db_pool.acquire() as conn:
        await conn.execute(
            "INSERT INTO confirmed_chats (chat_id, title, type, joined_date, confirmed_by, confirmed_date) VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT (chat_id) DO UPDATE SET confirmed_by=$5, confirmed_date=$6",
            chat_id, title, chat_type, datetime.now().strftime("%Y-%m-%d %H:%M:%S"), confirmed_by, datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        )
    await get_confirmed_chats(force_update=True)

@db_retry()
async def remove_confirmed_chat(chat_id: int):
    async with db_pool.acquire() as conn:
        await conn.execute("DELETE FROM confirmed_chats WHERE chat_id=$1", chat_id)
    await get_confirmed_chats(force_update=True)

@db_retry()
async def create_chat_confirmation_request(chat_id: int, title: str, chat_type: str, requested_by: int):
    async with db_pool.acquire() as conn:
        await conn.execute(
            "INSERT INTO chat_confirmation_requests (chat_id, title, type, requested_by, request_date, status) VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT (chat_id) DO UPDATE SET status='pending', requested_by=$4, request_date=$5",
            chat_id, title, chat_type, requested_by, datetime.now().strftime("%Y-%m-%d %H:%M:%S"), 'pending'
        )

@db_retry()
async def get_pending_chat_requests() -> List[dict]:
    async with db_pool.acquire() as conn:
        rows = await conn.fetch("SELECT * FROM chat_confirmation_requests WHERE status='pending' ORDER BY request_date")
        return [dict(r) for r in rows]

@db_retry()
async def update_chat_request_status(chat_id: int, status: str):
    async with db_pool.acquire() as conn:
        await conn.execute("UPDATE chat_confirmation_requests SET status=$1 WHERE chat_id=$2", status, chat_id)

# ==================== –ü–†–û–í–ï–†–ö–ê –ü–û–î–ü–ò–°–ö–ò ====================
async def check_subscription(user_id: int):
    channels = await get_channels()
    if not channels:
        return True, []
    not_subscribed = []
    for chat_id, title, link in channels:
        try:
            member = await bot.get_chat_member(chat_id=chat_id, user_id=user_id)
            if member.status in ['left', 'kicked']:
                not_subscribed.append((title, link))
        except Exception:
            not_subscribed.append((title, link))
    return len(not_subscribed) == 0, not_subscribed

# ==================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ====================
def progress_bar(current, total, length=10):
    if total <= 0:
        return "‚¨ú" * length
    filled = int(current / total * length)
    return "üü©" * filled + "‚¨ú" * (length - filled)

def format_time_remaining(seconds: int) -> str:
    if seconds < 60:
        return f"{seconds} —Å–µ–∫"
    minutes = seconds // 60
    if minutes < 60:
        return f"{minutes} –º–∏–Ω"
    hours = minutes // 60
    minutes %= 60
    if minutes == 0:
        return f"{hours} —á"
    return f"{hours} —á {minutes} –º–∏–Ω"

def get_random_phrase(phrase_list: List[str], **kwargs) -> str:
    if not phrase_list:
        return ""
    phrase = random.choice(phrase_list)
    return phrase.format(**kwargs)

async def notify_chats(message_text: str):
    confirmed = await get_confirmed_chats()
    for chat_id, data in confirmed.items():
        if not data.get('notify_enabled', True):
            continue
        await safe_send_chat(chat_id, message_text)

@db_retry()
async def is_banned(user_id: int) -> bool:
    async with db_pool.acquire() as conn:
        row = await conn.fetchval("SELECT user_id FROM banned_users WHERE user_id=$1", user_id)
    return row is not None

@db_retry()
async def find_user_by_input(input_str: str) -> Optional[Dict]:
    input_str = input_str.strip()
    try:
        uid = int(input_str)
        async with db_pool.acquire() as conn:
            row = await conn.fetchrow("SELECT * FROM users WHERE user_id=$1", uid)
            return dict(row) if row else None
    except ValueError:
        username = input_str.lower()
        if username.startswith('@'):
            username = username[1:]
        async with db_pool.acquire() as conn:
            row = await conn.fetchrow("SELECT * FROM users WHERE LOWER(username)=$1", username)
            return dict(row) if row else None

async def get_media_file_id(key: str) -> Optional[str]:
    if redis_client:
        cached = await redis_get(f"media:{key}")
        if cached:
            return cached
    async with db_pool.acquire() as conn:
        file_id = await conn.fetchval("SELECT file_id FROM media WHERE key=$1", key)
        if file_id and redis_client:
            await redis_set(f"media:{key}", file_id, 3600)
        return file_id

@db_retry()
async def set_media_file_id(key: str, file_id: str, description: str = ""):
    async with db_pool.acquire() as conn:
        await conn.execute(
            "INSERT INTO media (key, file_id, description) VALUES ($1, $2, $3) ON CONFLICT (key) DO UPDATE SET file_id=$2, description=$3, updated_at=NOW()",
            key, file_id, description
        )
    if redis_client:
        await redis_set(f"media:{key}", file_id, 3600)

async def send_with_media(chat_id: int, text: str, media_key: str = None, **kwargs):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–∞—Ä—Ç–∏–Ω–∫–æ–π –∏–∑ –º–µ–¥–∏–∞-—Ç–∞–±–ª–∏—Ü—ã, –µ—Å–ª–∏ –∫–ª—é—á –Ω–∞–π–¥–µ–Ω."""
    if media_key:
        file_id = await get_media_file_id(media_key)
        if file_id:
            try:
                await bot.send_photo(chat_id, file_id, caption=text, **kwargs)
                return
            except Exception as e:
                logging.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–æ—Ç–æ —Å –∫–ª—é—á–æ–º {media_key}: {e}")
    await safe_send_message(chat_id, text, **kwargs)

@db_retry()
async def save_last_bet(user_id: int, game: str, amount: float, bet_data: dict = None):
    async with db_pool.acquire() as conn:
        await conn.execute("""
            INSERT INTO user_last_bets (user_id, game, bet_amount, bet_data, updated_at)
            VALUES ($1, $2, $3, $4, NOW())
            ON CONFLICT (user_id, game) DO UPDATE SET
                bet_amount = EXCLUDED.bet_amount,
                bet_data = EXCLUDED.bet_data,
                updated_at = NOW()
        """, user_id, game, amount, json.dumps(bet_data) if bet_data else None)

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ï–ô (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ, —Å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è–º–∏ –∏ RETURNING) ====================
@db_retry()
async def ensure_user_exists(user_id: int, username: str = None, first_name: str = None):
    async with db_pool.acquire() as conn:
        exists = await conn.fetchval("SELECT 1 FROM users WHERE user_id=$1", user_id)
        if not exists:
            bonus = await get_setting_float("new_user_bonus")
            await conn.execute(
                "INSERT INTO users (user_id, username, first_name, joined_date, balance, reputation, total_spent, negative_balance, exp, level, bitcoin_balance, authority_balance, skill_share, skill_luck, skill_betray) "
                "VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)",
                user_id, username, first_name, datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                bonus, 0, 0, 0, 0, 1, 0.0, 0, 0, 0, 0
            )
            return True, bonus
    return False, 0

@db_retry()
async def get_user_balance(user_id: int) -> float:
    async with db_pool.acquire() as conn:
        balance = await conn.fetchval("SELECT balance FROM users WHERE user_id=$1", user_id)
        return float(balance) if balance is not None else 0.0

@db_retry()
async def update_user_balance(user_id: int, delta: float, conn=None, allow_negative: bool = False) -> Tuple[bool, float, float]:
    """
    –û–±–Ω–æ–≤–ª—è–µ—Ç –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
    –ï—Å–ª–∏ allow_negative=False –∏ –±–∞–ª–∞–Ω—Å —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º, –æ–ø–µ—Ä–∞—Ü–∏—è –Ω–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è (–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç False).
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (—É—Å–ø–µ—Ö, –Ω–æ–≤—ã–π_–±–∞–ª–∞–Ω—Å, –Ω–æ–≤—ã–π_–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π_–±–∞–ª–∞–Ω—Å).
    """
    delta = round(float(delta), 2)
    async def _update(conn):
        # –ë–ª–æ–∫–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫—É
        row = await conn.fetchrow("SELECT balance, negative_balance FROM users WHERE user_id=$1 FOR UPDATE", user_id)
        if not row:
            # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ—Ç ‚Äì —Å–æ–∑–¥–∞—ë–º (–Ω–æ —ç—Ç–æ–≥–æ –Ω–µ –¥–æ–ª–∂–Ω–æ —Å–ª—É—á–∞—Ç—å—Å—è)
            await ensure_user_exists(user_id)
            row = await conn.fetchrow("SELECT balance, negative_balance FROM users WHERE user_id=$1 FOR UPDATE", user_id)
        current_balance = float(row['balance'])
        current_negative = float(row['negative_balance'])

        new_balance = current_balance + delta
        if not allow_negative and new_balance < 0:
            return False, current_balance, current_negative

        if new_balance < 0:
            # –£—Ö–æ–¥–∏–º –≤ –º–∏–Ω—É—Å ‚Äì —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º negative_balance
            additional_negative = -new_balance
            new_balance = 0.0
            new_negative = current_negative + additional_negative
        else:
            new_negative = current_negative

        new_balance = round(new_balance, 2)
        new_negative = round(new_negative, 2)

        await conn.execute(
            "UPDATE users SET balance=$1, negative_balance=$2 WHERE user_id=$3",
            new_balance, new_negative, user_id
        )
        return True, new_balance, new_negative

    if conn:
        return await _update(conn)
    else:
        async with db_pool.acquire() as new_conn:
            async with new_conn.transaction():
                return await _update(new_conn)

@db_retry()
async def get_user_bitcoin(user_id: int) -> float:
    async with db_pool.acquire() as conn:
        btc = await conn.fetchval("SELECT bitcoin_balance FROM users WHERE user_id=$1", user_id)
        return float(btc) if btc is not None else 0.0

@db_retry()
async def update_user_bitcoin(user_id: int, delta: float, conn=None) -> Tuple[bool, float]:
    """–û–±–Ω–æ–≤–ª—è–µ—Ç –±–∞–ª–∞–Ω—Å –±–∏—Ç–∫–æ–∏–Ω–æ–≤. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (—É—Å–ø–µ—Ö, –Ω–æ–≤—ã–π_–±–∞–ª–∞–Ω—Å)."""
    delta = round(float(delta), 4)
    async def _update(conn):
        row = await conn.fetchrow("""
            UPDATE users SET bitcoin_balance = bitcoin_balance + $1
            WHERE user_id = $2 AND bitcoin_balance + $1 >= 0
            RETURNING bitcoin_balance
        """, delta, user_id)
        if not row:
            return False, None
        return True, float(row['bitcoin_balance'])

    if conn:
        return await _update(conn)
    else:
        async with db_pool.acquire() as new_conn:
            async with new_conn.transaction():
                return await _update(new_conn)

@db_retry()
async def get_user_authority(user_id: int) -> int:
    async with db_pool.acquire() as conn:
        auth = await conn.fetchval("SELECT authority_balance FROM users WHERE user_id=$1", user_id)
        return auth if auth is not None else 0

@db_retry()
async def update_user_authority(user_id: int, delta: int, conn=None) -> int:
    async def _update(conn):
        row = await conn.fetchrow("""
            UPDATE users SET authority_balance = authority_balance + $1
            WHERE user_id = $2
            RETURNING authority_balance
        """, delta, user_id)
        return row['authority_balance'] if row else 0
    if conn:
        return await _update(conn)
    else:
        async with db_pool.acquire() as new_conn:
            async with new_conn.transaction():
                return await _update(new_conn)

@db_retry()
async def get_user_reputation(user_id: int) -> int:
    async with db_pool.acquire() as conn:
        rep = await conn.fetchval("SELECT reputation FROM users WHERE user_id=$1", user_id)
        return rep if rep is not None else 0

@db_retry()
async def update_user_reputation(user_id: int, delta: int):
    async with db_pool.acquire() as conn:
        await conn.execute("UPDATE users SET reputation = reputation + $1 WHERE user_id=$2", delta, user_id)

@db_retry()
async def get_user_skills(user_id: int) -> dict:
    async with db_pool.acquire() as conn:
        row = await conn.fetchrow(
            "SELECT skill_share, skill_luck, skill_betray FROM users WHERE user_id=$1",
            user_id
        )
        if row:
            return dict(row)
        return {'skill_share': 0, 'skill_luck': 0, 'skill_betray': 0}

@db_retry()
async def update_user_skill(user_id: int, skill: str, delta: int = 1, conn=None):
    allowed = ['skill_share', 'skill_luck', 'skill_betray']
    if skill not in allowed:
        raise ValueError("Invalid skill")
    async def _update(conn):
        await conn.execute(f"UPDATE users SET {skill} = {skill} + $1 WHERE user_id=$2", delta, user_id)
    if conn:
        await _update(conn)
    else:
        async with db_pool.acquire() as conn2:
            await _update(conn2)

@db_retry()
async def get_user_stats(user_id: int) -> dict:
    async with db_pool.acquire() as conn:
        row = await conn.fetchrow("SELECT level, exp, strength, agility, defense FROM users WHERE user_id=$1", user_id)
        if row:
            return dict(row)
        return {'level': 1, 'exp': 0, 'strength': 1, 'agility': 1, 'defense': 1}

@db_retry()
async def update_user_game_stats(user_id: int, game: str, win: bool, conn=None):
    async def _update(conn):
        if win:
            if game == 'dice':
                await conn.execute("UPDATE users SET dice_wins = dice_wins + 1 WHERE user_id=$1", user_id)
            elif game == 'guess':
                await conn.execute("UPDATE users SET guess_wins = guess_wins + 1 WHERE user_id=$1", user_id)
            elif game == 'slots':
                await conn.execute("UPDATE users SET slots_wins = slots_wins + 1 WHERE user_id=$1", user_id)
            elif game == 'roulette':
                await conn.execute("UPDATE users SET roulette_wins = roulette_wins + 1 WHERE user_id=$1", user_id)
        else:
            if game == 'dice':
                await conn.execute("UPDATE users SET dice_losses = dice_losses + 1 WHERE user_id=$1", user_id)
            elif game == 'guess':
                await conn.execute("UPDATE users SET guess_losses = guess_losses + 1 WHERE user_id=$1", user_id)
            elif game == 'slots':
                await conn.execute("UPDATE users SET slots_losses = slots_losses + 1 WHERE user_id=$1", user_id)
            elif game == 'roulette':
                await conn.execute("UPDATE users SET roulette_losses = roulette_losses + 1 WHERE user_id=$1", user_id)
    if conn:
        await _update(conn)
    else:
        async with db_pool.acquire() as new_conn:
            await _update(new_conn)

@db_retry()
async def add_exp(user_id: int, exp: int, conn=None) -> Optional[str]:
    """
    –î–æ–±–∞–≤–ª—è–µ—Ç –æ–ø—ã—Ç, –ø–æ–≤—ã—à–∞–µ—Ç —É—Ä–æ–≤–µ–Ω—å –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –æ –ø–æ–≤—ã—à–µ–Ω–∏–∏ —É—Ä–æ–≤–Ω—è, –µ—Å–ª–∏ conn –ø–µ—Ä–µ–¥–∞–Ω (—Ç.–µ. –≤–Ω—É—Ç—Ä–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏),
    –∏–Ω–∞—á–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å—Ä–∞–∑—É.
    –í—ã–∑—ã–≤–∞—é—â–∏–π –∫–æ–¥ –¥–æ–ª–∂–µ–Ω –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤–æ–∑–≤—Ä–∞—â—ë–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –ø–æ—Å–ª–µ –∫–æ–º–º–∏—Ç–∞.
    """
    async def _add(conn):
        await conn.execute("SET LOCAL statement_timeout = '5s'")
        user = await conn.fetchrow("SELECT exp, level FROM users WHERE user_id=$1 FOR UPDATE", user_id)
        if not user:
            return None
        new_exp = user['exp'] + exp
        level = user['level']
        level_mult = await get_setting_int("level_multiplier")
        levels_gained = 0
        rewards = []
        while new_exp >= level * level_mult and level < 100:
            new_exp -= level * level_mult
            level += 1
            levels_gained += 1
            rewards.append(level)
        await conn.execute(
            "UPDATE users SET exp=$1, level=$2 WHERE user_id=$3",
            new_exp, level, user_id
        )
        if levels_gained > 0:
            str_inc = await get_setting_int("stat_strength_per_level") * levels_gained
            agi_inc = await get_setting_int("stat_agility_per_level") * levels_gained
            def_inc = await get_setting_int("stat_defense_per_level") * levels_gained
            await conn.execute(
                "UPDATE users SET strength = strength + $1, agility = agility + $2, defense = defense + $3 WHERE user_id=$4",
                str_inc, agi_inc, def_inc, user_id
            )
            reward_summary = []
            for lvl in rewards:
                reward = await conn.fetchrow(
                    "SELECT coins, reputation FROM level_rewards WHERE level=$1",
                    lvl
                )
                if reward:
                    reward_summary.append(f"–£—Ä–æ–≤–µ–Ω—å {lvl}: +{float(reward['coins']):.2f} –±–∞–∫—Å–æ–≤, +{reward['reputation']} —Ä–µ–ø—É—Ç–∞—Ü–∏–∏")
            if reward_summary:
                text = "üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –¢—ã –¥–æ—Å—Ç–∏–≥ –Ω–æ–≤—ã—Ö —É—Ä–æ–≤–Ω–µ–π!\n" + "\n".join(reward_summary) + \
                       f"\n–¢–≤–æ–∏ —Å—Ç–∞—Ç—ã —É–≤–µ–ª–∏—á–µ–Ω—ã: —Å–∏–ª–∞ +{str_inc}, –ª–æ–≤–∫–æ—Å—Ç—å +{agi_inc}, –∑–∞—â–∏—Ç–∞ +{def_inc}."
                return text
        return None

    if conn:
        return await _add(conn)
    else:
        async with db_pool.acquire() as conn2:
            async with conn2.transaction():
                msg = await _add(conn2)
            if msg:
                await safe_send_message(user_id, msg)
        return None

async def get_user_level(user_id: int) -> int:
    return (await get_user_stats(user_id))['level']

async def get_user_exp(user_id: int) -> int:
    return (await get_user_stats(user_id))['exp']

@db_retry()
async def update_user_total_spent(user_id: int, amount: float):
    async with db_pool.acquire() as conn:
        await conn.execute("UPDATE users SET total_spent = total_spent + $1 WHERE user_id=$2", amount, user_id)

@db_retry()
async def get_random_user(exclude_id: int):
    async with db_pool.acquire() as conn:
        row = await conn.fetchrow("""
            SELECT user_id FROM users 
            WHERE user_id != $1 AND user_id NOT IN (SELECT user_id FROM banned_users)
            ORDER BY random() LIMIT 1
        """, exclude_id)
        return row['user_id'] if row else None

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ì–õ–û–ë–ê–õ–¨–ù–û–ì–û –ö–£–õ–î–ê–£–ù–ê ====================
@db_retry()
async def check_global_cooldown(user_id: int, command: str, cooldown_seconds: int = None) -> Tuple[bool, int]:
    if cooldown_seconds is None:
        cooldown_seconds = await get_setting_int("global_cooldown_seconds")
    async with db_pool.acquire() as conn:
        row = await conn.fetchrow("SELECT last_used FROM global_cooldowns WHERE user_id=$1 AND command=$2", user_id, command)
        if row and row['last_used']:
            diff = datetime.now() - row['last_used']
            remaining = cooldown_seconds - diff.total_seconds()
            if remaining > 0:
                return False, int(remaining)
    return True, 0

@db_retry()
async def set_global_cooldown(user_id: int, command: str, cooldown_seconds: int = None):
    if cooldown_seconds is None:
        cooldown_seconds = await get_setting_int("global_cooldown_seconds")
    async with db_pool.acquire() as conn:
        await conn.execute('''
            INSERT INTO global_cooldowns (user_id, command, last_used)
            VALUES ($1, $2, $3)
            ON CONFLICT (user_id, command) DO UPDATE SET last_used = $3
        ''', user_id, command, datetime.now())

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ë–ò–ó–ù–ï–°–û–í ====================
@db_retry()
async def get_business_type_list(only_available: bool = True) -> List[dict]:
    async with db_pool.acquire() as conn:
        if only_available:
            rows = await conn.fetch("SELECT * FROM business_types WHERE available = TRUE ORDER BY base_price_btc")
        else:
            rows = await conn.fetch("SELECT * FROM business_types ORDER BY base_price_btc")
        result = []
        for r in rows:
            d = dict(r)
            d['base_price_btc'] = float(d['base_price_btc'])
            d['base_income_per_hour'] = float(d['base_income_per_hour'])
            result.append(d)
        return result

@db_retry()
async def get_business_type(business_type_id: int) -> Optional[dict]:
    async with db_pool.acquire() as conn:
        row = await conn.fetchrow("SELECT * FROM business_types WHERE id=$1", business_type_id)
        if row:
            d = dict(row)
            d['base_price_btc'] = float(d['base_price_btc'])
            d['base_income_per_hour'] = float(d['base_income_per_hour'])
            return d
        return None

@db_retry()
async def get_user_businesses(user_id: int) -> List[dict]:
    async with db_pool.acquire() as conn:
        rows = await conn.fetch("""
            SELECT ub.*, bt.name, bt.emoji, bt.base_price_btc, bt.base_income_per_hour, bt.max_level, bt.image_key, bt.lifetime_hours
            FROM user_businesses ub
            JOIN business_types bt ON ub.business_type_id = bt.id
            WHERE ub.user_id = $1
            ORDER BY bt.base_price_btc
        """, user_id)
        result = []
        for r in rows:
            d = dict(r)
            d['base_price_btc'] = float(d['base_price_btc'])
            d['base_income_per_hour'] = float(d['base_income_per_hour'])
            result.append(d)
        return result

@db_retry()
async def get_user_business(user_id: int, business_type_id: int) -> Optional[dict]:
    async with db_pool.acquire() as conn:
        row = await conn.fetchrow("""
            SELECT ub.*, bt.name, bt.emoji, bt.base_price_btc, bt.base_income_per_hour, bt.max_level, bt.image_key
            FROM user_businesses ub
            JOIN business_types bt ON ub.business_type_id = bt.id
            WHERE ub.user_id = $1 AND ub.business_type_id = $2
        """, user_id, business_type_id)
        if row:
            d = dict(row)
            d['base_price_btc'] = float(d['base_price_btc'])
            d['base_income_per_hour'] = float(d['base_income_per_hour'])
            return d
        return None

async def get_business_price(business_type: dict, level: int) -> float:
    base_price = business_type['base_price_btc']
    if level == 1:
        return base_price
    else:
        upgrade_base = await get_setting_float("business_upgrade_cost_per_level")
        cost = base_price + upgrade_base * (level ** 1.5)
        return round(cost, 2)

async def get_business_income(business_type: dict, level: int) -> float:
    return business_type['base_income_per_hour'] * level

@db_retry()
async def create_user_business(user_id: int, business_type_id: int, lifetime_hours: int):
    async with db_pool.acquire() as conn:
        now = datetime.now()
        expires_at = now + timedelta(hours=lifetime_hours) if lifetime_hours > 0 else None
        await conn.execute(
            "INSERT INTO user_businesses (user_id, business_type_id, level, last_collection, purchased_at, expires_at) VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT (user_id, business_type_id) DO NOTHING",
            user_id, business_type_id, 1, now, now, expires_at
        )

@db_retry()
async def collect_business_income(user_id: int, business_id: int) -> Tuple[bool, str, float]:
    async with db_pool.acquire() as conn:
        async with conn.transaction():
            await conn.execute("SET LOCAL statement_timeout = '5s'")
            biz = await conn.fetchrow("SELECT * FROM user_businesses WHERE id=$1 AND user_id=$2 FOR UPDATE", business_id, user_id)
            if not biz:
                return False, "‚ùå –ë–∏–∑–Ω–µ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω.", 0
            last_col = biz['last_collection']
            if last_col:
                last_date = last_col
            else:
                last_date = datetime.now() - timedelta(days=365)
            now = datetime.now()
            minutes_passed = int((now - last_date).total_seconds() / 60)

            collect_interval = await get_setting_int("business_collect_interval_minutes")
            if minutes_passed < collect_interval:
                next_collect = last_date + timedelta(minutes=collect_interval)
                wait_minutes = int((next_collect - now).total_seconds() / 60)
                return False, f"‚è≥ –°–ª–µ–¥—É—é—â–∏–π —Å–±–æ—Ä —á–µ—Ä–µ–∑ {wait_minutes} –º–∏–Ω.", 0

            max_storage_hours = await get_setting_int("business_max_storage_hours")
            max_storage_minutes = max_storage_hours * 60
            collectable_minutes = min(minutes_passed, max_storage_minutes)

            biz_type = await conn.fetchrow("SELECT * FROM business_types WHERE id = (SELECT business_type_id FROM user_businesses WHERE id=$1)", business_id)
            if not biz_type:
                return False, "‚ùå –¢–∏–ø –±–∏–∑–Ω–µ—Å–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω.", 0
            income_per_hour = float(biz_type['base_income_per_hour']) * biz['level']
            income = income_per_hour * (collectable_minutes / 60)
            income = round(income, 2)

            if income <= 0:
                return False, "‚ùå –î–æ—Ö–æ–¥ –µ—â—ë –Ω–µ –Ω–∞–∫–æ–ø–∏–ª—Å—è.", 0

            await update_user_balance(user_id, income, conn=conn, allow_negative=False)  # –¥–æ—Ö–æ–¥ –Ω–µ –º–æ–∂–µ—Ç —É–π—Ç–∏ –≤ –º–∏–Ω—É—Å
            await conn.execute(
                "UPDATE user_businesses SET last_collection=$1 WHERE id=$2",
                now, business_id
            )
            return True, f"üí∞ –°–æ–±—Ä–∞–Ω–æ {income} –±–∞–∫—Å–æ–≤ —Å –±–∏–∑–Ω–µ—Å–∞ {biz_type['emoji']} {biz_type['name']}!", income

@db_retry()
async def upgrade_business(user_id: int, business_id: int) -> Tuple[bool, str]:
    async with db_pool.acquire() as conn:
        async with conn.transaction():
            await conn.execute("SET LOCAL statement_timeout = '5s'")
            biz = await conn.fetchrow("""
                SELECT ub.*, bt.base_price_btc, bt.base_income_per_hour, bt.max_level, bt.emoji, bt.name
                FROM user_businesses ub 
                JOIN business_types bt ON ub.business_type_id = bt.id 
                WHERE ub.id=$1 AND ub.user_id=$2
            """, business_id, user_id)
            if not biz:
                return False, "‚ùå –ë–∏–∑–Ω–µ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω."
            if biz['level'] >= biz['max_level']:
                return False, f"‚ùå –ë–∏–∑–Ω–µ—Å —É–∂–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è ({biz['max_level']})."
            
            await collect_business_income(user_id, business_id)

            base_price = float(biz['base_price_btc'])
            cost = await get_business_price({'base_price_btc': base_price}, biz['level'] + 1)
            btc_balance = await get_user_bitcoin(user_id)
            if btc_balance < cost - 0.0001:
                return False, f"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∏—Ç–∫–æ–∏–Ω–æ–≤. –ù—É–∂–Ω–æ {cost:.2f} BTC, —É –≤–∞—Å {btc_balance:.4f}."
            await update_user_bitcoin(user_id, -cost, conn=conn)
            await conn.execute(
                "UPDATE user_businesses SET level = level + 1 WHERE id=$1",
                business_id
            )
            return True, f"‚úÖ –ë–∏–∑–Ω–µ—Å {biz['emoji']} {biz['name']} —É–ª—É—á—à–µ–Ω –¥–æ —É—Ä–æ–≤–Ω—è {biz['level'] + 1}! –ü–æ—Ç—Ä–∞—á–µ–Ω–æ {cost:.2f} BTC."

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ù–ê–õ–Å–¢–û–í (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ, —Å TIMESTAMP –∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è–º–∏) ====================
@db_retry()
async def spawn_heist(chat_id: int):
    """–°–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—ã–π –Ω–∞–ª—ë—Ç –≤ —á–∞—Ç–µ."""
    heist_type = random.choice(list(HEIST_TYPES.keys()))
    config = HEIST_TYPES[heist_type]
    keyword = config['keyword']
    join_minutes = await get_setting_int("heist_join_minutes")
    split_minutes = await get_setting_int("heist_split_minutes")
    now = datetime.now()
    join_until = now + timedelta(minutes=join_minutes)
    split_until = join_until + timedelta(minutes=split_minutes)

    total_pot = 0
    btc_pot = 0

    async with db_pool.acquire() as conn:
        heist_id = await conn.fetchval(
            "INSERT INTO heists (chat_id, event_type, keyword, total_pot, remaining_pot, btc_pot, started_at, join_until, split_until, status) "
            "VALUES ($1, $2, $3, $4, $4, $5, $6, $7, $8, $9) RETURNING id",
            chat_id, heist_type, keyword, total_pot, btc_pot,
            now, join_until, split_until, 'joining'
        )
    text = get_random_phrase(config['phrases_start'], minutes=join_minutes)
    text += f"\n\nüìù –ß—Ç–æ–±—ã —É—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å, –Ω–∞–ø–∏—à–∏ **{keyword}** –≤ —Ç–µ—á–µ–Ω–∏–µ {join_minutes} –º–∏–Ω—É—Ç!"
    
    media_key = f"heist_{heist_type}"
    file_id = await get_media_file_id(media_key)
    if file_id:
        await bot.send_photo(chat_id, file_id, caption=text)
    else:
        await safe_send_chat(chat_id, text)
    asyncio.create_task(finish_heist_joining(heist_id, join_until))

async def finish_heist_joining(heist_id: int, join_until: datetime):
    """–ó–∞–≤–µ—Ä—à–∞–µ—Ç —ç—Ç–∞–ø —Å–±–æ—Ä–∞ –∏ –∑–∞–ø—É—Å–∫–∞–µ—Ç —ç—Ç–∞–ø —Ä–∞—Å–ø–∏–ª–∞."""
    delay = max(0, (join_until - datetime.now()).total_seconds())
    await asyncio.sleep(delay)
    async with db_pool.acquire() as conn:
        async with conn.transaction():
            heist = await conn.fetchrow("SELECT * FROM heists WHERE id=$1 AND status='joining' FOR UPDATE", heist_id)
            if not heist:
                return
            await conn.execute(
                "UPDATE heists SET status='splitting' WHERE id=$1",
                heist_id
            )
            participants = await conn.fetch("SELECT user_id FROM heist_participants WHERE heist_id=$1", heist_id)
            if not participants:
                await conn.execute("UPDATE heists SET status='finished' WHERE id=$1", heist_id)
                await safe_send_chat(heist['chat_id'], "‚ùå –ù–∏–∫—Ç–æ –Ω–µ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ –Ω–∞–ª—ë—Ç—É. –û–Ω –æ—Ç–º–µ–Ω—ë–Ω.")
                return

            config = HEIST_TYPES[heist['event_type']]
            split_minutes = await get_setting_int("heist_split_minutes")
            text = get_random_phrase(config.get('phrases_split', ["üî™ –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Ä–∞—Å–ø–∏–ª! –£ —Ç–µ–±—è {minutes} –º–∏–Ω—É—Ç."]), minutes=split_minutes)
            await safe_send_chat(heist['chat_id'], text)

            split_until = heist['split_until']  # —É–∂–µ TIMESTAMP
            await ask_betray_choice(heist_id, split_until)

async def ask_betray_choice(heist_id: int, split_until: datetime):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∫–∞–∂–¥–æ–º—É —É—á–∞—Å—Ç–Ω–∏–∫—É –Ω–∞–ª—ë—Ç–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –≤—ã–±–æ—Ä–æ–º: —É–∫—Ä–∞—Å—Ç—å –∏–ª–∏ –æ—Ç–∫–∞–∑–∞—Ç—å—Å—è."""
    async with db_pool.acquire() as conn:
        participants = await conn.fetch("SELECT user_id FROM heist_participants WHERE heist_id=$1", heist_id)
        if not participants:
            return
        for p in participants:
            user_id = p['user_id']
            kb = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="üî™ –£–∫—Ä–∞—Å—Ç—å —É –ø–æ–¥–µ–ª—å–Ω–∏–∫–æ–≤", callback_data=f"betray_choice_yes_{heist_id}")],
                [InlineKeyboardButton(text="‚ùå –û—Ç–∫–∞–∑–∞—Ç—å—Å—è", callback_data=f"betray_choice_no_{heist_id}")]
            ])
            await safe_send_message(user_id,
                "üî™ –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Ä–∞—Å–ø–∏–ª! –¢—ã –º–æ–∂–µ—à—å –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è —É–∫—Ä–∞—Å—Ç—å —á–∞—Å—Ç—å –¥–æ–±—ã—á–∏ —É –¥—Ä—É–≥–∏—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.\n"
                "–ï—Å–ª–∏ –æ—Ç–∫–∞–∂–µ—à—å—Å—è, –æ—Å—Ç–∞–Ω–µ—à—å—Å—è —Å–æ —Å–≤–æ–µ–π –¥–æ–ª–µ–π, –Ω–æ –º–æ–∂–µ—à—å —Å—Ç–∞—Ç—å –∂–µ—Ä—Ç–≤–æ–π.\n"
                "–£ —Ç–µ–±—è –µ—Å—Ç—å 5 –º–∏–Ω—É—Ç –Ω–∞ –≤—ã–±–æ—Ä.",
                reply_markup=kb
            )
    asyncio.create_task(process_betray_results(heist_id, split_until))

async def process_betray_results(heist_id: int, split_until: datetime):
    """–°–æ–±–∏—Ä–∞–µ—Ç –æ—Ç–≤–µ—Ç—ã —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –∏ –ø—Ä–æ–≤–æ–¥–∏—Ç –∫–∏–¥–∞–ª–æ–≤–æ."""
    delay = max(0, (split_until - datetime.now()).total_seconds())
    await asyncio.sleep(delay)

    async with db_pool.acquire() as conn:
        async with conn.transaction():
            heist = await conn.fetchrow("SELECT * FROM heists WHERE id=$1 AND status='splitting' FOR UPDATE", heist_id)
            if not heist:
                return

            participants = await conn.fetch(
                "SELECT * FROM heist_participants WHERE heist_id=$1",
                heist_id
            )
            if not participants:
                await conn.execute("UPDATE heists SET status='finished' WHERE id=$1", heist_id)
                return

            # –†–∞–∑–¥–µ–ª—è–µ–º –Ω–∞ —Ç–µ—Ö, –∫—Ç–æ —Ö–æ—á–µ—Ç —É–∫—Ä–∞—Å—Ç—å, –∏ —Ç–µ—Ö, –∫—Ç–æ –æ—Ç–∫–∞–∑–∞–ª—Å—è
            attackers = [p for p in participants if p['betray_choice'] == 'yes']
            victims_pool = [p for p in participants]  # –≤—Å–µ, –≤–∫–ª—é—á–∞—è –∞—Ç–∞–∫—É—é—â–∏—Ö, –º–æ–≥—É—Ç –±—ã—Ç—å —Ü–µ–ª—è–º–∏ (–∫—Ä–æ–º–µ —Å–µ–±—è)

            # –°–ª—É—á–∞–π–Ω–æ–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –∞—Ç–∞–∫—É—é—â–∏—Ö —Å —Ü–µ–ª—è–º–∏ (–∫–∞–∂–¥—ã–π –∞—Ç–∞–∫—É—é—â–∏–π –ø–æ–ª—É—á–∞–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—É—é —Ü–µ–ª—å)
            random.shuffle(attackers)
            assigned = {}
            participants_indices = {p['user_id']: i for i, p in enumerate(participants)}
            available_targets = set(range(len(participants)))
            for attacker in attackers:
                attacker_index = participants_indices[attacker['user_id']]
                possible = [i for i in available_targets if i != attacker_index]
                if not possible:
                    continue
                target_index = random.choice(possible)
                target_id = participants[target_index]['user_id']
                assigned[attacker['user_id']] = target_id
                available_targets.remove(target_index)

            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–µ —Ü–µ–ª–∏ –≤ –ë–î
            for attacker_id, target_id in assigned.items():
                await conn.execute(
                    "UPDATE heist_participants SET betray_target_id=$1 WHERE heist_id=$2 AND user_id=$3",
                    target_id, heist_id, attacker_id
                )

            # –¢–µ–ø–µ—Ä—å –≤—ã–ø–æ–ª–Ω—è–µ–º –ø–æ–ø—ã—Ç–∫–∏
            betrayals_log = []  # –¥–ª—è –∏—Ç–æ–≥–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
            for attacker_id, target_id in assigned.items():
                attacker = next(p for p in participants if p['user_id'] == attacker_id)
                target = next(p for p in participants if p['user_id'] == target_id)

                # –ü–æ–ª—É—á–∞–µ–º –Ω–∞–≤—ã–∫–∏
                skills = await get_user_skills(attacker_id)
                betray_bonus = skills['skill_betray'] * await get_setting_int("skill_betray_bonus_per_level")
                base_chance = await get_setting_int("betray_base_chance")
                max_chance = await get_setting_int("betray_max_chance")
                chance = min(base_chance + betray_bonus, max_chance)

                success = random.randint(1, 100) <= chance

                steal_percent = await get_setting_int("betray_steal_percent")
                fail_penalty_percent = await get_setting_int("betray_fail_penalty_percent")

                attacker_share = float(attacker['current_share'])
                target_share = float(target['current_share'])

                if success:
                    steal_amount = target_share * steal_percent / 100
                    new_attacker_share = attacker_share + steal_amount
                    new_target_share = target_share - steal_amount
                    exp = await get_setting_int("exp_per_betray_success")
                    betrayals_log.append((attacker_id, target_id, steal_amount, True))
                else:
                    penalty = attacker_share * fail_penalty_percent / 100
                    new_attacker_share = attacker_share - penalty
                    new_target_share = target_share + penalty
                    exp = await get_setting_int("exp_per_betray_fail")
                    betrayals_log.append((attacker_id, target_id, penalty, False))

                # –û–±–Ω–æ–≤–ª—è–µ–º –¥–æ–ª–∏
                await conn.execute(
                    "UPDATE heist_participants SET current_share=$1 WHERE heist_id=$2 AND user_id=$3",
                    new_attacker_share, heist_id, attacker_id
                )
                await conn.execute(
                    "UPDATE heist_participants SET current_share=$1 WHERE heist_id=$2 AND user_id=$3",
                    new_target_share, heist_id, target_id
                )
                # –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤ heist_betrayals
                await conn.execute(
                    "INSERT INTO heist_betrayals (heist_id, attacker_id, target_id, success, amount, created_at) VALUES ($1, $2, $3, $4, $5, $6)",
                    heist_id, attacker_id, target_id, success, abs(attacker_share - new_attacker_share), datetime.now()
                )
                # –î–æ–±–∞–≤–ª—è–µ–º –æ–ø—ã—Ç ‚Äì —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤–æ–∑–≤—Ä–∞—â—ë–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–æ—Å–ª–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
                level_up_msg = await add_exp(attacker_id, exp, conn=conn)
                if level_up_msg:
                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ—Å–ª–µ –∫–æ–º–º–∏—Ç–∞ (–Ω–æ –≤ —Ç–µ–∫—É—â–µ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –º—ã –Ω–µ –º–æ–∂–µ–º –æ—Ç–ø—Ä–∞–≤–∏—Ç—å, –ø–æ—ç—Ç–æ–º—É —Å–æ—Ö—Ä–∞–Ω—è–µ–º)
                    # –í —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω—É–∂–Ω–æ —Å–æ–±—Ä–∞—Ç—å –≤—Å–µ —Ç–∞–∫–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–æ—Å–ª–µ –∫–æ–º–º–∏—Ç–∞
                    # –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –æ—Ç–ø—Ä–∞–≤–∏–º —Å—Ä–∞–∑—É, –Ω–æ —ç—Ç–æ –Ω–∞—Ä—É—à–∞–µ—Ç –ø—Ä–∏–Ω—Ü–∏–ø (–æ—Ç–ø—Ä–∞–≤–∫–∞ –≤–Ω—É—Ç—Ä–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏)
                    # –õ—É—á—à–µ —Å–æ–±—Ä–∞—Ç—å –≤ —Å–ø–∏—Å–æ–∫ –∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–æ—Å–ª–µ –≤—ã—Ö–æ–¥–∞ –∏–∑ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
                    # –ó–¥–µ—Å—å –º—ã –Ω–µ –º–æ–∂–µ–º —ç—Ç–æ–≥–æ —Å–¥–µ–ª–∞—Ç—å –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Ñ—É–Ω–∫—Ü–∏–∏, –ø–æ—ç—Ç–æ–º—É –ø–æ–∫–∞ –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å
                    # –í–ê–ñ–ù–û: —ç—Ç–æ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –ø—Ä–æ–±–ª–µ–º–∞, –Ω–æ –æ–Ω–∞ –Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã
                    asyncio.create_task(safe_send_message(attacker_id, level_up_msg))

                await set_global_cooldown(attacker_id, "betray")
                await conn.execute(
                    "UPDATE users SET heists_betray_attempts = heists_betray_attempts + 1, heists_betray_success = heists_betray_success + $1 WHERE user_id=$2",
                    1 if success else 0, attacker_id
                )
                await conn.execute(
                    "UPDATE users SET heists_betrayed_count = heists_betrayed_count + 1 WHERE user_id=$1",
                    target_id
                )

            # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–æ–ø –ø–æ –∏—Ç–æ–≥–æ–≤–æ–π –¥–æ–ª–µ (–±–µ–∑ —Å—É–º–º)
            final_participants = await conn.fetch(
                "SELECT user_id, current_share FROM heist_participants WHERE heist_id=$1 ORDER BY current_share DESC",
                heist_id
            )
            top_list = []
            for idx, p in enumerate(final_participants[:3], 1):
                user_info = await conn.fetchrow("SELECT first_name FROM users WHERE user_id=$1", p['user_id'])
                name = user_info['first_name'] if user_info else f"ID{p['user_id']}"
                top_list.append(f"{idx}. {name}")

            top_str = "\n".join(top_list)

            # –ò—Ç–æ–≥–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ (–±–µ–∑ —Å—É–º–º—ã)
            config = HEIST_TYPES[heist['event_type']]
            text = get_random_phrase(config.get('phrases_result', ["üèÅ –ù–∞–ª—ë—Ç –∑–∞–≤–µ—Ä—à—ë–Ω!\nüèÜ –¢–æ–ø –≤–æ—Ä–æ–≤:\n{top}"]), top=top_str)
            await safe_send_chat(heist['chat_id'], text)

            # –ù–∞—á–∏—Å–ª—è–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–µ –¥–æ–ª–∏
            for p in final_participants:
                await update_user_balance(p['user_id'], float(p['current_share']), conn=conn, allow_negative=False)

            await conn.execute("UPDATE heists SET status='finished' WHERE id=$1", heist_id)

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ö–û–ù–¢–†–ê–ë–ê–ù–î–´ ====================
@db_retry()
async def check_smuggle_cooldown(user_id: int) -> Tuple[bool, int]:
    async with db_pool.acquire() as conn:
        row = await conn.fetchrow("SELECT cooldown_until FROM smuggle_cooldowns WHERE user_id=$1", user_id)
        if row and row['cooldown_until']:
            cooldown_until = row['cooldown_until']
            remaining = (cooldown_until - datetime.now()).total_seconds()
            if remaining > 0:
                return False, int(remaining)
    return True, 0

@db_retry()
async def set_smuggle_cooldown(user_id: int, penalty: int = 0):
    base = await get_setting_int("smuggle_cooldown_minutes")
    cooldown_until = datetime.now() + timedelta(minutes=base + penalty)
    async with db_pool.acquire() as conn:
        await conn.execute('''
            INSERT INTO smuggle_cooldowns (user_id, cooldown_until)
            VALUES ($1, $2)
            ON CONFLICT (user_id) DO UPDATE SET cooldown_until = $2
        ''', user_id, cooldown_until)

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –¢–Æ–†–¨–ú–´ ====================
@db_retry()
async def start_jail_sentence(user_id: int, chat_id: int, duration_minutes: int, cell: int, article: int):
    now = datetime.now()
    end_time = now + timedelta(minutes=duration_minutes)
    async with db_pool.acquire() as conn:
        await conn.execute(
            "INSERT INTO jail_sentences (user_id, chat_id, start_time, end_time, cell_number, article_number) VALUES ($1, $2, $3, $4, $5, $6)",
            user_id, chat_id, now, end_time, cell, article
        )
    return end_time

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –†–ê–°–ß–Å–¢–ê –®–ê–ù–°–û–í (–î–õ–Ø –ö–†–ê–ñ) ====================
async def get_theft_success_chance(attacker_id: int) -> float:
    base = await get_setting_float("theft_success_chance")
    rep = await get_user_reputation(attacker_id)
    bonus = float(await get_setting_float("reputation_theft_bonus")) * rep
    max_bonus = await get_setting_float("reputation_max_bonus_percent")
    bonus = min(bonus, max_bonus)
    return base + bonus

async def get_defense_chance(victim_id: int) -> float:
    base = await get_setting_float("theft_defense_chance")
    rep = await get_user_reputation(victim_id)
    bonus = float(await get_setting_float("reputation_defense_bonus")) * rep
    max_bonus = await get_setting_float("reputation_max_bonus_percent")
    bonus = min(bonus, max_bonus)
    return base + bonus

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –û–ß–ò–°–¢–ö–ò ====================
@db_retry()
async def perform_cleanup(manual=False):
    days_heists = await get_setting_int("cleanup_days_heists")
    days_purchases = await get_setting_int("cleanup_days_purchases")
    days_giveaways = await get_setting_int("cleanup_days_giveaways")
    days_tasks = await get_setting_int("cleanup_days_user_tasks")
    days_smuggle = await get_setting_int("cleanup_days_smuggle")
    days_orders = await get_setting_int("cleanup_days_bitcoin_orders")
    days_jail = 30

    now = datetime.now()
    cutoff_heists = now - timedelta(days=days_heists)
    cutoff_purchases = now - timedelta(days=days_purchases)
    cutoff_giveaways = now - timedelta(days=days_giveaways)
    cutoff_tasks = now - timedelta(days=days_tasks)
    cutoff_smuggle = now - timedelta(days=days_smuggle)
    cutoff_orders = now - timedelta(days=days_orders)
    cutoff_jail = now - timedelta(days=days_jail)

    async with db_pool.acquire() as conn:
        await conn.execute("DELETE FROM heists WHERE status='finished' AND split_until < $1", cutoff_heists)
        await conn.execute("DELETE FROM purchases WHERE status IN ('completed','rejected') AND purchase_date < $1", cutoff_purchases)
        await conn.execute("DELETE FROM giveaways WHERE status='completed' AND end_date < $1", cutoff_giveaways)
        await conn.execute("DELETE FROM user_tasks WHERE expires_at IS NOT NULL AND expires_at < $1", cutoff_tasks)
        await conn.execute("DELETE FROM smuggle_runs WHERE status IN ('completed', 'failed') AND end_time < $1", cutoff_smuggle)
        await conn.execute("DELETE FROM bitcoin_orders WHERE status IN ('completed', 'cancelled') AND created_at < $1", cutoff_orders)
        await conn.execute("DELETE FROM jail_sentences WHERE status='completed' AND end_time < $1", cutoff_jail)

        cutoff_cooldown = now - timedelta(days=1)
        await conn.execute("DELETE FROM global_cooldowns WHERE last_used < $1", cutoff_cooldown)

    if manual:
        logging.info("–†—É—á–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞.")
    else:
        logging.info("–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞.")

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –≠–ö–°–ü–û–†–¢–ê ====================
@db_retry()
async def export_users_to_csv() -> bytes:
    async with db_pool.acquire() as conn:
        rows = await conn.fetch("SELECT * FROM users ORDER BY user_id")
    if not rows:
        return b""
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow(dict(rows[0]).keys())
    for row in rows:
        writer.writerow(dict(row).values())
    return output.getvalue().encode('utf-8')

ALLOWED_TABLES = ['users', 'purchases', 'heists', 'giveaways', 'tasks', 'bitcoin_orders']
@db_retry()
async def export_table_to_csv(table: str) -> Optional[bytes]:
    if table not in ALLOWED_TABLES:
        return None
    # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —ç–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–º–µ–Ω–∏ —Ç–∞–±–ª–∏—Ü—ã –¥–≤–æ–π–Ω—ã–º–∏ –∫–∞–≤—ã—á–∫–∞–º–∏
    table_escaped = table.replace('"', '""')
    async with db_pool.acquire() as conn:
        query = f'SELECT * FROM "{table_escaped}" ORDER BY id'
        try:
            rows = await conn.fetch(query)
        except Exception:
            return None
        if not rows:
            return None
        output = io.StringIO()
        writer = csv.writer(output)
        writer.writerow(dict(rows[0]).keys())
        for row in rows:
            writer.writerow(dict(row).values())
        return output.getvalue().encode('utf-8')

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ë–ò–¢–ö–û–ò–ù-–ë–ò–†–ñ–ò (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ, —Å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è–º–∏ –∏ RETURNING) ====================
@db_retry()
async def get_order_book() -> Dict[str, List[Dict]]:
    async with db_pool.acquire() as conn:
        buy_orders = await conn.fetch("""
            SELECT price, SUM(amount) as total_amount, COUNT(*) as count
            FROM bitcoin_orders
            WHERE type='buy' AND status='active'
            GROUP BY price
            ORDER BY price DESC
        """)
        sell_orders = await conn.fetch("""
            SELECT price, SUM(amount) as total_amount, COUNT(*) as count
            FROM bitcoin_orders
            WHERE type='sell' AND status='active'
            GROUP BY price
            ORDER BY price ASC
        """)
        bids = []
        for r in buy_orders:
            bids.append({
                'price': r['price'],
                'total_amount': float(r['total_amount']),
                'count': r['count']
            })
        asks = []
        for r in sell_orders:
            asks.append({
                'price': r['price'],
                'total_amount': float(r['total_amount']),
                'count': r['count']
            })
        return {'bids': bids, 'asks': asks}

@db_retry()
async def get_active_orders(order_type: str = None) -> List[dict]:
    async with db_pool.acquire() as conn:
        if order_type == 'buy':
            rows = await conn.fetch("SELECT * FROM bitcoin_orders WHERE type='buy' AND status='active' ORDER BY price DESC, created_at ASC")
        elif order_type == 'sell':
            rows = await conn.fetch("SELECT * FROM bitcoin_orders WHERE type='sell' AND status='active' ORDER BY price ASC, created_at ASC")
        else:
            rows = await conn.fetch("SELECT * FROM bitcoin_orders WHERE status='active' ORDER BY created_at DESC")
        result = []
        for r in rows:
            d = dict(r)
            d['amount'] = float(d['amount'])
            d['total_locked'] = float(d['total_locked'])
            result.append(d)
        return result

@db_retry()
async def create_bitcoin_order(user_id: int, order_type: str, amount: float, price: int) -> int:
    async with db_pool.acquire() as conn:
        async with conn.transaction():
            await conn.execute("SET LOCAL statement_timeout = '5s'")
            if order_type == 'sell':
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏ —Å–ø–∏—Å—ã–≤–∞–µ–º BTC
                success, new_balance = await update_user_bitcoin(user_id, -amount, conn=conn)
                if not success:
                    raise ValueError("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ BTC")
                total_locked = amount
            else:  # buy
                total_cost = amount * price
                # –ë–ª–æ–∫–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å
                user_row = await conn.fetchrow("SELECT balance FROM users WHERE user_id=$1 FOR UPDATE", user_id)
                if not user_row:
                    await ensure_user_exists(user_id)
                    user_row = await conn.fetchrow("SELECT balance FROM users WHERE user_id=$1 FOR UPDATE", user_id)
                current_balance = float(user_row['balance'])
                if current_balance < total_cost - 0.01:
                    raise ValueError("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∞–∫—Å–æ–≤")
                # –û–±–Ω–æ–≤–ª—è–µ–º –±–∞–ª–∞–Ω—Å, –∑–∞–ø—Ä–µ—â–∞—è —É—Ö–æ–¥ –≤ –º–∏–Ω—É—Å
                success, new_balance, _ = await update_user_balance(user_id, -total_cost, conn=conn, allow_negative=False)
                if not success:
                    raise ValueError("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∞–∫—Å–æ–≤ (–æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–ø–∏—Å–∞–Ω–∏–∏)")
                total_locked = total_cost

            order_id = await conn.fetchval(
                "INSERT INTO bitcoin_orders (user_id, type, amount, price, total_locked) VALUES ($1, $2, $3, $4, $5) RETURNING id",
                user_id, order_type, amount, price, total_locked
            )
            await match_orders(conn)
            return order_id

@db_retry()
async def cancel_bitcoin_order(order_id: int, user_id: int) -> bool:
    async with db_pool.acquire() as conn:
        async with conn.transaction():
            await conn.execute("SET LOCAL statement_timeout = '5s'")
            order = await conn.fetchrow("SELECT * FROM bitcoin_orders WHERE id=$1 AND user_id=$2 AND status='active' FOR UPDATE", order_id, user_id)
            if not order:
                return False
            total_locked = float(order['total_locked'])
            if order['type'] == 'sell':
                await update_user_bitcoin(user_id, total_locked, conn=conn)
            else:
                await update_user_balance(user_id, total_locked, conn=conn, allow_negative=False)  # –≤–æ–∑–≤—Ä–∞—Ç —Å—Ä–µ–¥—Å—Ç–≤
            await conn.execute("UPDATE bitcoin_orders SET status='cancelled' WHERE id=$1", order_id)
            return True

async def match_orders(conn):
    while True:
        buy = await conn.fetchrow("""
            SELECT id, user_id, price, amount, total_locked
            FROM bitcoin_orders
            WHERE type='buy' AND status='active'
            ORDER BY price DESC, created_at ASC
            LIMIT 1
            FOR UPDATE SKIP LOCKED
        """)
        sell = await conn.fetchrow("""
            SELECT id, user_id, price, amount, total_locked
            FROM bitcoin_orders
            WHERE type='sell' AND status='active'
            ORDER BY price ASC, created_at ASC
            LIMIT 1
            FOR UPDATE SKIP LOCKED
        """)
        if not buy or not sell or buy['price'] < sell['price']:
            break

        buy_amount = float(buy['amount'])
        buy_total_locked = float(buy['total_locked'])
        sell_amount = float(sell['amount'])
        sell_total_locked = float(sell['total_locked'])
        trade_price = sell['price']

        trade_amount = min(buy_amount, sell_amount)
        total_cost = trade_amount * trade_price

        buyer_id = buy['user_id']
        seller_id = sell['user_id']

        await update_user_balance(seller_id, total_cost, conn=conn, allow_negative=False)
        await update_user_bitcoin(buyer_id, trade_amount, conn=conn)

        new_buy_amount = buy_amount - trade_amount
        new_sell_amount = sell_amount - trade_amount
        new_buy_locked = buy_total_locked - total_cost
        new_sell_locked = sell_total_locked - trade_amount

        if new_buy_amount <= 0.0001:
            await conn.execute("UPDATE bitcoin_orders SET status='completed', amount=0, total_locked=0 WHERE id=$1", buy['id'])
        else:
            await conn.execute("UPDATE bitcoin_orders SET amount=$1, total_locked=$2 WHERE id=$3", new_buy_amount, new_buy_locked, buy['id'])

        if new_sell_amount <= 0.0001:
            await conn.execute("UPDATE bitcoin_orders SET status='completed', amount=0, total_locked=0 WHERE id=$1", sell['id'])
        else:
            await conn.execute("UPDATE bitcoin_orders SET amount=$1, total_locked=$2 WHERE id=$3", new_sell_amount, new_sell_locked, sell['id'])

        await conn.execute(
            "INSERT INTO bitcoin_trades (buy_order_id, sell_order_id, amount, price, buyer_id, seller_id) VALUES ($1, $2, $3, $4, $5, $6)",
            buy['id'], sell['id'], trade_amount, trade_price, buyer_id, seller_id
        )

# ==================== –ù–û–í–´–ï –§–£–ù–ö–¶–ò–ò –î–õ–Ø –°–ë–†–û–°–ê –°–¢–ê–¢–ò–°–¢–ò–ö–ò ====================
@db_retry()
async def generate_reset_key(user_id: int, expire_minutes: int = 10) -> str:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–π 6-–∑–Ω–∞—á–Ω—ã–π –∫–ª—é—á –¥–ª—è —Å–±—Ä–æ—Å–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∞–¥–º–∏–Ω–æ–º)"""
    key = ''.join(random.choices(string.digits, k=6))
    expires_at = datetime.now() + timedelta(minutes=expire_minutes)
    async with db_pool.acquire() as conn:
        await conn.execute(
            "INSERT INTO reset_keys (key, user_id, expires_at) VALUES ($1, $2, $3)",
            key, user_id, expires_at
        )
    return key

@db_retry()
async def verify_reset_key(key: str, user_id: int) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∫–ª—é—á —Å–±—Ä–æ—Å–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∞–¥–º–∏–Ω–æ–º –∏–ª–∏ —Å–∞–º–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ)"""
    async with db_pool.acquire() as conn:
        row = await conn.fetchrow(
            "SELECT * FROM reset_keys WHERE key=$1 AND user_id=$2 AND used=FALSE AND expires_at > NOW()",
            key, user_id
        )
        if row:
            await conn.execute("UPDATE reset_keys SET used=TRUE WHERE key=$1", key)
            return True
    return False

@db_retry()
async def reset_user_stats(user_id: int):
    """–°–±—Ä–∞—Å—ã–≤–∞–µ—Ç –≤—Å—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–∫—Ä–æ–º–µ –±–∞–ª–∞–Ω—Å–∞ –∏ –±–∏–∑–Ω–µ—Å–æ–≤). –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∞–¥–º–∏–Ω–æ–º."""
    async with db_pool.acquire() as conn:
        await conn.execute("""
            UPDATE users SET
                reputation = 0,
                total_spent = 0,
                negative_balance = 0,
                last_bonus = NULL,
                last_theft_time = NULL,
                theft_attempts = 0,
                theft_success = 0,
                theft_failed = 0,
                theft_protected = 0,
                casino_wins = 0,
                casino_losses = 0,
                dice_wins = 0,
                dice_losses = 0,
                guess_wins = 0,
                guess_losses = 0,
                slots_wins = 0,
                slots_losses = 0,
                roulette_wins = 0,
                roulette_losses = 0,
                exp = 0,
                level = 1,
                last_gift_time = NULL,
                gift_count_today = 0,
                global_authority = 0,
                smuggle_success = 0,
                smuggle_fail = 0,
                authority_balance = 0,
                skill_share = 0,
                skill_luck = 0,
                skill_betray = 0,
                heists_joined = 0,
                heists_betray_attempts = 0,
                heists_betray_success = 0,
                heists_betrayed_count = 0,
                heists_earned = 0,
                strength = 1,
                agility = 1,
                defense = 1
            WHERE user_id = $1
        """, user_id)
        # –£–¥–∞–ª—è–µ–º –≤—Å–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –∑–∞–¥–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        await conn.execute("DELETE FROM user_tasks WHERE user_id = $1", user_id)
        # –û—Ç–º–µ–Ω—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–∞—è–≤–∫–∏ –Ω–∞ –±–∏—Ä–∂–µ
        await conn.execute("UPDATE bitcoin_orders SET status='cancelled' WHERE user_id=$1 AND status='active'", user_id)
        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∫—É–ª–¥–∞—É–Ω—ã
        await conn.execute("DELETE FROM global_cooldowns WHERE user_id=$1", user_id)

# ==================== –ù–û–í–´–ï –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ó–ê–î–ê–ù–ò–ô ====================
@db_retry()
async def create_subscribe_task(name: str, description: str, channel_id: str, 
                                reward_coins: float, reward_reputation: int, 
                                max_completions: int, media_file_id: str = None, 
                                media_type: str = None, button_link: str = None,
                                created_by: int = None) -> int:
    async with db_pool.acquire() as conn:
        task_id = await conn.fetchval("""
            INSERT INTO tasks 
                (name, description, task_type, target_id, reward_coins, reward_reputation, 
                 max_completions, media_file_id, media_type, button_link, created_by, created_at, active)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
            RETURNING id
        """, name, description, 'subscribe', channel_id, reward_coins, reward_reputation,
            max_completions, media_file_id, media_type, button_link, created_by, 
            datetime.now().strftime("%Y-%m-%d %H:%M:%S"), True)
        return task_id

async def check_user_subscription(user_id: int, channel_id: str) -> bool:
    try:
        member = await bot.get_chat_member(channel_id, user_id)
        return member.status not in ['left', 'kicked']
    except Exception as e:
        logging.error(f"Error checking subscription for {user_id} to {channel_id}: {e}")
        return False

@db_retry()
async def complete_task(user_id: int, task_id: int):
    async with db_pool.acquire() as conn:
        async with conn.transaction():
            await conn.execute("SET LOCAL statement_timeout = '5s'")
            existing = await conn.fetchval(
                "SELECT 1 FROM user_tasks WHERE user_id=$1 AND task_id=$2",
                user_id, task_id
            )
            if existing:
                return False, "–í—ã —É–∂–µ –≤—ã–ø–æ–ª–Ω–∏–ª–∏ —ç—Ç–æ –∑–∞–¥–∞–Ω–∏–µ"
            
            task = await conn.fetchrow("SELECT * FROM tasks WHERE id=$1 AND active=TRUE", task_id)
            if not task:
                return False, "–ó–∞–¥–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ"
            
            if task['max_completions'] > 0 and task['completed_count'] >= task['max_completions']:
                return False, "–õ–∏–º–∏—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–π –∑–∞–¥–∞–Ω–∏—è –∏—Å—á–µ—Ä–ø–∞–Ω"
            
            if float(task['reward_coins']) > 0:
                await update_user_balance(user_id, float(task['reward_coins']), conn=conn, allow_negative=False)
            if task['reward_reputation'] > 0:
                await update_user_reputation(user_id, task['reward_reputation'])
            
            await conn.execute(
                "INSERT INTO user_tasks (user_id, task_id, completed_at) VALUES ($1, $2, $3)",
                user_id, task_id, datetime.now()
            )
            await conn.execute(
                "UPDATE tasks SET completed_count = completed_count + 1 WHERE id=$1",
                task_id
            )
            return True, f"‚úÖ –ó–∞–¥–∞–Ω–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ! +{float(task['reward_coins']):.2f} –±–∞–∫—Å–æ–≤, +{task['reward_reputation']} —Ä–µ–ø—É—Ç–∞—Ü–∏–∏"

# ==================== –ù–û–í–´–ï –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ü–†–û–ú–û–ö–û–î–û–í ====================
@db_retry()
async def create_promocode(code: str, reward: float, reward_type: str, max_uses: int, created_by: int = None):
    async with db_pool.acquire() as conn:
        await conn.execute(
            "INSERT INTO promocodes (code, reward, reward_type, max_uses, created_at, created_by) VALUES ($1, $2, $3, $4, $5, $6)",
            code, reward, reward_type, max_uses, datetime.now().strftime("%Y-%m-%d %H:%M:%S"), created_by
        )

@db_retry()
async def activate_promocode(user_id: int, code: str) -> Tuple[bool, str]:
    async with db_pool.acquire() as conn:
        async with conn.transaction():
            await conn.execute("SET LOCAL statement_timeout = '5s'")
            used = await conn.fetchval(
                "SELECT 1 FROM promo_activations WHERE user_id=$1 AND promo_code=$2",
                user_id, code
            )
            if used:
                return False, "–í—ã —É–∂–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–ª–∏ —ç—Ç–æ—Ç –ø—Ä–æ–º–æ–∫–æ–¥"
            
            promo = await conn.fetchrow("SELECT * FROM promocodes WHERE code=$1", code)
            if not promo:
                return False, "–ü—Ä–æ–º–æ–∫–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω"
            
            if promo['used_count'] >= promo['max_uses']:
                return False, "–ü—Ä–æ–º–æ–∫–æ–¥ —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞–∑"
            
            reward = float(promo['reward'])
            if promo['reward_type'] == 'bitcoin':
                await update_user_bitcoin(user_id, reward, conn=conn)
                reward_text = f"{reward:.4f} BTC"
            else:
                await update_user_balance(user_id, reward, conn=conn, allow_negative=False)
                reward_text = f"{reward:.2f} –±–∞–∫—Å–æ–≤"
            
            await conn.execute(
                "UPDATE promocodes SET used_count = used_count + 1 WHERE code=$1",
                code
            )
            await conn.execute(
                "INSERT INTO promo_activations (user_id, promo_code, activated_at) VALUES ($1, $2, $3)",
                user_id, code, datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            )
            return True, f"‚úÖ –ü—Ä–æ–º–æ–∫–æ–¥ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω! –í—ã –ø–æ–ª—É—á–∏–ª–∏ {reward_text}"

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ò–Ø –ù–ê–õ–Å–¢–û–í (–ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø) ====================
@db_retry()
async def recover_heists():
    """–í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –Ω–µ–∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–µ –Ω–∞–ª—ë—Ç—ã –ø–æ—Å–ª–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞.
       –¢–∞–∫–∂–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–ª—ë—Ç—ã, —É –∫–æ—Ç–æ—Ä—ã—Ö –≤—Ä–µ–º—è –∏—Å—Ç–µ–∫–ª–æ, –Ω–æ —Å—Ç–∞—Ç—É—Å –Ω–µ –æ–±–Ω–æ–≤–ª—ë–Ω."""
    async with db_pool.acquire() as conn:
        # –ù–∞–ª—ë—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –¥–æ–ª–∂–Ω—ã –±—ã–ª–∏ –ø–µ—Ä–µ–π—Ç–∏ –≤ splitting, –Ω–æ –Ω–µ –ø–µ—Ä–µ—à–ª–∏
        joining_heists = await conn.fetch(
            "SELECT id, join_until FROM heists WHERE status='joining' AND join_until <= NOW()"
        )
        for h in joining_heists:
            # –ó–∞–≤–µ—Ä—à–∞–µ–º —ç—Ç–∞–ø —Å–±–æ—Ä–∞ (–±–µ–∑ –æ–∂–∏–¥–∞–Ω–∏—è)
            asyncio.create_task(finish_heist_joining(h['id'], h['join_until']))

        # –ù–∞–ª—ë—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –¥–æ–ª–∂–Ω—ã –±—ã–ª–∏ –ø–µ—Ä–µ–π—Ç–∏ –≤ finished, –Ω–æ –Ω–µ –ø–µ—Ä–µ—à–ª–∏
        splitting_heists = await conn.fetch(
            "SELECT id, split_until FROM heists WHERE status='splitting' AND split_until <= NOW()"
        )
        for h in splitting_heists:
            # –ó–∞–≤–µ—Ä—à–∞–µ–º —ç—Ç–∞–ø —Ä–∞—Å–ø–∏–ª–∞ (–±–µ–∑ –æ–∂–∏–¥–∞–Ω–∏—è)
            asyncio.create_task(process_betray_results(h['id'], h['split_until']))

        # –ê–∫—Ç–∏–≤–Ω—ã–µ –Ω–∞–ª—ë—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –µ—â—ë –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ
        active_joining = await conn.fetch(
            "SELECT id, join_until FROM heists WHERE status='joining' AND join_until > NOW()"
        )
        for h in active_joining:
            join_until = h['join_until']
            asyncio.create_task(finish_heist_joining(h['id'], join_until))

        active_splitting = await conn.fetch(
            "SELECT id, split_until FROM heists WHERE status='splitting' AND split_until > NOW()"
        )
        for h in active_splitting:
            split_until = h['split_until']
            asyncio.create_task(process_betray_results(h['id'], split_until))

    logging.info(f"–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ {len(joining_heists)} –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã—Ö –∏ {len(active_joining)} –∞–∫—Ç–∏–≤–Ω—ã—Ö –Ω–∞–ª—ë—Ç–æ–≤ –≤ —Å–±–æ—Ä–µ, "
                 f"{len(splitting_heists)} –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã—Ö –∏ {len(active_splitting)} –∞–∫—Ç–∏–≤–Ω—ã—Ö –≤ —Ä–∞—Å–ø–∏–ª–µ.")

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ü–û–õ–£–ß–ï–ù–ò–Ø –ò–ù–§–û–†–ú–ê–¶–ò–ò –û –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ï ====================
@db_retry()
async def get_user_name(user_id: int) -> str:
    async with db_pool.acquire() as conn:
        name = await conn.fetchval("SELECT first_name FROM users WHERE user_id=$1", user_id)
        return name or f"ID{user_id}"

@db_retry()
async def get_user_username(user_id: int) -> str:
    async with db_pool.acquire() as conn:
        username = await conn.fetchval("SELECT username FROM users WHERE user_id=$1", user_id)
        return username or "–Ω–µ—Ç —é–∑–µ—Ä–Ω–µ–π–º–∞"

# ==================== –†–ï–ì–ò–°–¢–†–ê–¶–ò–Ø –ú–ò–î–õ–í–ê–†–ï–ô ====================
dp.message.middleware(ThrottlingMiddleware(rate_limit=0.5))
dp.message.middleware(GlobalCooldownMiddleware())

# ==================== –ö–û–ù–ï–¶ –ß–ê–°–¢–ò 1 ====================
# ==================== –ß–ê–°–¢–¨ 2: –°–û–°–¢–û–Ø–ù–ò–Ø FSM –ò –ö–õ–ê–í–ò–ê–¢–£–†–´ ====================
# –ü–æ–ª–Ω–æ—Å—Ç—å—é –ø–µ—Ä–µ–ø–∏—Å–∞–Ω–æ –¥–ª—è aiogram 3.x. –í—Å–µ –æ—à–∏–±–∫–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã.
# –î–æ–±–∞–≤–ª–µ–Ω—ã –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è, –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω—ã –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã.

from aiogram.fsm.state import State, StatesGroup
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder
from typing import List, Dict, Tuple, Optional

# ==================== –°–û–°–¢–û–Ø–ù–ò–Ø FSM ====================
# –í—Å–µ –∫–ª–∞—Å—Å—ã —Å–æ—Å—Ç–æ—è–Ω–∏–π —Å –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ–º –æ—Ç StatesGroup

class CreateGiveaway(StatesGroup):
    prize = State()
    description = State()
    condition_type = State()
    end_date = State()
    min_participants = State()
    winners_count = State()
    media = State()

class AddChannel(StatesGroup):
    chat_id = State()
    title = State()
    invite_link = State()

class RemoveChannel(StatesGroup):
    chat_id = State()

class AddShopItem(StatesGroup):
    name = State()
    description = State()
    price = State()
    stock = State()
    photo = State()

class RemoveShopItem(StatesGroup):
    item_id = State()

class EditShopItem(StatesGroup):
    item_id = State()
    field = State()
    value = State()

class CreatePromocode(StatesGroup):
    code = State()
    reward = State()
    reward_type = State()
    max_uses = State()

class Broadcast(StatesGroup):
    media = State()

class AddBalance(StatesGroup):
    user_id = State()
    amount = State()

class RemoveBalance(StatesGroup):
    user_id = State()
    amount = State()

class AddReputation(StatesGroup):
    user_id = State()
    amount = State()

class RemoveReputation(StatesGroup):
    user_id = State()
    amount = State()

class AddExp(StatesGroup):
    user_id = State()
    amount = State()

class SetLevel(StatesGroup):
    user_id = State()
    level = State()

class AddBitcoin(StatesGroup):
    user_id = State()
    amount = State()

class RemoveBitcoin(StatesGroup):
    user_id = State()
    amount = State()

class AddAuthority(StatesGroup):
    user_id = State()
    amount = State()

class RemoveAuthority(StatesGroup):
    user_id = State()
    amount = State()

class DiceBet(StatesGroup):
    amount = State()

class GuessBet(StatesGroup):
    amount = State()
    number = State()

class SlotsBet(StatesGroup):
    amount = State()

class RouletteBet(StatesGroup):
    amount = State()
    bet_type = State()
    number = State()

class PromoActivate(StatesGroup):
    code = State()

class TheftTarget(StatesGroup):
    target = State()

class FindUser(StatesGroup):
    query = State()

class AddJuniorAdmin(StatesGroup):
    user_id = State()
    permissions = State()

class EditAdminPermissions(StatesGroup):
    user_id = State()
    selecting_permissions = State()
    confirm = State()

class RemoveJuniorAdmin(StatesGroup):
    user_id = State()

class CompleteGiveaway(StatesGroup):
    giveaway_id = State()
    winners_count = State()

class BlockUser(StatesGroup):
    user_id = State()
    reason = State()

class UnblockUser(StatesGroup):
    user_id = State()

class EditSettings(StatesGroup):
    key = State()
    value = State()

class CreateTask(StatesGroup):
    name = State()
    description = State()
    task_type = State()
    target_id = State()
    reward_coins = State()
    reward_reputation = State()
    required_days = State()
    penalty_days = State()
    max_completions = State()
    media = State()
    button_link = State()

class DeleteTask(StatesGroup):
    task_id = State()

class ManageChats(StatesGroup):
    action = State()
    chat_id = State()

class AddBusiness(StatesGroup):
    name = State()
    emoji = State()
    price = State()
    income = State()
    description = State()
    max_level = State()
    lifetime_hours = State()
    image_key = State()

class EditBusiness(StatesGroup):
    business_id = State()
    field = State()
    value = State()

class ToggleBusiness(StatesGroup):
    business_id = State()
    confirm = State()

class BuyBusiness(StatesGroup):
    business_type_id = State()
    confirming = State()

class UpgradeBusiness(StatesGroup):
    business_id = State()
    confirming = State()

class AddMedia(StatesGroup):
    key = State()
    file = State()

class RemoveMedia(StatesGroup):
    key = State()

# ----- –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è –±–∏—Ä–∂–∏ -----
class BuyBitcoin(StatesGroup):
    amount = State()
    price = State()

class SellBitcoin(StatesGroup):
    amount = State()
    price = State()

class CancelBitcoinOrder(StatesGroup):
    order_id = State()

# ----- –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è –ø–æ–∫—É–ø–∫–∏/–ø—Ä–æ–¥–∞–∂–∏ –ø–æ —Ü–µ–Ω–µ –∏–∑ —Å—Ç–∞–∫–∞–Ω–∞ -----
class BuyFromPrice(StatesGroup):
    amount = State()

class SellToPrice(StatesGroup):
    amount = State()

# ----- –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è –Ω–∞–ª—ë—Ç–æ–≤ -----
class HeistBetrayConfirm(StatesGroup):
    # –û—Å—Ç–∞–≤–ª–µ–Ω–æ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏, –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è
    pass

# ----- –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è —Ç—é—Ä—å–º—ã -----
class JailProcess(StatesGroup):
    cell = State()      # –Ω–æ–º–µ—Ä –∫–∞–º–µ—Ä—ã (1-15)
    article = State()   # –Ω–æ–º–µ—Ä —Å—Ç–∞—Ç—å–∏ (1-300)

# ----- –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è –ø—Ä–æ–∫–∞—á–∫–∏ –Ω–∞–≤—ã–∫–æ–≤ -----
class UpgradeSkill(StatesGroup):
    skill = State()
    confirming = State()

# ----- –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è —Å–±—Ä–æ—Å–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ (–∞–¥–º–∏–Ω –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç –∫–ª—é—á–æ–º) -----
class AdminResetStats(StatesGroup):
    user_id = State()
    confirm_key = State()

# ----- –°–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è –ø–æ–∫—É–ø–∫–∏ -----
class PurchaseReject(StatesGroup):
    comment = State()

# ----- –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π -----
class EditGiveaway(StatesGroup):
    field = State()
    prize = State()
    description = State()
    end_date = State()
    min_participants = State()
    winners_count = State()
    media = State()

# ==================== –ö–õ–ê–í–ò–ê–¢–£–†–´ ====================

def back_keyboard():
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ —Å –æ–¥–Ω–æ–π –∫–Ω–æ–ø–∫–æ–π "‚óÄÔ∏è –ù–∞–∑–∞–¥"."""
    return ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥")]], resize_keyboard=True)

def cancel_keyboard():
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ —Å –æ–¥–Ω–æ–π –∫–Ω–æ–ø–∫–æ–π "‚ùå –û—Ç–º–µ–Ω–∞"."""
    return ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞")]], resize_keyboard=True)

def main_menu_keyboard(is_admin: bool = False):
    """–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
    builder = ReplyKeyboardBuilder()
    builder.row(
        KeyboardButton(text="üë§ –ü—Ä–æ—Ñ–∏–ª—å"),
        KeyboardButton(text="üéÅ –ë–æ–Ω—É—Å")
    )
    builder.row(
        KeyboardButton(text="üõí –ú–∞–≥–∞–∑–∏–Ω –ø–æ–¥–∞—Ä–∫–æ–≤"),
        KeyboardButton(text="üé∞ –ö–∞–∑–∏–Ω–æ")
    )
    builder.row(
        KeyboardButton(text="üéü –ü—Ä–æ–º–æ–∫–æ–¥"),
        KeyboardButton(text="üèÜ –¢–æ–ø –∏–≥—Ä–æ–∫–æ–≤")
    )
    builder.row(
        KeyboardButton(text="üí∞ –ú–æ–∏ –ø–æ–∫—É–ø–∫–∏"),
        KeyboardButton(text="üî´ –û–≥—Ä–∞–±–∏—Ç—å")
    )
    builder.row(
        KeyboardButton(text="üìã –ó–∞–¥–∞–Ω–∏—è"),
        KeyboardButton(text="üîó –†–µ—Ñ–µ—Ä–∞–ª–∫–∞")
    )
    builder.row(
        KeyboardButton(text="üéÅ –†–æ–∑—ã–≥—Ä—ã—à–∏"),
        KeyboardButton(text="üìä –£—Ä–æ–≤–µ–Ω—å")
    )
    builder.row(
        KeyboardButton(text="üè™ –ú–æ–∏ –±–∏–∑–Ω–µ—Å—ã"),
        KeyboardButton(text="üíº –ë–∏—Ç–∫–æ–∏–Ω-–±–∏—Ä–∂–∞")
    )
    builder.row(
        KeyboardButton(text="üéì –£–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç")
    )
    if is_admin:
        builder.row(KeyboardButton(text="‚öôÔ∏è –ê–¥–º–∏–Ω –ø–∞–Ω–µ–ª—å"))
    return builder.as_markup(resize_keyboard=True)

def casino_menu_keyboard():
    """–ú–µ–Ω—é –∫–∞–∑–∏–Ω–æ."""
    builder = ReplyKeyboardBuilder()
    builder.row(
        KeyboardButton(text="üé≤ –ö–æ—Å—Ç–∏"),
        KeyboardButton(text="üî¢ –£–≥–∞–¥–∞–π —á–∏—Å–ª–æ")
    )
    builder.row(
        KeyboardButton(text="üçí –°–ª–æ—Ç—ã"),
        KeyboardButton(text="üé° –†—É–ª–µ—Ç–∫–∞")
    )
    builder.row(KeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥"))
    return builder.as_markup(resize_keyboard=True)

def guess_number_keyboard():
    """–ò–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ —á–∏—Å–ª–∞ –æ—Ç 1 –¥–æ 5."""
    kb = []
    row = []
    for i in range(1, 6):
        row.append(InlineKeyboardButton(str(i), callback_data=f"guess_num_{i}"))
        if i % 3 == 0:
            kb.append(row)
            row = []
    if row:
        kb.append(row)
    kb.append([InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="guess_cancel")])
    return InlineKeyboardMarkup(inline_keyboard=kb)

def roulette_type_keyboard():
    """–ò–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ç–∏–ø–∞ —Å—Ç–∞–≤–∫–∏ –≤ —Ä—É–ª–µ—Ç–∫–µ."""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton("üî¥ –ö—Ä–∞—Å–Ω–æ–µ", callback_data="roulette_type_red"),
         InlineKeyboardButton("‚ö´Ô∏è –ß—ë—Ä–Ω–æ–µ", callback_data="roulette_type_black")],
        [InlineKeyboardButton("üü¢ –ó–µ–ª—ë–Ω–æ–µ", callback_data="roulette_type_green"),
         InlineKeyboardButton("üî¢ –ß–∏—Å–ª–æ", callback_data="roulette_type_number")],
        [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="roulette_cancel")]
    ])

def roulette_number_keyboard():
    """–ò–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ —á–∏—Å–ª–∞ –æ—Ç 0 –¥–æ 36."""
    kb = []
    row = []
    for i in range(0, 37):
        row.append(InlineKeyboardButton(str(i), callback_data=f"roulette_num_{i}"))
        if len(row) == 5:
            kb.append(row)
            row = []
    if row:
        kb.append(row)
    kb.append([InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="roulette_cancel")])
    return InlineKeyboardMarkup(inline_keyboard=kb)

def repeat_bet_keyboard(game: str):
    """–ò–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è —Å—Ç–∞–≤–∫–∏."""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîÅ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å", callback_data=f"repeat_{game}")]
    ])

def theft_choice_keyboard():
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –≤—ã–±–æ—Ä–∞ —Ü–µ–ª–∏ –¥–ª—è –æ–≥—Ä–∞–±–ª–µ–Ω–∏—è."""
    return ReplyKeyboardMarkup(keyboard=[
        [KeyboardButton(text="üé≤ –°–ª—É—á–∞–π–Ω–∞—è —Ü–µ–ª—å")],
        [KeyboardButton(text="üë§ –í—ã–±—Ä–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")],
        [KeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥")]
    ], resize_keyboard=True)

def bitcoin_exchange_keyboard():
    """–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –±–∏—Ç–∫–æ–∏–Ω-–±–∏—Ä–∂–∏."""
    return ReplyKeyboardMarkup(keyboard=[
        [KeyboardButton(text="üìà –ö—É–ø–∏—Ç—å BTC"), KeyboardButton(text="üìâ –ü—Ä–æ–¥–∞—Ç—å BTC")],
        [KeyboardButton(text="üìã –ú–æ–∏ –∑–∞—è–≤–∫–∏"), KeyboardButton(text="üìä –°—Ç–∞–∫–∞–Ω –∑–∞—è–≤–æ–∫")],
        [KeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥")]
    ], resize_keyboard=True)

def order_book_keyboard(book: Dict[str, List[Dict]]):
    """–ò–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è —Å—Ç–∞–∫–∞–Ω–∞ –∑–∞—è–≤–æ–∫."""
    kb = []
    if book['asks']:
        kb.append([InlineKeyboardButton(text="üìâ –ü—Ä–æ–¥–∞–∂–∞ (ASK) - –ª—É—á—à–∏–µ —Ü–µ–Ω—ã", callback_data="noop")])
        for ask in book['asks'][:5]:
            kb.append([InlineKeyboardButton(
                text=f"üí∞ {ask['price']} $ | {ask['total_amount']:.4f} BTC ({ask['count']} –∑–∞—è–≤–æ–∫)",
                callback_data=f"buy_from_{ask['price']}"
            )])
    else:
        kb.append([InlineKeyboardButton(text="–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø—Ä–æ–¥–∞–∂", callback_data="noop")])
    
    if book['bids']:
        kb.append([InlineKeyboardButton(text="üìà –ü–æ–∫—É–ø–∫–∞ (BID) - –ª—É—á—à–∏–µ —Ü–µ–Ω—ã", callback_data="noop")])
        for bid in book['bids'][:5]:
            kb.append([InlineKeyboardButton(
                text=f"üí∞ {bid['price']} $ | {bid['total_amount']:.4f} BTC ({bid['count']} –∑–∞—è–≤–æ–∫)",
                callback_data=f"sell_to_{bid['price']}"
            )])
    else:
        kb.append([InlineKeyboardButton(text="–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–∫—É–ø–æ–∫", callback_data="noop")])
    
    kb.append([InlineKeyboardButton(text="¬´ –ù–∞–∑–∞–¥", callback_data="exchange_back")])
    return InlineKeyboardMarkup(inline_keyboard=kb)

def bitcoin_orders_keyboard(orders: List[dict], order_type: str, page: int = 1, total_pages: int = 1):
    """–ò–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è —Å–ø–∏—Å–∫–∞ –∑–∞—è–≤–æ–∫ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ (–ø–æ–∫—É–ø–∫–∞/–ø—Ä–æ–¥–∞–∂–∞)."""
    kb = []
    for order in orders:
        kb.append([InlineKeyboardButton(
            text=f"{order['amount']:.4f} BTC @ {order['price']} $ (ID: {order['id']})",
            callback_data=f"{order_type}_order_{order['id']}"
        )])
    nav = []
    if page > 1:
        nav.append(InlineKeyboardButton("‚¨ÖÔ∏è", callback_data=f"{order_type}_page_{page-1}"))
    if page < total_pages:
        nav.append(InlineKeyboardButton("‚û°Ô∏è", callback_data=f"{order_type}_page_{page+1}"))
    if nav:
        kb.append(nav)
    kb.append([InlineKeyboardButton("¬´ –ù–∞–∑–∞–¥", callback_data="exchange_back")])
    return InlineKeyboardMarkup(inline_keyboard=kb)

def my_orders_keyboard(orders: List[dict], page: int = 1, total_pages: int = 1):
    """–ò–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è —Å–ø–∏—Å–∫–∞ –º–æ–∏—Ö –∑–∞—è–≤–æ–∫."""
    kb = []
    for order in orders:
        order_type_emoji = "üìà" if order['type'] == 'buy' else "üìâ"
        kb.append([InlineKeyboardButton(
            text=f"{order_type_emoji} {order['amount']:.4f} BTC @ {order['price']} $",
            callback_data=f"myorder_{order['id']}"
        )])
    nav = []
    if page > 1:
        nav.append(InlineKeyboardButton("‚¨ÖÔ∏è", callback_data=f"myorders_page_{page-1}"))
    if page < total_pages:
        nav.append(InlineKeyboardButton("‚û°Ô∏è", callback_data=f"myorders_page_{page+1}"))
    if nav:
        kb.append(nav)
    kb.append([InlineKeyboardButton("¬´ –ù–∞–∑–∞–¥", callback_data="exchange_back")])
    return InlineKeyboardMarkup(inline_keyboard=kb)

def business_main_keyboard(businesses: List[dict]):
    """–ò–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è —Å–ø–∏—Å–∫–∞ –±–∏–∑–Ω–µ—Å–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
    kb = []
    for biz in businesses:
        kb.append([InlineKeyboardButton(
            text=f"{biz['emoji']} {biz['name']} (—É—Ä. {biz['level']})",
            callback_data=f"biz_view_{biz['id']}"
        )])
    kb.append([InlineKeyboardButton(text="üõí –ö—É–ø–∏—Ç—å –Ω–æ–≤—ã–π –±–∏–∑–Ω–µ—Å", callback_data="buy_business_menu")])
    kb.append([InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="biz_back_to_main")])
    return InlineKeyboardMarkup(inline_keyboard=kb)

def business_actions_keyboard(business_id: int):
    """–ò–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–∏–∑–Ω–µ—Å–æ–º."""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üí∞ –°–æ–±—Ä–∞—Ç—å –¥–æ—Ö–æ–¥", callback_data=f"biz_collect_{business_id}")],
        [InlineKeyboardButton(text="‚¨ÜÔ∏è –£–ª—É—á—à–∏—Ç—å", callback_data=f"biz_upgrade_{business_id}")],
        [InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="biz_back")]
    ])

def business_buy_keyboard(business_types: List[dict]):
    """–ò–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ –±–∏–∑–Ω–µ—Å–∞ –∫ –ø–æ–∫—É–ø–∫–µ."""
    kb = []
    for bt in business_types:
        kb.append([InlineKeyboardButton(
            text=f"{bt['emoji']} {bt['name']} ‚Äì {bt['base_price_btc']} BTC (üí∞ {bt['base_income_per_hour']} $/—á–∞—Å)",
            callback_data=f"bizbuy_preview_{bt['id']}"
        )])
    kb.append([InlineKeyboardButton(text="‚óÄÔ∏è –û—Ç–º–µ–Ω–∞", callback_data="bizbuy_cancel")])
    return InlineKeyboardMarkup(inline_keyboard=kb)

def giveaways_user_keyboard():
    """–ú–µ–Ω—é —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
    return ReplyKeyboardMarkup(keyboard=[
        [KeyboardButton(text="üìã –ê–∫—Ç–∏–≤–Ω—ã–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∏")],
        [KeyboardButton(text="üèÅ –ó–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∏")],
        [KeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥")]
    ], resize_keyboard=True)

def active_giveaways_keyboard(giveaways: List[dict], page: int, total_pages: int):
    """–ò–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è —Å–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π."""
    kb = []
    for gw in giveaways:
        kb.append([InlineKeyboardButton(
            text=f"#{gw['id']} | {gw['prize']} | –¥–æ {gw['end_date']}",
            callback_data=f"active_gw_{gw['id']}"
        )])
    nav = []
    if page > 1:
        nav.append(InlineKeyboardButton("‚¨ÖÔ∏è", callback_data=f"active_gw_page_{page-1}"))
    if page < total_pages:
        nav.append(InlineKeyboardButton("‚û°Ô∏è", callback_data=f"active_gw_page_{page+1}"))
    if nav:
        kb.append(nav)
    kb.append([InlineKeyboardButton("¬´ –ù–∞–∑–∞–¥", callback_data="active_gw_back")])
    return InlineKeyboardMarkup(inline_keyboard=kb)

def completed_giveaways_keyboard(giveaways: List[dict], page: int, total_pages: int):
    """–ò–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è —Å–ø–∏—Å–∫–∞ –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π."""
    kb = []
    for gw in giveaways:
        display = f"#{gw['id']} | {gw['prize']} | {gw['winners_list'][:20]}" if gw['winners_list'] else f"#{gw['id']} | {gw['prize']}"
        kb.append([InlineKeyboardButton(text=display, callback_data=f"completed_gw_{gw['id']}")])
    nav = []
    if page > 1:
        nav.append(InlineKeyboardButton("‚¨ÖÔ∏è", callback_data=f"completed_gw_page_{page-1}"))
    if page < total_pages:
        nav.append(InlineKeyboardButton("‚û°Ô∏è", callback_data=f"completed_gw_page_{page+1}"))
    if nav:
        kb.append(nav)
    kb.append([InlineKeyboardButton("¬´ –ù–∞–∑–∞–¥", callback_data="completed_gw_back")])
    return InlineKeyboardMarkup(inline_keyboard=kb)

def giveaway_detail_keyboard(giveaway_id: int, is_participant: bool, participants_count: int = None):
    """–ò–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –¥–µ—Ç–∞–ª–µ–π —Ä–æ–∑—ã–≥—Ä—ã—à–∞."""
    kb = []
    if participants_count is not None:
        kb.append([InlineKeyboardButton(text=f"üë• –£—á–∞—Å—Ç–Ω–∏–∫–æ–≤: {participants_count}", callback_data="noop")])
    if not is_participant:
        kb.append([InlineKeyboardButton("‚úÖ –£—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å", callback_data=f"join_giveaway_{giveaway_id}")])
    else:
        kb.append([InlineKeyboardButton("‚ùå –û—Ç–∫–∞–∑–∞—Ç—å—Å—è", callback_data=f"leave_giveaway_{giveaway_id}")])
    kb.append([InlineKeyboardButton("¬´ –ù–∞–∑–∞–¥", callback_data="active_gw_back")])
    return InlineKeyboardMarkup(inline_keyboard=kb)

def confirm_chat_inline(chat_id: int):
    """–ò–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —á–∞—Ç–∞ –∞–¥–º–∏–Ω–æ–º."""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", callback_data=f"confirm_chat_{chat_id}"),
         InlineKeyboardButton(text="‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å", callback_data=f"reject_chat_{chat_id}")]
    ])

def subscription_inline(not_subscribed: List[Tuple[str, str]]):
    """–ò–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∫–∏."""
    kb = []
    for title, link in not_subscribed:
        if link:
            kb.append([InlineKeyboardButton(text=f"üì¢ {title}", url=link)])
        else:
            kb.append([InlineKeyboardButton(text=f"üì¢ {title}", callback_data="no_link")])
    kb.append([InlineKeyboardButton(text="‚úÖ –Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è", callback_data="check_sub")])
    return InlineKeyboardMarkup(inline_keyboard=kb)

# ==================== –ù–û–í–´–ï –ö–õ–ê–í–ò–ê–¢–£–†–´ –î–õ–Ø –ù–ê–õ–Å–¢–û–í ====================

def betray_choice_keyboard(heist_id: int):
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ –≤ –õ–°: —É–∫—Ä–∞—Å—Ç—å –∏–ª–∏ –æ—Ç–∫–∞–∑–∞—Ç—å—Å—è."""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üî™ –£–∫—Ä–∞—Å—Ç—å —É –ø–æ–¥–µ–ª—å–Ω–∏–∫–æ–≤", callback_data=f"betray_choice_yes_{heist_id}")],
        [InlineKeyboardButton(text="‚ùå –û—Ç–∫–∞–∑–∞—Ç—å—Å—è", callback_data=f"betray_choice_no_{heist_id}")]
    ])

def heist_betray_inline_keyboard(heist_id: int):
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –ø–æ–ø—ã—Ç–∫–∏ –∫–∏–¥–∞–ª–æ–≤–∞ –≤–æ –≤—Ä–µ–º—è —Ä–∞—Å–ø–∏–ª–∞ (—Å—Ç–∞—Ä–∞—è)."""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üî™ –ü–æ–ø—ã—Ç–∞—Ç—å—Å—è –∫–∏–Ω—É—Ç—å —Å–æ—É—á–∞—Å—Ç–Ω–∏–∫–∞", callback_data=f"betray_attempt_{heist_id}")],
        [InlineKeyboardButton(text="‚ùå –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="betray_skip")]
    ])

def betray_confirm_keyboard():
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∫–∏–¥–∞–ª–æ–≤–∞."""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úÖ –î–∞, —Ö–æ—á—É —Ä–∏—Å–∫–Ω—É—Ç—å", callback_data="betray_confirm_yes")],
        [InlineKeyboardButton(text="‚ùå –ù–µ—Ç, –ø–µ—Ä–µ–¥—É–º–∞–ª", callback_data="betray_confirm_no")]
    ])

# ==================== –ù–û–í–´–ï –ö–õ–ê–í–ò–ê–¢–£–†–´ –î–õ–Ø –¢–Æ–†–¨–ú–´ ====================

def jail_cell_keyboard():
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ –Ω–æ–º–µ—Ä–∞ –∫–∞–º–µ—Ä—ã (1-15)."""
    kb = []
    row = []
    for i in range(1, 16):
        row.append(InlineKeyboardButton(str(i), callback_data=f"jail_cell_{i}"))
        if i % 5 == 0:
            kb.append(row)
            row = []
    if row:
        kb.append(row)
    return InlineKeyboardMarkup(inline_keyboard=kb)

# ==================== –ù–û–í–´–ï –ö–õ–ê–í–ò–ê–¢–£–†–´ –î–õ–Ø –ó–ê–î–ê–ù–ò–ô ====================

def task_detail_keyboard(task_id: int, button_link: str = None):
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –∫–∞—Ä—Ç–æ—á–∫–∏ –∑–∞–¥–∞–Ω–∏—è."""
    kb = []
    if button_link:
        kb.append([InlineKeyboardButton(text="üì¢ –ü–µ—Ä–µ–π—Ç–∏ –≤ –∫–∞–Ω–∞–ª", url=button_link)])
    kb.append([InlineKeyboardButton(text="‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data=f"check_task_{task_id}")])
    kb.append([InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="tasks_back")])
    return InlineKeyboardMarkup(inline_keyboard=kb)

# ==================== –ù–û–í–´–ï –ö–õ–ê–í–ò–ê–¢–£–†–´ –î–õ–Ø –†–û–ó–´–ì–†–´–®–ï–ô (–ê–î–ú–ò–ù–ö–ê) ====================

def giveaway_condition_keyboard():
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ç–∏–ø–∞ —É—Å–ª–æ–≤–∏—è –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Ä–æ–∑—ã–≥—Ä—ã—à–∞."""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚è∞ –ü–æ –≤—Ä–µ–º–µ–Ω–∏", callback_data="giveaway_cond_time")],
        [InlineKeyboardButton(text="üë• –ü–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤", callback_data="giveaway_cond_participants")]
    ])

# ==================== –ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–ò–í–ù–´–ï –ö–õ–ê–í–ò–ê–¢–£–†–´ ====================

def admin_main_keyboard(permissions: List[str]):
    """–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏."""
    builder = ReplyKeyboardBuilder()
    row1 = []
    if "manage_users" in permissions:
        row1.append(KeyboardButton("üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏"))
    if "manage_shop" in permissions:
        row1.append(KeyboardButton("üõí –ú–∞–≥–∞–∑–∏–Ω"))
    if "manage_giveaways" in permissions:
        row1.append(KeyboardButton("üéÅ –†–æ–∑—ã–≥—Ä—ã—à–∏"))
    if row1:
        builder.row(*row1)
    row2 = []
    if "manage_channels" in permissions:
        row2.append(KeyboardButton("üì¢ –ö–∞–Ω–∞–ª—ã"))
    if "manage_chats" in permissions:
        row2.append(KeyboardButton("ü§ñ –ß–∞—Ç—ã"))
    if "manage_promocodes" in permissions:
        row2.append(KeyboardButton("üé´ –ü—Ä–æ–º–æ–∫–æ–¥—ã"))
    if row2:
        builder.row(*row2)
    row3 = []
    if "manage_businesses" in permissions:
        row3.append(KeyboardButton("üè™ –ë–∏–∑–Ω–µ—Å—ã"))
    if "manage_exchange" in permissions:
        row3.append(KeyboardButton("üíº –ë–∏—Ä–∂–∞"))
    if "manage_media" in permissions:
        row3.append(KeyboardButton("üñº –ú–µ–¥–∏–∞"))
    if row3:
        builder.row(*row3)
    row4 = []
    if "view_stats" in permissions:
        row4.append(KeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"))
    if "broadcast" in permissions:
        row4.append(KeyboardButton("üì¢ –†–∞—Å—Å—ã–ª–∫–∞"))
    if "edit_settings" in permissions:
        row4.append(KeyboardButton("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏"))
    if "cleanup" in permissions:
        row4.append(KeyboardButton("üßπ –û—á–∏—Å—Ç–∫–∞"))
    if "manage_admins" in permissions:
        row4.append(KeyboardButton("üëë –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã"))
    if row4:
        builder.row(*row4)
    builder.row(KeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"))
    return builder.as_markup(resize_keyboard=True)

def admin_users_keyboard():
    """–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏."""
    return ReplyKeyboardMarkup(keyboard=[
        [KeyboardButton("üí∞ –ù–∞—á–∏—Å–ª–∏—Ç—å –±–∞–∫—Å—ã"), KeyboardButton("üí∏ –°–ø–∏—Å–∞—Ç—å –±–∞–∫—Å—ã")],
        [KeyboardButton("‚≠êÔ∏è –ù–∞—á–∏—Å–ª–∏—Ç—å —Ä–µ–ø—É—Ç–∞—Ü–∏—é"), KeyboardButton("üîª –°–Ω—è—Ç—å —Ä–µ–ø—É—Ç–∞—Ü–∏—é")],
        [KeyboardButton("üìà –ù–∞—á–∏—Å–ª–∏—Ç—å –æ–ø—ã—Ç"), KeyboardButton("üîù –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å")],
        [KeyboardButton("‚Çø –ù–∞—á–∏—Å–ª–∏—Ç—å –±–∏—Ç–∫–æ–∏–Ω—ã"), KeyboardButton("‚Çø –°–ø–∏—Å–∞—Ç—å –±–∏—Ç–∫–æ–∏–Ω—ã")],
        [KeyboardButton("‚öîÔ∏è –ù–∞—á–∏—Å–ª–∏—Ç—å –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç"), KeyboardButton("‚öîÔ∏è –°–ø–∏—Å–∞—Ç—å –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç")],
        [KeyboardButton("üë• –ù–∞–π—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"), KeyboardButton("üìä –≠–∫—Å–ø–æ—Ä—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π")],
        [KeyboardButton("üîÑ –°–±—Ä–æ—Å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏")],
        [KeyboardButton("‚õî –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å"), KeyboardButton("‚úÖ –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å")],
        [KeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω–∫—É")]
    ], resize_keyboard=True)

def admin_shop_keyboard():
    """–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º–∞–≥–∞–∑–∏–Ω–æ–º."""
    return ReplyKeyboardMarkup(keyboard=[
        [KeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å —Ç–æ–≤–∞—Ä")],
        [KeyboardButton("‚ûñ –£–¥–∞–ª–∏—Ç—å —Ç–æ–≤–∞—Ä")],
        [KeyboardButton("‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–æ–≤–∞—Ä")],
        [KeyboardButton("üìã –°–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤")],
        [KeyboardButton("üõçÔ∏è –°–ø–∏—Å–æ–∫ –ø–æ–∫—É–ø–æ–∫")],
        [KeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω–∫—É")]
    ], resize_keyboard=True)

def admin_giveaway_keyboard():
    """–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–æ–∑—ã–≥—Ä—ã—à–∞–º–∏."""
    return ReplyKeyboardMarkup(keyboard=[
        [KeyboardButton("‚ûï –°–æ–∑–¥–∞—Ç—å —Ä–æ–∑—ã–≥—Ä—ã—à")],
        [KeyboardButton("üìã –ê–∫—Ç–∏–≤–Ω—ã–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∏ (–∞–¥–º–∏–Ω)")],
        [KeyboardButton("‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å —Ä–æ–∑—ã–≥—Ä—ã—à")],
        [KeyboardButton("üìã –ó–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∏ (–∞–¥–º–∏–Ω)")],
        [KeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω–∫—É")]
    ], resize_keyboard=True)

def admin_channel_keyboard():
    """–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–∞–Ω–∞–ª–∞–º–∏."""
    return ReplyKeyboardMarkup(keyboard=[
        [KeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–∞–Ω–∞–ª")],
        [KeyboardButton("‚ûñ –£–¥–∞–ª–∏—Ç—å –∫–∞–Ω–∞–ª")],
        [KeyboardButton("üìã –°–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤")],
        [KeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω–∫—É")]
    ], resize_keyboard=True)

def admin_promo_keyboard():
    """–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø—Ä–æ–º–æ–∫–æ–¥–∞–º–∏."""
    return ReplyKeyboardMarkup(keyboard=[
        [KeyboardButton("‚ûï –°–æ–∑–¥–∞—Ç—å –ø—Ä–æ–º–æ–∫–æ–¥")],
        [KeyboardButton("üìã –°–ø–∏—Å–æ–∫ –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤")],
        [KeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω–∫—É")]
    ], resize_keyboard=True)

def admin_business_keyboard():
    """–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–∏–∑–Ω–µ—Å–∞–º–∏."""
    return ReplyKeyboardMarkup(keyboard=[
        [KeyboardButton("üìã –°–ø–∏—Å–æ–∫ –±–∏–∑–Ω–µ—Å–æ–≤")],
        [KeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –±–∏–∑–Ω–µ—Å")],
        [KeyboardButton("‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –±–∏–∑–Ω–µ—Å")],
        [KeyboardButton("üîÑ –ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å")],
        [KeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω–∫—É")]
    ], resize_keyboard=True)

def admin_exchange_keyboard():
    """–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–∏—Ä–∂–µ–π."""
    return ReplyKeyboardMarkup(keyboard=[
        [KeyboardButton("üìã –ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞—è–≤–∫–∏")],
        [KeyboardButton("‚ùå –£–¥–∞–ª–∏—Ç—å –∑–∞—è–≤–∫—É (–ø–æ ID)")],
        [KeyboardButton("üìä –ò—Å—Ç–æ—Ä–∏—è —Å–¥–µ–ª–æ–∫")],
        [KeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω–∫—É")]
    ], resize_keyboard=True)

def admin_media_keyboard():
    """–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º–µ–¥–∏–∞."""
    return ReplyKeyboardMarkup(keyboard=[
        [KeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –º–µ–¥–∏–∞")],
        [KeyboardButton("‚ûñ –£–¥–∞–ª–∏—Ç—å –º–µ–¥–∏–∞")],
        [KeyboardButton("üìã –°–ø–∏—Å–æ–∫ –º–µ–¥–∏–∞")],
        [KeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω–∫—É")]
    ], resize_keyboard=True)

def admin_chats_keyboard():
    """–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —á–∞—Ç–∞–º–∏."""
    return ReplyKeyboardMarkup(keyboard=[
        [KeyboardButton("üìã –°–ø–∏—Å–æ–∫ –∑–∞–ø—Ä–æ—Å–æ–≤ –Ω–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ")],
        [KeyboardButton("‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å —á–∞—Ç")],
        [KeyboardButton("‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å –∑–∞–ø—Ä–æ—Å")],
        [KeyboardButton("üóë –£–¥–∞–ª–∏—Ç—å —á–∞—Ç –∏–∑ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã—Ö")],
        [KeyboardButton("üìã –°–ø–∏—Å–æ–∫ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã—Ö —á–∞—Ç–æ–≤")],
        [KeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω–∫—É")]
    ], resize_keyboard=True)

def admin_tasks_keyboard():
    """–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞–Ω–∏—è–º–∏."""
    return ReplyKeyboardMarkup(keyboard=[
        [KeyboardButton("‚ûï –°–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞–Ω–∏–µ")],
        [KeyboardButton("üìã –°–ø–∏—Å–æ–∫ –∑–∞–¥–∞–Ω–∏–π")],
        [KeyboardButton("‚ùå –£–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞–Ω–∏–µ")],
        [KeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω–∫—É")]
    ], resize_keyboard=True)

def admin_admins_keyboard():
    """–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º–∏."""
    return ReplyKeyboardMarkup(keyboard=[
        [KeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞")],
        [KeyboardButton("‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∞–≤–∞")],
        [KeyboardButton("‚ûñ –£–¥–∞–ª–∏—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞")],
        [KeyboardButton("üìã –°–ø–∏—Å–æ–∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤")],
        [KeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω–∫—É")]
    ], resize_keyboard=True)

def settings_categories_keyboard():
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –≤—ã–±–æ—Ä–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫."""
    return ReplyKeyboardMarkup(keyboard=[
        [KeyboardButton("‚öôÔ∏è –ö–∞–∑–∏–Ω–æ")],
        [KeyboardButton("‚öôÔ∏è –ö—Ä–∞–∂–∞")],
        [KeyboardButton("‚öôÔ∏è –ö–∏–¥–∞–ª–æ–≤–æ (PVP)")],
        [KeyboardButton("‚öôÔ∏è –ù–∞–ª—ë—Ç—ã")],
        [KeyboardButton("‚öôÔ∏è –ë–∏–∑–Ω–µ—Å—ã")],
        [KeyboardButton("‚öôÔ∏è –û–ø—ã—Ç –∏ —É—Ä–æ–≤–Ω–∏")],
        [KeyboardButton("‚öôÔ∏è –†–µ—Ñ–µ—Ä–∞–ª—ã")],
        [KeyboardButton("‚öôÔ∏è –ü–æ–¥–≥–æ–Ω")],
        [KeyboardButton("‚öôÔ∏è –ë–∏—Ç–∫–æ–∏–Ω-–±–∏—Ä–∂–∞")],
        [KeyboardButton("‚öôÔ∏è –ê–≤—Ç–æ—É–¥–∞–ª–µ–Ω–∏–µ")],
        [KeyboardButton("‚öôÔ∏è –ü—Ä–æ–∫–∞—á–∫–∞ –Ω–∞–≤—ã–∫–æ–≤")],
        [KeyboardButton("‚öôÔ∏è –ö–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥–∞")],
        [KeyboardButton("‚öôÔ∏è –¢—é—Ä—å–º–∞")],
        [KeyboardButton("‚öôÔ∏è –ó–∞–¥–∞–Ω–∏—è")],
        [KeyboardButton("‚öôÔ∏è –ü—Ä–æ–º–æ–∫–æ–¥—ã")],
        [KeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω–∫—É")]
    ], resize_keyboard=True)

def settings_param_keyboard(params: List[Tuple[str, str]], category: str):
    """–ò–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è —Å–ø–∏—Å–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏."""
    kb = []
    for key, desc in params:
        kb.append([InlineKeyboardButton(text=desc, callback_data=f"edit_{key}")])
    kb.append([InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data=f"settings_back_{category}")])
    return InlineKeyboardMarkup(inline_keyboard=kb)

def purchase_action_keyboard(purchase_id: int):
    """–ò–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –¥–µ–π—Å—Ç–≤–∏–π —Å –ø–æ–∫—É–ø–∫–æ–π."""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ", callback_data=f"purchase_done_{purchase_id}"),
         InlineKeyboardButton(text="‚ùå –û—Ç–∫–∞–∑", callback_data=f"purchase_reject_{purchase_id}")]
    ])

def cancel_inline():
    """–ü—Ä–æ—Å—Ç–∞—è –∏–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ —Å –∫–Ω–æ–ø–∫–æ–π –æ—Ç–º–µ–Ω—ã."""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_action")]
    ])

def promo_type_keyboard():
    """–ò–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ç–∏–ø–∞ –Ω–∞–≥—Ä–∞–¥—ã –ø—Ä–æ–º–æ–∫–æ–¥–∞."""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üí∞ –ë–∞–∫—Å—ã", callback_data="promo_type_coins"),
         InlineKeyboardButton(text="‚Çø –ë–∏—Ç–∫–æ–∏–Ω—ã", callback_data="promo_type_bitcoin")]
    ])

def reset_stats_confirm_keyboard(user_id: int):
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Å–±—Ä–æ—Å–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∞–¥–º–∏–Ω–æ–º (—Å –≥–µ–Ω–µ—Ä–∞—Ü–∏–µ–π –∫–ª—é—á–∞)."""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å —Å–±—Ä–æ—Å", callback_data=f"reset_stats_confirm_{user_id}")],
        [InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="reset_stats_cancel")]
    ])

# ==================== –ù–ê–í–ò–ì–ê–¶–ò–Ø –ö–û–ú–ê–ù–î –í –ß–ê–¢–ê–• (—Ç–µ–∫—Å—Ç–æ–≤–∞—è —Å–ø—Ä–∞–≤–∫–∞) ====================

def chat_help_text() -> str:
    return (
        "üìö <b>–ö–æ–º–∞–Ω–¥—ã –≤ —á–∞—Ç–µ:</b>\n\n"
        "‚Ä¢ /mlb_profile ‚Äì —Ç–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å\n"
        "‚Ä¢ /mlb_heist ‚Äì —Å—Ç–∞—Ç—É—Å —Ç–µ–∫—É—â–µ–≥–æ –Ω–∞–ª—ë—Ç–∞\n"
        "‚Ä¢ /mlb_smuggle ‚Äì –æ—Ç–ø—Ä–∞–≤–∏—Ç—å—Å—è –≤ –∫–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥—É\n"
        "‚Ä¢ /mlb_jail ‚Äì —Å–µ—Å—Ç—å –≤ —Ç—é—Ä—å–º—É\n"
        "‚Ä¢ /mlb_top ‚Äì —Ç–æ–ø —á–∞—Ç–∞\n"
        "‚Ä¢ /betray ‚Äì –∫–∏–Ω—É—Ç—å –ø–æ–¥–µ–ª—å–Ω–∏–∫–∞ (–≤–æ –≤—Ä–µ–º—è —Ä–∞—Å–ø–∏–ª–∞)\n"
        "‚Ä¢ /myheist ‚Äì –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç–≤–æ—ë–º —É—á–∞—Å—Ç–∏–∏ –≤ –Ω–∞–ª—ë—Ç–µ\n"
        "‚Ä¢ <b>üéÅ –ü–æ–¥–≥–æ–Ω</b> ‚Äì –∫–Ω–æ–ø–∫–∞ –≤ –º–µ–Ω—é (–µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ)\n\n"
        "‚è≥ <i>–ì–ª–æ–±–∞–ª—å–Ω—ã–π –∫—É–ª–¥–∞—É–Ω –º–µ–∂–¥—É –¥–µ–π—Å—Ç–≤–∏—è–º–∏ ‚Äì 1 —á–∞—Å.</i>"
    )

# ==================== –ö–û–ù–ï–¶ –ß–ê–°–¢–ò 2 ====================
# ==================== –ß–ê–°–¢–¨ 3: –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–¨–°–ö–ò–ï –•–ï–ù–î–õ–ï–†–´ (–õ–ò–ß–ù–´–ï –°–û–û–ë–©–ï–ù–ò–Ø) ====================
# –ü–æ–ª–Ω–æ—Å—Ç—å—é –ø–µ—Ä–µ–ø–∏—Å–∞–Ω–æ –¥–ª—è aiogram 3.x. –í—Å–µ –æ—à–∏–±–∫–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã.
# - –ò—Å–ø—Ä–∞–≤–ª–µ–Ω –ø–∞—Ä—Å–∏–Ω–≥ callback_data –≤ buyproduct_
# - –î–æ–±–∞–≤–ª–µ–Ω—ã –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è BuyFromPrice, SellToPrice
# - –ò—Å–ø—Ä–∞–≤–ª–µ–Ω repeat_bet: —Ç–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
# - –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –ø–∞–≥–∏–Ω–∞—Ü–∏—è –≤ shop_page_
# - –£–ª—É—á—à–µ–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ FSM –∏ –æ—á–∏—Å—Ç–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏–π
# - –î–æ–±–∞–≤–ª–µ–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä allow_negative=False –≤–æ –≤—Å–µ –≤—ã–∑–æ–≤—ã update_user_balance
# - –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞—Ç (—Ç–µ–ø–µ—Ä—å –Ω–∞–ø—Ä—è–º—É—é datetime –∏–∑ –ë–î)
# - –í perform_theft –¥–æ–±–∞–≤–ª–µ–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ø–µ—à–Ω–æ—Å—Ç–∏ —Å–ø–∏—Å–∞–Ω–∏—è —Å—Ç–æ–∏–º–æ—Å—Ç–∏

import asyncio
import logging
import random
import json
from datetime import datetime, timedelta

from aiogram import F, types
from aiogram.filters import Command, CommandStart
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery, Message, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.exceptions import TelegramBadRequest

# –í—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ —á–∞—Å—Ç–µ–π 1-2 –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞—é—Ç—Å—è –¥–æ—Å—Ç—É–ø–Ω—ã–º–∏
# (bot, dp, db_pool, redis_client, –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã, —Å–æ—Å—Ç–æ—è–Ω–∏—è)

# ==================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ====================
async def get_level_reward_coins(level: int) -> float:
    async with db_pool.acquire() as conn:
        val = await conn.fetchval("SELECT coins FROM level_rewards WHERE level=$1", level)
        return float(val) if val else 0.0

async def get_level_reward_rep(level: int) -> int:
    async with db_pool.acquire() as conn:
        val = await conn.fetchval("SELECT reputation FROM level_rewards WHERE level=$1", level)
        return val if val else 0

# ==================== –ì–õ–û–ë–ê–õ–¨–ù–´–ô –û–ë–†–ê–ë–û–¢–ß–ò–ö /cancel ====================
@dp.message(Command("cancel"))
async def cmd_cancel(message: Message, state: FSMContext):
    if message.chat.type != 'private':
        return
    current_state = await state.get_state()
    if current_state is None:
        return
    await state.clear()
    user_id = message.from_user.id
    await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)
    await message.answer("‚ùå –î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=main_menu_keyboard(await is_admin(user_id)))

# ==================== –£–ù–ò–í–ï–†–°–ê–õ–¨–ù–´–ô –û–ë–†–ê–ë–û–¢–ß–ò–ö –ö–ù–û–ü–ö–ò "–ù–ê–ó–ê–î" ====================
@dp.message(F.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥")
async def universal_back_handler(message: Message, state: FSMContext):
    if message.chat.type != 'private':
        return
    current_state = await state.get_state()
    user_id = message.from_user.id
    is_admin_user = await is_admin(user_id)

    if current_state is None:
        await message.answer("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=main_menu_keyboard(is_admin_user))
        return

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≥—Ä—É–ø–ø—É —Å–æ—Å—Ç–æ—è–Ω–∏–π –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–µ –º–µ–Ω—é
    if current_state.startswith('DiceBet') or current_state.startswith('GuessBet') or \
       current_state.startswith('SlotsBet') or current_state.startswith('RouletteBet'):
        await state.clear()
        await casino_menu(message)

    elif current_state.startswith('AddBalance') or current_state.startswith('RemoveBalance') or \
         current_state.startswith('AddReputation') or current_state.startswith('RemoveReputation') or \
         current_state.startswith('AddExp') or current_state.startswith('SetLevel') or \
         current_state.startswith('AddBitcoin') or current_state.startswith('RemoveBitcoin') or \
         current_state.startswith('AddAuthority') or current_state.startswith('RemoveAuthority') or \
         current_state.startswith('FindUser') or current_state.startswith('AdminResetStats'):
        await state.clear()
        await admin_users_menu(message)

    elif current_state.startswith('AddShopItem') or current_state.startswith('RemoveShopItem') or \
         current_state.startswith('EditShopItem'):
        await state.clear()
        await admin_shop_menu(message)

    elif current_state.startswith('CreateGiveaway') or current_state.startswith('CompleteGiveaway'):
        await state.clear()
        await admin_giveaway_menu(message)

    elif current_state.startswith('AddChannel') or current_state.startswith('RemoveChannel'):
        await state.clear()
        await admin_channel_menu(message)

    elif current_state.startswith('CreatePromocode'):
        await state.clear()
        await admin_promo_menu(message)

    elif current_state.startswith('CreateTask') or current_state.startswith('DeleteTask'):
        await state.clear()
        await admin_tasks_menu(message)

    elif current_state.startswith('BlockUser') or current_state.startswith('UnblockUser'):
        await state.clear()
        await admin_ban_menu(message)

    elif current_state.startswith('AddJuniorAdmin') or current_state.startswith('RemoveJuniorAdmin') or \
         current_state.startswith('EditAdminPermissions'):
        await state.clear()
        await admin_admins_menu(message)

    elif current_state.startswith('SellBitcoin') or current_state.startswith('BuyBitcoin') or \
         current_state.startswith('CancelBitcoinOrder') or current_state.startswith('BuyFromPrice') or \
         current_state.startswith('SellToPrice'):
        await state.clear()
        await bitcoin_exchange_menu(message)

    elif current_state.startswith('BuyBusiness') or current_state.startswith('UpgradeBusiness'):
        await state.clear()
        await my_businesses(message)

    elif current_state.startswith('AddBusiness') or current_state.startswith('EditBusiness') or \
         current_state.startswith('ToggleBusiness'):
        await state.clear()
        await admin_business_menu(message)

    elif current_state.startswith('AddMedia') or current_state.startswith('RemoveMedia'):
        await state.clear()
        await admin_media_menu(message)

    elif current_state.startswith('TheftTarget'):
        await state.clear()
        await theft_menu(message)

    elif current_state.startswith('PromoActivate'):
        await state.clear()
        await promo_handler(message)

    elif current_state.startswith('UpgradeSkill'):
        await state.clear()
        await university_menu(message)

    elif current_state.startswith('JailProcess'):
        await state.clear()
        await message.answer("‚ùå –ü—Ä–æ—Ü–µ—Å—Å –æ—Ç–º–µ–Ω—ë–Ω.", reply_markup=main_menu_keyboard(is_admin_user))

    elif current_state.startswith('PurchaseReject'):
        await state.clear()
        await admin_shop_menu(message)

    else:
        await state.clear()
        await message.answer("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=main_menu_keyboard(is_admin_user))

# ==================== –°–¢–ê–†–¢ ====================
@dp.message(CommandStart())
async def cmd_start(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        await message.answer("‚õî –í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –≤ –±–æ—Ç–µ.")
        return

    args = message.text.split()
    if len(args) > 1:
        ref = args[1]
        if ref.startswith('ref') and len(ref) > 3:
            try:
                referrer_id = int(ref[3:])
                if referrer_id != user_id:
                    async with db_pool.acquire() as conn:
                        referrer_exists = await conn.fetchval("SELECT 1 FROM users WHERE user_id=$1", referrer_id)
                        if referrer_exists and not await is_banned(referrer_id):
                            existing = await conn.fetchval("SELECT 1 FROM referrals WHERE referred_id=$1", user_id)
                            if not existing:
                                await conn.execute(
                                    "INSERT INTO referrals (referrer_id, referred_id, referred_date, reward_given, clicks) VALUES ($1, $2, $3, $4, 1) ON CONFLICT (referred_id) DO NOTHING",
                                    referrer_id, user_id, datetime.now().strftime("%Y-%m-%d %H:%M:%S"), False
                                )
                                await conn.execute("UPDATE referrals SET clicks = clicks + 1 WHERE referred_id=$1", user_id)
                                await safe_send_message(referrer_id, f"üîó –ù–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {message.from_user.first_name} –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–ª—Å—è –ø–æ –≤–∞—à–µ–π —Å—Å—ã–ª–∫–µ! –ù–∞–≥—Ä–∞–¥–∞ –±—É–¥–µ—Ç –≤—ã–¥–∞–Ω–∞ –ø–æ—Å–ª–µ —Ç–æ–≥–æ, –∫–∞–∫ –æ–Ω —Å–æ–≤–µ—Ä—à–∏—Ç {await get_setting('referral_required_thefts')} —É—Å–ø–µ—à–Ω—ã—Ö –æ–≥—Ä–∞–±–ª–µ–Ω–∏–π.")
            except:
                pass

    created, bonus = await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)
    if created:
        await message.answer(f"üéÅ –í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω —Å—Ç–∞—Ä—Ç–æ–≤—ã–π –±–æ–Ω—É—Å: {bonus} –±–∞–∫—Å–æ–≤!")

    welcome_text = "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Malboro GAME! üö¨\n–¢—É—Ç —Ç—ã –Ω–∞–π–¥—ë—à—å: –∫–∞–∑–∏–Ω–æ, —Ä–æ–∑—ã–≥—Ä—ã—à–∏, –º–∞–≥–∞–∑–∏–Ω, –±–∏—Ç–∫–æ–∏–Ω-–±–∏—Ä–∂—É.\n–ê –µ—â—ë –º–æ–∂–µ—à—å –≥—Ä–∞–±–∏—Ç—å –¥—Ä—É–≥–∏—Ö –∏–ª–∏ —É—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å –≤ –Ω–∞–ª—ë—Ç–∞—Ö!\n–£ —Ç–µ–±—è 1 —É—Ä–æ–≤–µ–Ω—å. –ó–∞—Ä–∞–±–∞—Ç—ã–≤–∞–π –æ–ø—ã—Ç –∏ –ø–æ–≤—ã—à–∞–π —É—Ä–æ–≤–µ–Ω—å!\n\n–ö–∞–Ω–∞–ª: @lllMALBOROlll (–ø–æ–¥–ø–∏—à–∏—Å—å!)"
    await send_with_media(user_id, welcome_text, media_key='welcome')

    ok, not_subscribed = await check_subscription(user_id)
    if not ok:
        await message.answer(
            "‚ùóÔ∏è –î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±–æ—Ç–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –Ω–∞—à–∏ –∫–∞–Ω–∞–ª—ã:",
            reply_markup=subscription_inline(not_subscribed)
        )
        return

    is_admin_user = await is_admin(user_id)
    await message.answer(
        f"–ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}!\n"
        f"–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ <b>Malboro GAME</b>! üö¨\n"
        f"–¢—É—Ç —Ç—ã –Ω–∞–π–¥—ë—à—å: –∫–∞–∑–∏–Ω–æ, —Ä–æ–∑—ã–≥—Ä—ã—à–∏, –º–∞–≥–∞–∑–∏–Ω, –±–∏—Ç–∫–æ–∏–Ω-–±–∏—Ä–∂—É.\n"
        f"–ê –µ—â—ë –º–æ–∂–µ—à—å –≥—Ä–∞–±–∏—Ç—å –¥—Ä—É–≥–∏—Ö –∏–ª–∏ —É—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å –≤ –Ω–∞–ª—ë—Ç–∞—Ö!\n"
        f"–£ —Ç–µ–±—è 1 —É—Ä–æ–≤–µ–Ω—å. –ó–∞—Ä–∞–±–∞—Ç—ã–≤–∞–π –æ–ø—ã—Ç –∏ –ø–æ–≤—ã—à–∞–π —É—Ä–æ–≤–µ–Ω—å!\n\n"
        f"–ö–∞–Ω–∞–ª: @lllMALBOROlll (–ø–æ–¥–ø–∏—à–∏—Å—å!)",
        reply_markup=main_menu_keyboard(is_admin_user)
    )

@dp.message(Command("help"))
async def cmd_help_private(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        return
    await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)
    ok, not_subscribed = await check_subscription(user_id)
    if not ok:
        await message.answer("‚ùóÔ∏è –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã.", reply_markup=subscription_inline(not_subscribed))
        return
    text = (
        "üìö <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã –∏ —Ä–∞–∑–¥–µ–ª—ã</b>\n\n"
        "üë§ –ü—Ä–æ—Ñ–∏–ª—å ‚Äì —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏\n"
        "üéÅ –ë–æ–Ω—É—Å ‚Äì –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–π –±–æ–Ω—É—Å\n"
        "üõí –ú–∞–≥–∞–∑–∏–Ω –ø–æ–¥–∞—Ä–∫–æ–≤ ‚Äì –ø–æ–∫—É–ø–∫–∞ –ø–æ–¥–∞—Ä–∫–æ–≤\n"
        "üé∞ –ö–∞–∑–∏–Ω–æ ‚Äì –∞–∑–∞—Ä—Ç–Ω—ã–µ –∏–≥—Ä—ã (–∫–æ—Å—Ç–∏, —É–≥–∞–¥–∞–π–∫–∞, —Å–ª–æ—Ç—ã, —Ä—É–ª–µ—Ç–∫–∞)\n"
        "üéü –ü—Ä–æ–º–æ–∫–æ–¥ ‚Äì –∞–∫—Ç–∏–≤–∞—Ü–∏—è –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤\n"
        "üèÜ –¢–æ–ø –∏–≥—Ä–æ–∫–æ–≤ ‚Äì —Ä–µ–π—Ç–∏–Ω–≥ –ø–æ –±–∞–∫—Å–∞–º, —Ä–µ–ø—É—Ç–∞—Ü–∏–∏, –±–∏—Ç–∫–æ–∏–Ω–∞–º –∏ —Ç.–¥.\n"
        "üí∞ –ú–æ–∏ –ø–æ–∫—É–ø–∫–∏ ‚Äì –∏—Å—Ç–æ—Ä–∏—è –∑–∞–∫–∞–∑–æ–≤\n"
        "üî´ –û–≥—Ä–∞–±–∏—Ç—å ‚Äì —É–∫—Ä–∞–¥–∏ –±–∞–∫—Å—ã —É –¥—Ä—É–≥–æ–≥–æ\n"
        "üìã –ó–∞–¥–∞–Ω–∏—è ‚Äì –≤—ã–ø–æ–ª–Ω—è–π –∏ –ø–æ–ª—É—á–∞–π –Ω–∞–≥—Ä–∞–¥—ã\n"
        "üîó –†–µ—Ñ–µ—Ä–∞–ª–∫–∞ ‚Äì –ø—Ä–∏–≥–ª–∞—à–∞–π –¥—Ä—É–∑–µ–π\n"
        "üìä –£—Ä–æ–≤–µ–Ω—å ‚Äì —Ç–≤–æ–π –ø—Ä–æ–≥—Ä–µ—Å—Å\n"
        "üéÅ –†–æ–∑—ã–≥—Ä—ã—à–∏ ‚Äì –∞–∫—Ç–∏–≤–Ω—ã–µ –∏ –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–µ\n"
        "üè™ –ú–æ–∏ –±–∏–∑–Ω–µ—Å—ã ‚Äì —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–∏–∑–Ω–µ—Å–æ–º (–ø–æ–∫—É–ø–∫–∞ –∑–∞ BTC)\n"
        "üíº –ë–∏—Ç–∫–æ–∏–Ω-–±–∏—Ä–∂–∞ ‚Äì –ø—Ä–æ–¥–∞–≤–∞–π –∏ –ø–æ–∫—É–ø–∞–π BTC –∑–∞ –±–∞–∫—Å—ã\n"
        "üéì –£–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç ‚Äì –ø—Ä–æ–∫–∞—á–∫–∞ –Ω–∞–≤—ã–∫–æ–≤ –∑–∞ –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç\n"
        "‚öôÔ∏è –ê–¥–º–∏–Ω –ø–∞–Ω–µ–ª—å ‚Äì –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤"
    )
    await message.answer(text)

# ==================== –ü–†–û–í–ï–†–ö–ê –ü–û–î–ü–ò–°–ö–ò ====================
@dp.callback_query(F.data == "check_sub")
async def check_subscription_callback(callback: CallbackQuery):
    user_id = callback.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        await callback.answer("‚õî –í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã.", show_alert=True)
        return
    await ensure_user_exists(user_id, callback.from_user.username, callback.from_user.first_name)
    ok, not_subscribed = await check_subscription(user_id)
    if ok:
        await callback.message.delete()
        is_admin_user = await is_admin(user_id)
        await callback.message.answer(
            "‚úÖ –°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–¥–ø–∏—Å–∫—É! –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å.",
            reply_markup=main_menu_keyboard(is_admin_user)
        )
    else:
        await callback.answer("‚ùå –¢—ã –µ—â—ë –Ω–µ –ø–æ–¥–ø–∏—Å–∞–ª—Å—è –Ω–∞ –≤—Å–µ –∫–∞–Ω–∞–ª—ã!", show_alert=True)
        await callback.message.edit_reply_markup(reply_markup=subscription_inline(not_subscribed))
    await callback.answer()

@dp.callback_query(F.data == "no_link")
async def no_link_callback(callback: CallbackQuery):
    await callback.answer("–°—Å—ã–ª–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç. –ü–æ–¥–ø–∏—à–∏—Å—å –≤—Ä—É—á–Ω—É—é.", show_alert=True)

# ==================== –ü–†–û–§–ò–õ–¨ ====================
@dp.message(F.text == "üë§ –ü—Ä–æ—Ñ–∏–ª—å")
async def profile_handler(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        return
    await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)
    ok, not_subscribed = await check_subscription(user_id)
    if not ok:
        await message.answer("‚ùóÔ∏è –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã.", reply_markup=subscription_inline(not_subscribed))
        return

    async with db_pool.acquire() as conn:
        row = await conn.fetchrow(
            "SELECT balance, reputation, total_spent, negative_balance, joined_date, "
            "theft_attempts, theft_success, theft_failed, theft_protected, "
            "casino_wins, casino_losses, dice_wins, dice_losses, guess_wins, guess_losses, "
            "slots_wins, slots_losses, roulette_wins, roulette_losses, "
            "exp, level, "
            "smuggle_success, smuggle_fail, "
            "bitcoin_balance, authority_balance, "
            "skill_share, skill_luck, skill_betray, "
            "heists_joined, heists_betray_attempts, heists_betray_success, heists_betrayed_count, heists_earned, "
            "strength, agility, defense "
            "FROM users WHERE user_id=$1",
            user_id
        )
    if not row:
        await message.answer("‚ùå –ü—Ä–æ—Ñ–∏–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return

    balance = float(row['balance'] or 0)
    rep = row['reputation'] or 0
    spent = float(row['total_spent'] or 0)
    neg = float(row['negative_balance'] or 0)
    joined = row['joined_date']
    attempts = row['theft_attempts'] or 0
    success = row['theft_success'] or 0
    failed = row['theft_failed'] or 0
    protected = row['theft_protected'] or 0
    cw = row['casino_wins'] or 0
    cl = row['casino_losses'] or 0
    dw = row['dice_wins'] or 0
    dl = row['dice_losses'] or 0
    gw = row['guess_wins'] or 0
    gl = row['guess_losses'] or 0
    sw = row['slots_wins'] or 0
    sl = row['slots_losses'] or 0
    rw = row['roulette_wins'] or 0
    rl = row['roulette_losses'] or 0
    exp = row['exp'] or 0
    level = row['level'] or 1
    smuggle_success = row['smuggle_success'] or 0
    smuggle_fail = row['smuggle_fail'] or 0
    bitcoin = float(row['bitcoin_balance']) if row['bitcoin_balance'] is not None else 0.0
    authority = row['authority_balance'] or 0

    skill_share = row['skill_share'] or 0
    skill_luck = row['skill_luck'] or 0
    skill_betray = row['skill_betray'] or 0

    heists_joined = row['heists_joined'] or 0
    heists_betray_attempts = row['heists_betray_attempts'] or 0
    heists_betray_success = row['heists_betray_success'] or 0
    heists_betrayed_count = row['heists_betrayed_count'] or 0
    heists_earned = float(row['heists_earned'] or 0)

    strength = row['strength'] or 1
    agility = row['agility'] or 1
    defense = row['defense'] or 1

    neg_text = f" (–¥–æ–ª–≥: {neg:.2f})" if neg > 0 else ""
    level_mult = await get_setting_int("level_multiplier")
    exp_needed = level * level_mult
    bar = progress_bar(exp, exp_needed, 10)

    share_bonus = skill_share * await get_setting_int("skill_share_bonus_per_level")
    luck_bonus = skill_luck * await get_setting_int("skill_luck_bonus_per_level")
    betray_bonus = skill_betray * await get_setting_int("skill_betray_bonus_per_level")

    joined_str = joined if joined else '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'

    text = (
        f"üë§ <b>–¢–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å</b>\n"
        f"üìä <b>–£—Ä–æ–≤–µ–Ω—å:</b> {level}\n"
        f"üìà <b>–û–ø—ã—Ç:</b> {exp}/{exp_needed}\n{bar}\n"
        f"üí∞ –ë–∞–ª–∞–Ω—Å: {balance:.2f} –±–∞–∫—Å–æ–≤{neg_text}\n"
        f"‚Çø –ë–∏—Ç–∫–æ–∏–Ω—ã: {bitcoin:.4f} BTC\n"
        f"‚≠êÔ∏è –†–µ–ø—É—Ç–∞—Ü–∏—è: {rep}\n"
        f"‚öîÔ∏è –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç: {authority}\n"
        f"üìÖ –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω: {joined_str}\n\n"
        f"<b>üìä –ù–∞–≤—ã–∫–∏ (–≤–∏–¥–Ω—ã —Ç–æ–ª—å–∫–æ —Ç–µ–±–µ):</b>\n"
        f"üéØ –î–æ–ª—è: +{share_bonus}% –∫ —Å—É–º–º–µ –≥—Ä–∞–±–µ–∂–µ–π\n"
        f"üçÄ –£–¥–∞—á–∞: +{luck_bonus}% —É–π—Ç–∏ –æ—Ç –º–µ–Ω—Ç–æ–≤\n"
        f"üî™ –ö–∏–¥–∞–ª–æ–≤–æ: +{betray_bonus}% –∫ —É—Å–ø–µ—Ö—É\n\n"
        f"<b>üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –Ω–∞–ª—ë—Ç–æ–≤:</b>\n"
        f"–£—á–∞—Å—Ç–∏–π: {heists_joined}, –∑–∞—Ä–∞–±–æ—Ç–∞–Ω–æ: {heists_earned:.2f} $\n"
        f"–ö–∏–¥–∞–ª: {heists_betray_attempts} (—É—Å–ø–µ—à–Ω–æ: {heists_betray_success})\n"
        f"–ö–∏–Ω—É–ª–∏ —Ç–µ–±—è: {heists_betrayed_count} —Ä–∞–∑\n\n"
        f"<b>üé∞ –ö–∞–∑–∏–Ω–æ:</b>\n"
        f"–ö–æ—Å—Ç–∏: {dw}/{dl} | –£–≥–∞–¥–∞–π–∫–∞: {gw}/{gl} | –°–ª–æ—Ç—ã: {sw}/{sl} | –†—É–ª–µ—Ç–∫–∞: {rw}/{rl}\n"
        f"üî´ –û–≥—Ä–∞–±–ª–µ–Ω–∏–π: {attempts} (—É—Å–ø–µ—à–Ω–æ: {success}, –ø—Ä–æ–≤–∞–ª: {failed})\n"
        f"üì¶ –ö–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥–∞: —É—Å–ø–µ—à–Ω–æ {smuggle_success}, –ø—Ä–æ–≤–∞–ª {smuggle_fail}\n\n"
        f"<b>üìä –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:</b>\n"
        f"üí™ –°–∏–ª–∞: {strength} | üèÉ –õ–æ–≤–∫–æ—Å—Ç—å: {agility} | üõ° –ó–∞—â–∏—Ç–∞: {defense}"
    )
    await send_with_media(user_id, text, media_key='profile', reply_markup=main_menu_keyboard(await is_admin(user_id)))

# ==================== –£–ù–ò–í–ï–†–°–ò–¢–ï–¢ (–ü–†–û–ö–ê–ß–ö–ê –ù–ê–í–´–ö–û–í) ====================
@dp.message(F.text == "üéì –£–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç")
async def university_menu(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        return
    await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)
    ok, not_subscribed = await check_subscription(user_id)
    if not ok:
        await message.answer("‚ùóÔ∏è –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã.", reply_markup=subscription_inline(not_subscribed))
        return
    skills = await get_user_skills(user_id)
    authority = await get_user_authority(user_id)
    max_level = await get_setting_int("skill_max_level")
    share_cost = await get_setting_int("skill_share_cost_per_level")
    luck_cost = await get_setting_int("skill_luck_cost_per_level")
    betray_cost = await get_setting_int("skill_betray_cost_per_level")
    share_bonus = skills['skill_share'] * await get_setting_int("skill_share_bonus_per_level")
    luck_bonus = skills['skill_luck'] * await get_setting_int("skill_luck_bonus_per_level")
    betray_bonus = skills['skill_betray'] * await get_setting_int("skill_betray_bonus_per_level")
    text = (
        f"üéì –ö—Ä–∏–º–∏–Ω–∞–ª—å–Ω—ã–π —É–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç\n\n"
        f"–¢–≤–æ–π –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç: {authority}\n\n"
        f"<b>–ù–∞–≤—ã–∫–∏:</b>\n"
        f"üéØ –î–æ–ª—è: —É—Ä–æ–≤–µ–Ω—å {skills['skill_share']}/{max_level} (–±–æ–Ω—É—Å –∫ —Å—É–º–º–µ –≥—Ä–∞–±–µ–∂–µ–π: +{share_bonus}%)\n"
        f"üçÄ –£–¥–∞—á–∞: —É—Ä–æ–≤–µ–Ω—å {skills['skill_luck']}/{max_level} (–±–æ–Ω—É—Å –∫ —É—Ö–æ–¥—É: +{luck_bonus}%)\n"
        f"üî™ –ö–∏–¥–∞–ª–æ–≤–æ: —É—Ä–æ–≤–µ–Ω—å {skills['skill_betray']}/{max_level} (–±–æ–Ω—É—Å –∫ —É—Å–ø–µ—Ö—É: +{betray_bonus}%)\n\n"
        f"–°—Ç–æ–∏–º–æ—Å—Ç—å –ø—Ä–æ–∫–∞—á–∫–∏:\n"
        f"–î–æ–ª—è: {share_cost} –∞–≤—Ç.\n"
        f"–£–¥–∞—á–∞: {luck_cost} –∞–≤—Ç.\n"
        f"–ö–∏–¥–∞–ª–æ–≤–æ: {betray_cost} –∞–≤—Ç.\n\n"
        f"–í—ã–±–µ—Ä–∏, —á—Ç–æ –ø—Ä–æ–∫–∞—á–∞—Ç—å:"
    )
    kb = []
    if skills['skill_share'] < max_level:
        kb.append([InlineKeyboardButton(f"üéØ –î–æ–ª—è –¥–æ {skills['skill_share']+1}", callback_data="upgrade_share")])
    if skills['skill_luck'] < max_level:
        kb.append([InlineKeyboardButton(f"üçÄ –£–¥–∞—á–∞ –¥–æ {skills['skill_luck']+1}", callback_data="upgrade_luck")])
    if skills['skill_betray'] < max_level:
        kb.append([InlineKeyboardButton(f"üî™ –ö–∏–¥–∞–ª–æ–≤–æ –¥–æ {skills['skill_betray']+1}", callback_data="upgrade_betray")])
    kb.append([InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="university_back")])
    await message.answer(text, reply_markup=InlineKeyboardMarkup(inline_keyboard=kb))

@dp.callback_query(F.data.startswith("upgrade_"))
async def upgrade_skill_callback(callback: CallbackQuery, state: FSMContext):
    skill = callback.data.split("_")[1]
    user_id = callback.from_user.id
    skills = await get_user_skills(user_id)
    current_level = skills[f'skill_{skill}']
    max_level = await get_setting_int("skill_max_level")
    if current_level >= max_level:
        await callback.answer("–£–∂–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å!", show_alert=True)
        return
    cost = await get_setting_int(f"skill_{skill}_cost_per_level")
    authority = await get_user_authority(user_id)
    if authority < cost:
        await callback.answer(f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. –ù—É–∂–Ω–æ {cost}, —É —Ç–µ–±—è {authority}.", show_alert=True)
        return
    await state.update_data(skill=skill, cost=cost)
    await callback.message.answer(f"–ü—Ä–æ–∫–∞—á–∞—Ç—å {skill} –¥–æ —É—Ä–æ–≤–Ω—è {current_level+1} –∑–∞ {cost} –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞? (–¥–∞/–Ω–µ—Ç)", reply_markup=back_keyboard())
    await UpgradeSkill.confirming.set()
    await callback.answer()

@dp.message(UpgradeSkill.confirming, F.text)
async def upgrade_skill_confirm(message: Message, state: FSMContext):
    if message.text.lower() == '–Ω–µ—Ç' or message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await university_menu(message)
        return
    if message.text.lower() == '–¥–∞':
        data = await state.get_data()
        skill = data['skill']
        cost = data['cost']
        user_id = message.from_user.id
        async with db_pool.acquire() as conn:
            async with conn.transaction():
                await conn.execute("SET LOCAL statement_timeout = '5s'")
                authority = await get_user_authority(user_id)
                if authority < cost:
                    await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞.")
                    await state.clear()
                    return
                await update_user_authority(user_id, -cost, conn=conn)
                await update_user_skill(user_id, f'skill_{skill}', delta=1, conn=conn)
        await message.answer(f"‚úÖ –ù–∞–≤—ã–∫ {skill} —É—Å–ø–µ—à–Ω–æ –ø—Ä–æ–∫–∞—á–∞–Ω!", reply_markup=main_menu_keyboard(await is_admin(user_id)))
        await state.clear()
        await university_menu(message)
    else:
        await message.answer("–í–≤–µ–¥–∏ '–¥–∞' –∏–ª–∏ '–Ω–µ—Ç'.")

@dp.callback_query(F.data == "university_back")
async def university_back(callback: CallbackQuery):
    await callback.message.delete()
    await university_menu(callback.message)
    await callback.answer()

# ==================== –£–†–û–í–ï–ù–¨ ====================
@dp.message(F.text == "üìä –£—Ä–æ–≤–µ–Ω—å")
async def level_handler(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        return
    await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)
    ok, not_subscribed = await check_subscription(user_id)
    if not ok:
        await message.answer("‚ùóÔ∏è –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã.", reply_markup=subscription_inline(not_subscribed))
        return
    level = await get_user_level(user_id)
    exp = await get_user_exp(user_id)
    level_mult = await get_setting_int("level_multiplier")
    exp_needed = level * level_mult
    bar = progress_bar(exp, exp_needed, 10)
    next_coins = await get_level_reward_coins(level+1)
    next_rep = await get_level_reward_rep(level+1)
    text = (
        f"üìä <b>–¢–≤–æ–π —É—Ä–æ–≤–µ–Ω—å</b>\n\n"
        f"–£—Ä–æ–≤–µ–Ω—å: {level}\n"
        f"–û–ø—ã—Ç: {exp} / {exp_needed}\n"
        f"{bar}\n\n"
        f"–ó–∞ –ø–æ–≤—ã—à–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è —Ç—ã –ø–æ–ª—É—á–∞–µ—à—å –±–∞–∫—Å—ã, —Ä–µ–ø—É—Ç–∞—Ü–∏—é –∏ –æ—á–∫–∏ —Å—Ç–∞—Ç–æ–≤!\n"
        f"–°–ª–µ–¥—É—é—â–∞—è –Ω–∞–≥—Ä–∞–¥–∞: +{next_coins:.2f} –±–∞–∫—Å–æ–≤, +{next_rep} —Ä–µ–ø—É—Ç–∞—Ü–∏–∏."
    )
    await message.answer(text, reply_markup=main_menu_keyboard(await is_admin(user_id)))

# ==================== –ë–û–ù–£–° ====================
@dp.message(F.text == "üéÅ –ë–æ–Ω—É—Å")
async def bonus_handler(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        return
    await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)
    ok, not_subscribed = await check_subscription(user_id)
    if not ok:
        await message.answer("‚ùóÔ∏è –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã.", reply_markup=subscription_inline(not_subscribed))
        return

    async with db_pool.acquire() as conn:
        last_bonus = await conn.fetchval("SELECT last_bonus FROM users WHERE user_id=$1", user_id)

        now = datetime.now()
        if last_bonus:
            if last_bonus.date() == now.date():
                next_bonus = last_bonus + timedelta(days=1)
                time_left = next_bonus - now
                hours, remainder = divmod(time_left.seconds, 3600)
                minutes, _ = divmod(remainder, 60)
                await message.answer(f"‚è≥ –ë–æ–Ω—É—Å —É–∂–µ –ø–æ–ª—É—á–µ–Ω —Å–µ–≥–æ–¥–Ω—è. –°–ª–µ–¥—É—é—â–∏–π —á–µ—Ä–µ–∑ {hours} —á {minutes} –º–∏–Ω.")
                return

        bonus = random.randint(3, 12)
        phrase = f"üéâ –û—Ç–ª–∏—á–Ω–æ, –ª–æ–≤–∏ +{bonus} –±–∞–∫—Å–æ–≤!"

        await conn.execute(
            "UPDATE users SET balance = balance + $1, last_bonus = $2 WHERE user_id=$3",
            bonus, now, user_id
        )
    await message.answer(phrase, reply_markup=main_menu_keyboard(await is_admin(user_id)))

# ==================== –¢–û–ü –ò–ì–†–û–ö–û–í ====================
@dp.message(F.text == "üèÜ –¢–æ–ø –∏–≥—Ä–æ–∫–æ–≤")
async def leaderboard_menu(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        return
    await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)
    ok, not_subscribed = await check_subscription(user_id)
    if not ok:
        await message.answer("‚ùóÔ∏è –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã.", reply_markup=subscription_inline(not_subscribed))
        return
    kb = ReplyKeyboardMarkup(keyboard=[
        [KeyboardButton(text="üí∞ –°–∞–º—ã–µ –±–æ–≥–∞—Ç—ã–µ")],
        [KeyboardButton(text="üí∏ –¢—Ä–∞–Ω–∂–∏—Ä—ã")],
        [KeyboardButton(text="üî´ –ö—Ä–∞–¥—É–Ω—ã")],
        [KeyboardButton(text="‚≠êÔ∏è –ü–æ —Ä–µ–ø—É—Ç–∞—Ü–∏–∏")],
        [KeyboardButton(text="‚Çø –ü–æ –±–∏—Ç–∫–æ–∏–Ω–∞–º")],
        [KeyboardButton(text="üìà –ü–æ —É—Ä–æ–≤–Ω—é")],
        [KeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥")]
    ], resize_keyboard=True)
    await message.answer("–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é —Ç–æ–ø–∞:", reply_markup=kb)

async def show_top(message: Message, field: str, title: str, page: int = 1):
    """–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ç–æ–ø–∞ —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π."""
    offset = (page - 1) * ITEMS_PER_PAGE
    async with db_pool.acquire() as conn:
        if field == 'bitcoin_balance':
            order_expr = "bitcoin_balance"
        else:
            order_expr = field
        total = await conn.fetchval("SELECT COUNT(*) FROM users")
        rows = await conn.fetch(
            f"SELECT first_name, {order_expr} as value FROM users ORDER BY value DESC LIMIT $1 OFFSET $2",
            ITEMS_PER_PAGE, offset
        )
    if not rows:
        await message.answer("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö.")
        return
    text = f"{title} (—Å—Ç—Ä–∞–Ω–∏—Ü–∞ {page}):\n\n"
    for idx, row in enumerate(rows, start=offset+1):
        val = row['value']
        if field == 'bitcoin_balance':
            val = f"{float(val):.4f}"
        elif field in ['balance', 'total_spent']:
            val = f"{float(val):.2f}"
        text += f"{idx}. {row['first_name']} ‚Äì {val}\n"
    kb = []
    nav_buttons = []
    if page > 1:
        nav_buttons.append(InlineKeyboardButton(text="‚¨ÖÔ∏è", callback_data=f"top:{field}:{page-1}"))
    if offset + ITEMS_PER_PAGE < total:
        nav_buttons.append(InlineKeyboardButton(text="‚û°Ô∏è", callback_data=f"top:{field}:{page+1}"))
    if nav_buttons:
        kb.append(nav_buttons)
    if kb:
        await message.answer(text, reply_markup=InlineKeyboardMarkup(inline_keyboard=kb))
    else:
        await message.answer(text)

@dp.message(F.text == "üí∞ –°–∞–º—ã–µ –±–æ–≥–∞—Ç—ã–µ")
async def top_rich_handler(message: Message):
    await show_top(message, "balance", "üí∞ –°–∞–º—ã–µ –±–æ–≥–∞—Ç—ã–µ")

@dp.message(F.text == "üí∏ –¢—Ä–∞–Ω–∂–∏—Ä—ã")
async def top_spenders_handler(message: Message):
    await show_top(message, "total_spent", "üí∏ –¢—Ä–∞–Ω–∂–∏—Ä—ã")

@dp.message(F.text == "üî´ –ö—Ä–∞–¥—É–Ω—ã")
async def top_thieves_handler(message: Message):
    await show_top(message, "theft_success", "üî´ –ö—Ä–∞–¥—É–Ω—ã")

@dp.message(F.text == "‚≠êÔ∏è –ü–æ —Ä–µ–ø—É—Ç–∞—Ü–∏–∏")
async def top_reputation_handler(message: Message):
    await show_top(message, "reputation", "‚≠êÔ∏è –ü–æ —Ä–µ–ø—É—Ç–∞—Ü–∏–∏")

@dp.message(F.text == "‚Çø –ü–æ –±–∏—Ç–∫–æ–∏–Ω–∞–º")
async def top_bitcoin_handler(message: Message):
    await show_top(message, "bitcoin_balance", "‚Çø –ü–æ –±–∏—Ç–∫–æ–∏–Ω–∞–º")

@dp.message(F.text == "üìà –ü–æ —É—Ä–æ–≤–Ω—é")
async def top_level_handler(message: Message):
    await show_top(message, "level", "üìà –ü–æ —É—Ä–æ–≤–Ω—é")

@dp.callback_query(F.data.startswith("top:"))
async def top_page_callback(callback: CallbackQuery):
    parts = callback.data.split(":")
    field = parts[1]
    page = int(parts[2])
    titles = {
        "balance": "üí∞ –°–∞–º—ã–µ –±–æ–≥–∞—Ç—ã–µ",
        "total_spent": "üí∏ –¢—Ä–∞–Ω–∂–∏—Ä—ã",
        "theft_success": "üî´ –ö—Ä–∞–¥—É–Ω—ã",
        "reputation": "‚≠êÔ∏è –ü–æ —Ä–µ–ø—É—Ç–∞—Ü–∏–∏",
        "bitcoin_balance": "‚Çø –ü–æ –±–∏—Ç–∫–æ–∏–Ω–∞–º",
        "level": "üìà –ü–æ —É—Ä–æ–≤–Ω—é",
    }
    title = titles.get(field, "–¢–æ–ø")
    await show_top(callback.message, field, title, page)
    await callback.answer()

# ==================== –ö–ê–ó–ò–ù–û ====================
@dp.message(F.text == "üé∞ –ö–∞–∑–∏–Ω–æ")
async def casino_menu(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        return
    await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)
    ok, not_subscribed = await check_subscription(user_id)
    if not ok:
        await message.answer("‚ùóÔ∏è –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã.", reply_markup=subscription_inline(not_subscribed))
        return
    min_level = await get_setting_int("min_level_casino")
    level = await get_user_level(user_id)
    if level < min_level:
        await message.answer(f"‚ùå –î–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–∑–∏–Ω–æ –Ω—É–∂–µ–Ω {min_level} —É—Ä–æ–≤–µ–Ω—å. –¢–≤–æ–π —É—Ä–æ–≤–µ–Ω—å: {level}")
        return
    await send_with_media(user_id, "–í—ã–±–µ—Ä–∏ –∏–≥—Ä—É:", media_key='casino', reply_markup=casino_menu_keyboard())

# ----- –ö–æ—Å—Ç–∏ -----
@dp.message(F.text == "üé≤ –ö–æ—Å—Ç–∏")
async def dice_start(message: Message, state: FSMContext):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    min_level = await get_setting_int("min_level_casino")
    level = await get_user_level(user_id)
    if level < min_level:
        await message.answer(f"‚ùå –î–ª—è —ç—Ç–æ–π –∏–≥—Ä—ã –Ω—É–∂–µ–Ω {min_level} —É—Ä–æ–≤–µ–Ω—å. –¢–≤–æ–π —É—Ä–æ–≤–µ–Ω—å: {level}")
        return
    await message.answer("–í–≤–µ–¥–∏ —Å—É–º–º—É —Å—Ç–∞–≤–∫–∏ (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω—É—é):", reply_markup=back_keyboard())
    await DiceBet.amount.set()

@dp.message(DiceBet.amount, F.text)
async def dice_bet(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await casino_menu(message)
        return

    ok, remaining = await check_global_cooldown(message.from_user.id, "dice")
    if not ok:
        await message.answer(f"‚è≥ –ü–æ–¥–æ–∂–¥–∏ –µ—â—ë {remaining} —Å–µ–∫.")
        await state.clear()
        return

    try:
        amount = float(message.text)
        if amount <= 0:
            raise ValueError
        amount = round(amount, 2)
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.")
        return
    user_id = message.from_user.id
    balance = await get_user_balance(user_id)
    min_bet = await get_setting_float("casino_min_bet")
    max_bet = await get_setting_float("casino_max_bet")
    max_input = await get_setting_float("max_input_number")
    if amount < min_bet:
        await message.answer(f"‚ùå –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–∞–≤–∫–∞ {min_bet:.2f} –±–∞–∫—Å–∞.")
        await state.clear()
        return
    if amount > max_bet:
        await message.answer(f"‚ùå –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–∞–≤–∫–∞ {max_bet:.2f}.")
        await state.clear()
        return
    if amount > max_input:
        await message.answer(f"‚ùå –°—É–º–º–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è (–º–∞–∫—Å–∏–º—É–º {max_input:.2f}).")
        await state.clear()
        return
    if amount > balance:
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∞–∫—Å–æ–≤.")
        await state.clear()
        return

    dice1 = random.randint(1, 6)
    dice2 = random.randint(1, 6)
    total = dice1 + dice2

    win_chance = await get_setting_float("casino_win_chance")
    win = random.random() * 100 <= win_chance

    async with db_pool.acquire() as conn:
        success, new_balance, _ = await update_user_balance(user_id, -amount, conn=conn, allow_negative=False)
        if not success:
            await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–ø–∏—Å–∞–Ω–∏–∏ —Å—Ç–∞–≤–∫–∏.")
            await state.clear()
            return
        await update_user_game_stats(user_id, 'dice', win, conn=conn)
        if win:
            multiplier = 2.0
            profit = amount * multiplier
            await update_user_balance(user_id, profit, conn=conn, allow_negative=False)
            exp = await get_setting_int("exp_per_dice_win")
            phrase = f"üé≤ {dice1} + {dice2} = {total} ‚Äî –ü–æ–±–µ–¥–∞! +{profit:.2f} –±–∞–∫—Å–æ–≤!"
        else:
            exp = await get_setting_int("exp_per_dice_lose")
            phrase = f"üé≤ {dice1} + {dice2} = {total} ‚Äî –ü—Ä–æ–∏–≥—Ä—ã—à. -{amount:.2f} –±–∞–∫—Å–æ–≤."
        level_up_msg = await add_exp(user_id, exp, conn=conn)
        if level_up_msg:
            asyncio.create_task(safe_send_message(user_id, level_up_msg))

    await save_last_bet(user_id, 'dice', amount)
    await set_global_cooldown(user_id, "dice")

    await message.answer(phrase, reply_markup=repeat_bet_keyboard('dice'))
    await state.clear()

# ----- –£–≥–∞–¥–∞–π —á–∏—Å–ª–æ (—Å –∫–Ω–æ–ø–∫–∞–º–∏) -----
@dp.message(F.text == "üî¢ –£–≥–∞–¥–∞–π —á–∏—Å–ª–æ")
async def guess_start(message: Message, state: FSMContext):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    min_level = await get_setting_int("min_level_casino")
    level = await get_user_level(user_id)
    if level < min_level:
        await message.answer(f"‚ùå –î–ª—è —ç—Ç–æ–π –∏–≥—Ä—ã –Ω—É–∂–µ–Ω {min_level} —É—Ä–æ–≤–µ–Ω—å. –¢–≤–æ–π —É—Ä–æ–≤–µ–Ω—å: {level}")
        return
    await message.answer("–í–≤–µ–¥–∏ —Å—É–º–º—É —Å—Ç–∞–≤–∫–∏ (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω—É—é):", reply_markup=back_keyboard())
    await GuessBet.amount.set()

@dp.message(GuessBet.amount, F.text)
async def guess_bet(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await casino_menu(message)
        return

    ok, remaining = await check_global_cooldown(message.from_user.id, "guess")
    if not ok:
        await message.answer(f"‚è≥ –ü–æ–¥–æ–∂–¥–∏ –µ—â—ë {remaining} —Å–µ–∫.")
        await state.clear()
        return

    try:
        amount = float(message.text)
        if amount <= 0:
            raise ValueError
        amount = round(amount, 2)
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.")
        return
    user_id = message.from_user.id
    balance = await get_user_balance(user_id)
    min_bet = await get_setting_float("casino_min_bet")
    max_bet = await get_setting_float("casino_max_bet")
    max_input = await get_setting_float("max_input_number")
    if amount < min_bet:
        await message.answer(f"‚ùå –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–∞–≤–∫–∞ {min_bet:.2f}.")
        await state.clear()
        return
    if amount > max_bet:
        await message.answer(f"‚ùå –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–∞–≤–∫–∞ {max_bet:.2f}.")
        await state.clear()
        return
    if amount > max_input:
        await message.answer(f"‚ùå –°—É–º–º–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è (–º–∞–∫—Å–∏–º—É–º {max_input:.2f}).")
        await state.clear()
        return
    if amount > balance:
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∞–∫—Å–æ–≤.")
        await state.clear()
        return

    await state.update_data(amount=amount)
    await message.answer("–í—ã–±–µ—Ä–∏ —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 5:", reply_markup=guess_number_keyboard())
    await GuessBet.number.set()

@dp.callback_query(GuessBet.number, F.data.startswith("guess_num_"))
async def guess_number_callback(callback: CallbackQuery, state: FSMContext):
    guess = int(callback.data.split("_")[2])
    data = await state.get_data()
    amount = data['amount']
    user_id = callback.from_user.id

    win_chance = await get_setting_float("casino_win_chance")
    win = random.random() * 100 <= win_chance

    multiplier = 2.0
    rep_reward = 1

    async with db_pool.acquire() as conn:
        success, new_balance, _ = await update_user_balance(user_id, -amount, conn=conn, allow_negative=False)
        if not success:
            await callback.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–ø–∏—Å–∞–Ω–∏–∏ —Å—Ç–∞–≤–∫–∏.", show_alert=True)
            await state.clear()
            return
        await update_user_game_stats(user_id, 'guess', win, conn=conn)
        if win:
            profit = amount * multiplier
            await update_user_balance(user_id, profit, conn=conn, allow_negative=False)
            await update_user_reputation(user_id, rep_reward)
            exp = await get_setting_int("exp_per_guess_win")
            phrase = f"üî¢ –¢—ã —É–≥–∞–¥–∞–ª! –ë—ã–ª–æ {guess}. –í—ã–∏–≥—Ä—ã—à: +{profit:.2f} –±–∞–∫—Å–æ–≤ –∏ +{rep_reward} —Ä–µ–ø—É—Ç–∞—Ü–∏–∏!"
        else:
            exp = await get_setting_int("exp_per_guess_lose")
            secret = random.randint(1, 5)
            phrase = f"üî¢ –ù–µ —É–≥–∞–¥–∞–ª. –ë—ã–ª–æ {secret}. -{amount:.2f} –±–∞–∫—Å–æ–≤."
        level_up_msg = await add_exp(user_id, exp, conn=conn)
        if level_up_msg:
            asyncio.create_task(safe_send_message(user_id, level_up_msg))

    bet_data = {'number': guess}
    await save_last_bet(user_id, 'guess', amount, bet_data)
    await set_global_cooldown(user_id, "guess")

    await callback.message.edit_text(phrase, reply_markup=repeat_bet_keyboard('guess'))
    await state.clear()
    await callback.answer()

@dp.callback_query(GuessBet.number, F.data == "guess_cancel")
async def guess_cancel(callback: CallbackQuery, state: FSMContext):
    await state.clear()
    await casino_menu(callback.message)
    await callback.answer()

# ----- –°–ª–æ—Ç—ã -----
@dp.message(F.text == "üçí –°–ª–æ—Ç—ã")
async def slots_start(message: Message, state: FSMContext):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    min_level = await get_setting_int("min_level_casino")
    level = await get_user_level(user_id)
    if level < min_level:
        await message.answer(f"‚ùå –î–ª—è —ç—Ç–æ–π –∏–≥—Ä—ã –Ω—É–∂–µ–Ω {min_level} —É—Ä–æ–≤–µ–Ω—å. –¢–≤–æ–π —É—Ä–æ–≤–µ–Ω—å: {level}")
        return
    await message.answer("–í–≤–µ–¥–∏ —Å—É–º–º—É —Å—Ç–∞–≤–∫–∏ (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω—É—é):", reply_markup=back_keyboard())
    await SlotsBet.amount.set()

@dp.message(SlotsBet.amount, F.text)
async def slots_bet(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await casino_menu(message)
        return

    ok, remaining = await check_global_cooldown(message.from_user.id, "slots")
    if not ok:
        await message.answer(f"‚è≥ –ü–æ–¥–æ–∂–¥–∏ –µ—â—ë {remaining} —Å–µ–∫.")
        await state.clear()
        return

    try:
        amount = float(message.text)
        if amount <= 0:
            raise ValueError
        amount = round(amount, 2)
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.")
        return
    user_id = message.from_user.id
    balance = await get_user_balance(user_id)
    min_bet = await get_setting_float("casino_min_bet")
    max_bet = await get_setting_float("casino_max_bet")
    max_input = await get_setting_float("max_input_number")
    if amount < min_bet:
        await message.answer(f"‚ùå –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–∞–≤–∫–∞ {min_bet:.2f}.")
        await state.clear()
        return
    if amount > max_bet:
        await message.answer(f"‚ùå –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–∞–≤–∫–∞ {max_bet:.2f}.")
        await state.clear()
        return
    if amount > max_input:
        await message.answer(f"‚ùå –°—É–º–º–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è (–º–∞–∫—Å–∏–º—É–º {max_input:.2f}).")
        await state.clear()
        return
    if amount > balance:
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∞–∫—Å–æ–≤.")
        await state.clear()
        return

    anim = await message.answer("üçí –ó–∞–ø—É—Å–∫–∞–µ–º —Å–ª–æ—Ç—ã...")
    stages = [
        "üçí | üçã | üçä",
        "üçã | üçä | 7Ô∏è‚É£",
        "üçä | 7Ô∏è‚É£ | üíé",
        "7Ô∏è‚É£ | üíé | üçí",
    ]
    for stage in stages:
        await asyncio.sleep(0.3)
        await anim.edit_text(stage)

    win_prob = await get_setting_float("slots_win_probability")
    win = random.random() * 100 <= win_prob
    symbols = ['üçí', 'üçã', 'üçä', '7Ô∏è‚É£', 'üíé']
    result = [random.choice(symbols) for _ in range(3)]
    if win:
        if random.random() < 0.1:
            result = [random.choice(symbols) for _ in range(3)]
            result[0] = result[1] = result[2] = random.choice(symbols)
        else:
            result = [random.choice(symbols) for _ in range(3)]
    result_str = " | ".join(result)

    if win and result[0] == result[1] == result[2]:
        if result[0] == '7Ô∏è‚É£':
            multiplier = await get_setting_float("slots_multiplier_seven")
        elif result[0] == 'üíé':
            multiplier = await get_setting_float("slots_multiplier_diamond")
        else:
            multiplier = await get_setting_float("slots_multiplier_three")
    elif win:
        multiplier = 2.0
    else:
        multiplier = 0

    async with db_pool.acquire() as conn:
        success, new_balance, _ = await update_user_balance(user_id, -amount, conn=conn, allow_negative=False)
        if not success:
            await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–ø–∏—Å–∞–Ω–∏–∏ —Å—Ç–∞–≤–∫–∏.")
            await state.clear()
            return
        await update_user_game_stats(user_id, 'slots', win, conn=conn)
        if win:
            profit = amount * multiplier
            await update_user_balance(user_id, profit, conn=conn, allow_negative=False)
            exp = await get_setting_int("exp_per_slots_win")
            phrase = f"üçí {result_str} ‚Äî –£—Ä–∞! –í—ã–∏–≥—Ä—ã—à x{multiplier:.1f}! +{profit:.2f} –±–∞–∫—Å–æ–≤!"
        else:
            exp = await get_setting_int("exp_per_slots_lose")
            phrase = f"üçí {result_str} ‚Äî –ù–µ –ø–æ–≤–µ–∑–ª–æ. -{amount:.2f} –±–∞–∫—Å–æ–≤."
        level_up_msg = await add_exp(user_id, exp, conn=conn)
        if level_up_msg:
            asyncio.create_task(safe_send_message(user_id, level_up_msg))

    await save_last_bet(user_id, 'slots', amount)
    await set_global_cooldown(user_id, "slots")

    await anim.edit_text(phrase, reply_markup=repeat_bet_keyboard('slots'))
    await state.clear()

# ----- –†—É–ª–µ—Ç–∫–∞ (—Å –∫–Ω–æ–ø–∫–∞–º–∏) -----
@dp.message(F.text == "üé° –†—É–ª–µ—Ç–∫–∞")
async def roulette_start(message: Message, state: FSMContext):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    min_level = await get_setting_int("min_level_casino")
    level = await get_user_level(user_id)
    if level < min_level:
        await message.answer(f"‚ùå –î–ª—è —ç—Ç–æ–π –∏–≥—Ä—ã –Ω—É–∂–µ–Ω {min_level} —É—Ä–æ–≤–µ–Ω—å. –¢–≤–æ–π —É—Ä–æ–≤–µ–Ω—å: {level}")
        return
    await message.answer("–í–≤–µ–¥–∏ —Å—É–º–º—É —Å—Ç–∞–≤–∫–∏ (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω—É—é):", reply_markup=back_keyboard())
    await RouletteBet.amount.set()

@dp.message(RouletteBet.amount, F.text)
async def roulette_bet_amount(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await casino_menu(message)
        return

    ok, remaining = await check_global_cooldown(message.from_user.id, "roulette")
    if not ok:
        await message.answer(f"‚è≥ –ü–æ–¥–æ–∂–¥–∏ –µ—â—ë {remaining} —Å–µ–∫.")
        await state.clear()
        return

    try:
        amount = float(message.text)
        if amount <= 0:
            raise ValueError
        amount = round(amount, 2)
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.")
        return
    user_id = message.from_user.id
    balance = await get_user_balance(user_id)
    min_bet = await get_setting_float("casino_min_bet")
    max_bet = await get_setting_float("casino_max_bet")
    max_input = await get_setting_float("max_input_number")
    if amount < min_bet:
        await message.answer(f"‚ùå –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–∞–≤–∫–∞ {min_bet:.2f}.")
        await state.clear()
        return
    if amount > max_bet:
        await message.answer(f"‚ùå –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–∞–≤–∫–∞ {max_bet:.2f}.")
        await state.clear()
        return
    if amount > max_input:
        await message.answer(f"‚ùå –°—É–º–º–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è (–º–∞–∫—Å–∏–º—É–º {max_input:.2f}).")
        await state.clear()
        return
    if amount > balance:
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∞–∫—Å–æ–≤.")
        await state.clear()
        return
    await state.update_data(amount=amount)
    await message.answer("–í—ã–±–µ—Ä–∏ —Ç–∏–ø —Å—Ç–∞–≤–∫–∏:", reply_markup=roulette_type_keyboard())
    await RouletteBet.bet_type.set()

@dp.callback_query(RouletteBet.bet_type, F.data.startswith("roulette_type_"))
async def roulette_type_callback(callback: CallbackQuery, state: FSMContext):
    bet_type = callback.data.split("_")[2]
    if bet_type == "number":
        await callback.message.edit_text("–í—ã–±–µ—Ä–∏ —á–∏—Å–ª–æ –æ—Ç 0 –¥–æ 36:", reply_markup=roulette_number_keyboard())
        await RouletteBet.number.set()
    else:
        await state.update_data(bet_type=bet_type, number=None)
        await process_roulette_bet(callback.message, state, callback.from_user.id)
    await callback.answer()

@dp.callback_query(RouletteBet.number, F.data.startswith("roulette_num_"))
async def roulette_number_callback(callback: CallbackQuery, state: FSMContext):
    number = int(callback.data.split("_")[2])
    await state.update_data(bet_type='number', number=number)
    await process_roulette_bet(callback.message, state, callback.from_user.id)
    await callback.answer()

@dp.callback_query(RouletteBet.bet_type, F.data == "roulette_cancel")
@dp.callback_query(RouletteBet.number, F.data == "roulette_cancel")
async def roulette_cancel(callback: CallbackQuery, state: FSMContext):
    await state.clear()
    await casino_menu(callback.message)
    await callback.answer()

async def process_roulette_bet(message: Message, state: FSMContext, user_id: int):
    data = await state.get_data()
    amount = data['amount']
    bet_type = data['bet_type']
    bet_number = data.get('number')
    anim = await message.answer("üé° –ö—Ä—É—Ç–∏–º —Ä—É–ª–µ—Ç–∫—É...")
    for _ in range(3):
        await asyncio.sleep(0.5)
        await anim.edit_text("üé° ‚Ä¢ ‚Ä¢")
        await asyncio.sleep(0.5)
        await anim.edit_text("‚Ä¢ üé° ‚Ä¢")
        await asyncio.sleep(0.5)
        await anim.edit_text("‚Ä¢ ‚Ä¢ üé°")

    number = random.randint(0, 36)
    color = '–∑–µ–ª—ë–Ω–æ–µ' if number == 0 else ('–∫—Ä–∞—Å–Ω–æ–µ' if number % 2 == 0 else '—á—ë—Ä–Ω–æ–µ')

    win_chance = await get_setting_float("roulette_win_chance")
    if bet_type == 'green':
        win_chance = 1 / 37 * 100
    elif bet_type == 'number':
        win_chance = 1 / 37 * 100

    win = random.random() * 100 <= win_chance
    if bet_type == 'number':
        win = win and number == bet_number
    elif bet_type == 'red':
        win = win and color == '–∫—Ä–∞—Å–Ω–æ–µ'
    elif bet_type == 'black':
        win = win and color == '—á—ë—Ä–Ω–æ–µ'
    elif bet_type == 'green':
        win = win and color == '–∑–µ–ª—ë–Ω–æ–µ'

    async with db_pool.acquire() as conn:
        success, new_balance, _ = await update_user_balance(user_id, -amount, conn=conn, allow_negative=False)
        if not success:
            await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–ø–∏—Å–∞–Ω–∏–∏ —Å—Ç–∞–≤–∫–∏.")
            await state.clear()
            return
        await update_user_game_stats(user_id, 'roulette', win, conn=conn)
        if win:
            if bet_type == 'number':
                multiplier = await get_setting_float("roulette_number_multiplier")
            elif bet_type == 'green':
                multiplier = await get_setting_float("roulette_green_multiplier")
            else:
                multiplier = await get_setting_float("roulette_color_multiplier")
            profit = amount * multiplier
            await update_user_balance(user_id, profit, conn=conn, allow_negative=False)
            exp = await get_setting_int("exp_per_roulette_win")
            phrase = f"üé° –í—ã–ø–∞–ª–æ {number} {color}! –¢—ã –≤—ã–∏–≥—Ä–∞–ª {profit:.2f} –±–∞–∫—Å–æ–≤!"
        else:
            exp = await get_setting_int("exp_per_roulette_lose")
            phrase = f"üé° –í—ã–ø–∞–ª–æ {number} {color}. –¢–≤–æ—è —Å—Ç–∞–≤–∫–∞ –Ω–µ —Å—ã–≥—Ä–∞–ª–∞. -{amount:.2f} –±–∞–∫—Å–æ–≤."
        level_up_msg = await add_exp(user_id, exp, conn=conn)
        if level_up_msg:
            asyncio.create_task(safe_send_message(user_id, level_up_msg))

    bet_data = {'bet_type': bet_type, 'number': bet_number}
    await save_last_bet(user_id, 'roulette', amount, bet_data)
    await set_global_cooldown(user_id, "roulette")

    await anim.edit_text(phrase, reply_markup=repeat_bet_keyboard('roulette'))
    await state.clear()

# ----- –ü–æ–≤—Ç–æ—Ä —Å—Ç–∞–≤–∫–∏ -----
@dp.callback_query(F.data.startswith("repeat_"))
async def repeat_bet_callback(callback: CallbackQuery, state: FSMContext):
    game = callback.data.split("_")[1]
    user_id = callback.from_user.id
    await ensure_user_exists(user_id, callback.from_user.username, callback.from_user.first_name)

    ok, remaining = await check_global_cooldown(user_id, game)
    if not ok:
        await callback.answer(f"‚è≥ –ü–æ–¥–æ–∂–¥–∏ –µ—â—ë {remaining} —Å–µ–∫.", show_alert=True)
        return

    async with db_pool.acquire() as conn:
        last = await conn.fetchrow(
            "SELECT bet_amount, bet_data FROM user_last_bets WHERE user_id=$1 AND game=$2",
            user_id, game
        )
        if not last:
            await callback.answer("–£ —Ç–µ–±—è –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–π —Å—Ç–∞–≤–∫–∏ –¥–ª—è —ç—Ç–æ–π –∏–≥—Ä—ã.", show_alert=True)
            return

        amount = float(last['bet_amount'])
        bet_data = json.loads(last['bet_data']) if last['bet_data'] else {}

    balance = await get_user_balance(user_id)
    if amount > balance:
        await callback.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∞–∫—Å–æ–≤ –¥–ª—è –ø–æ–≤—Ç–æ—Ä–∞ —Å—Ç–∞–≤–∫–∏.", show_alert=True)
        return

    chat_id = callback.message.chat.id

    if game == 'dice':
        await process_dice_repeat(user_id, amount, chat_id)
    elif game == 'guess' and 'number' in bet_data:
        number = bet_data['number']
        await process_guess_repeat(user_id, amount, number, chat_id)
    elif game == 'slots':
        await process_slots_repeat(user_id, amount, chat_id)
    elif game == 'roulette' and 'bet_type' in bet_data:
        bet_type = bet_data['bet_type']
        number = bet_data.get('number')
        await process_roulette_repeat(user_id, amount, bet_type, number, chat_id)
    else:
        await callback.answer("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø–æ–≤—Ç–æ—Ä–∞.", show_alert=True)
        return

    await set_global_cooldown(user_id, game)
    await callback.answer()

async def process_dice_repeat(user_id: int, amount: float, chat_id: int):
    dice1 = random.randint(1, 6)
    dice2 = random.randint(1, 6)
    total = dice1 + dice2
    win_chance = await get_setting_float("casino_win_chance")
    win = random.random() * 100 <= win_chance

    async with db_pool.acquire() as conn:
        success, new_balance, _ = await update_user_balance(user_id, -amount, conn=conn, allow_negative=False)
        if not success:
            await bot.send_message(chat_id, "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–ø–∏—Å–∞–Ω–∏–∏ —Å—Ç–∞–≤–∫–∏.")
            return
        await update_user_game_stats(user_id, 'dice', win, conn=conn)
        if win:
            multiplier = 2.0
            profit = amount * multiplier
            await update_user_balance(user_id, profit, conn=conn, allow_negative=False)
            exp = await get_setting_int("exp_per_dice_win")
            phrase = f"üé≤ {dice1} + {dice2} = {total} ‚Äî –ü–æ–±–µ–¥–∞! +{profit:.2f} –±–∞–∫—Å–æ–≤!"
        else:
            exp = await get_setting_int("exp_per_dice_lose")
            phrase = f"üé≤ {dice1} + {dice2} = {total} ‚Äî –ü—Ä–æ–∏–≥—Ä—ã—à. -{amount:.2f} –±–∞–∫—Å–æ–≤."
        level_up_msg = await add_exp(user_id, exp, conn=conn)
        if level_up_msg:
            asyncio.create_task(safe_send_message(user_id, level_up_msg))

    await save_last_bet(user_id, 'dice', amount)
    await bot.send_message(chat_id, phrase, reply_markup=repeat_bet_keyboard('dice'))

async def process_guess_repeat(user_id: int, amount: float, number: int, chat_id: int):
    win_chance = await get_setting_float("casino_win_chance")
    win = random.random() * 100 <= win_chance
    secret = random.randint(1, 5)

    multiplier = 2.0
    rep_reward = 1

    async with db_pool.acquire() as conn:
        success, new_balance, _ = await update_user_balance(user_id, -amount, conn=conn, allow_negative=False)
        if not success:
            await bot.send_message(chat_id, "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–ø–∏—Å–∞–Ω–∏–∏ —Å—Ç–∞–≤–∫–∏.")
            return
        await update_user_game_stats(user_id, 'guess', win, conn=conn)
        if win:
            profit = amount * multiplier
            await update_user_balance(user_id, profit, conn=conn, allow_negative=False)
            await update_user_reputation(user_id, rep_reward)
            exp = await get_setting_int("exp_per_guess_win")
            phrase = f"üî¢ –¢—ã —É–≥–∞–¥–∞–ª! –ë—ã–ª–æ {secret}. –í—ã–∏–≥—Ä—ã—à: +{profit:.2f} –±–∞–∫—Å–æ–≤ –∏ +{rep_reward} —Ä–µ–ø—É—Ç–∞—Ü–∏–∏!"
        else:
            exp = await get_setting_int("exp_per_guess_lose")
            phrase = f"üî¢ –ù–µ —É–≥–∞–¥–∞–ª. –ë—ã–ª–æ {secret}. -{amount:.2f} –±–∞–∫—Å–æ–≤."
        level_up_msg = await add_exp(user_id, exp, conn=conn)
        if level_up_msg:
            asyncio.create_task(safe_send_message(user_id, level_up_msg))

    bet_data = {'number': number}
    await save_last_bet(user_id, 'guess', amount, bet_data)
    await bot.send_message(chat_id, phrase, reply_markup=repeat_bet_keyboard('guess'))

async def process_slots_repeat(user_id: int, amount: float, chat_id: int):
    win_prob = await get_setting_float("slots_win_probability")
    win = random.random() * 100 <= win_prob
    symbols = ['üçí', 'üçã', 'üçä', '7Ô∏è‚É£', 'üíé']
    result = [random.choice(symbols) for _ in range(3)]
    if win:
        if random.random() < 0.1:
            result = [random.choice(symbols) for _ in range(3)]
            result[0] = result[1] = result[2] = random.choice(symbols)
        else:
            result = [random.choice(symbols) for _ in range(3)]
    result_str = " | ".join(result)

    if win and result[0] == result[1] == result[2]:
        if result[0] == '7Ô∏è‚É£':
            multiplier = await get_setting_float("slots_multiplier_seven")
        elif result[0] == 'üíé':
            multiplier = await get_setting_float("slots_multiplier_diamond")
        else:
            multiplier = await get_setting_float("slots_multiplier_three")
    elif win:
        multiplier = 2.0
    else:
        multiplier = 0

    async with db_pool.acquire() as conn:
        success, new_balance, _ = await update_user_balance(user_id, -amount, conn=conn, allow_negative=False)
        if not success:
            await bot.send_message(chat_id, "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–ø–∏—Å–∞–Ω–∏–∏ —Å—Ç–∞–≤–∫–∏.")
            return
        await update_user_game_stats(user_id, 'slots', win, conn=conn)
        if win:
            profit = amount * multiplier
            await update_user_balance(user_id, profit, conn=conn, allow_negative=False)
            exp = await get_setting_int("exp_per_slots_win")
            phrase = f"üçí {result_str} ‚Äî –£—Ä–∞! –í—ã–∏–≥—Ä—ã—à x{multiplier:.1f}! +{profit:.2f} –±–∞–∫—Å–æ–≤!"
        else:
            exp = await get_setting_int("exp_per_slots_lose")
            phrase = f"üçí {result_str} ‚Äî –ù–µ –ø–æ–≤–µ–∑–ª–æ. -{amount:.2f} –±–∞–∫—Å–æ–≤."
        level_up_msg = await add_exp(user_id, exp, conn=conn)
        if level_up_msg:
            asyncio.create_task(safe_send_message(user_id, level_up_msg))

    await save_last_bet(user_id, 'slots', amount)
    await bot.send_message(chat_id, phrase, reply_markup=repeat_bet_keyboard('slots'))

async def process_roulette_repeat(user_id: int, amount: float, bet_type: str, number: int, chat_id: int):
    spin = random.randint(0, 36)
    color = '–∑–µ–ª—ë–Ω–æ–µ' if spin == 0 else ('–∫—Ä–∞—Å–Ω–æ–µ' if spin % 2 == 0 else '—á—ë—Ä–Ω–æ–µ')

    win_chance = await get_setting_float("roulette_win_chance")
    if bet_type == 'green':
        win_chance = 1 / 37 * 100
    elif bet_type == 'number':
        win_chance = 1 / 37 * 100

    win = random.random() * 100 <= win_chance
    if bet_type == 'number':
        win = win and spin == number
    elif bet_type == 'red':
        win = win and color == '–∫—Ä–∞—Å–Ω–æ–µ'
    elif bet_type == 'black':
        win = win and color == '—á—ë—Ä–Ω–æ–µ'
    elif bet_type == 'green':
        win = win and color == '–∑–µ–ª—ë–Ω–æ–µ'

    async with db_pool.acquire() as conn:
        success, new_balance, _ = await update_user_balance(user_id, -amount, conn=conn, allow_negative=False)
        if not success:
            await bot.send_message(chat_id, "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–ø–∏—Å–∞–Ω–∏–∏ —Å—Ç–∞–≤–∫–∏.")
            return
        await update_user_game_stats(user_id, 'roulette', win, conn=conn)
        if win:
            if bet_type == 'number':
                multiplier = await get_setting_float("roulette_number_multiplier")
            elif bet_type == 'green':
                multiplier = await get_setting_float("roulette_green_multiplier")
            else:
                multiplier = await get_setting_float("roulette_color_multiplier")
            profit = amount * multiplier
            await update_user_balance(user_id, profit, conn=conn, allow_negative=False)
            exp = await get_setting_int("exp_per_roulette_win")
            phrase = f"üé° –í—ã–ø–∞–ª–æ {spin} {color}! –¢—ã –≤—ã–∏–≥—Ä–∞–ª {profit:.2f} –±–∞–∫—Å–æ–≤!"
        else:
            exp = await get_setting_int("exp_per_roulette_lose")
            phrase = f"üé° –í—ã–ø–∞–ª–æ {spin} {color}. –¢–≤–æ—è —Å—Ç–∞–≤–∫–∞ –Ω–µ —Å—ã–≥—Ä–∞–ª–∞. -{amount:.2f} –±–∞–∫—Å–æ–≤."
        level_up_msg = await add_exp(user_id, exp, conn=conn)
        if level_up_msg:
            asyncio.create_task(safe_send_message(user_id, level_up_msg))

    bet_data = {'bet_type': bet_type, 'number': number}
    await save_last_bet(user_id, 'roulette', amount, bet_data)
    await bot.send_message(chat_id, phrase, reply_markup=repeat_bet_keyboard('roulette'))

# ==================== –ú–ê–ì–ê–ó–ò–ù –ü–û–î–ê–†–ö–û–í ====================
@dp.message(F.text == "üõí –ú–∞–≥–∞–∑–∏–Ω –ø–æ–¥–∞—Ä–∫–æ–≤")
async def shop_handler(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        return
    await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)
    ok, not_subscribed = await check_subscription(user_id)
    if not ok:
        await message.answer("‚ùóÔ∏è –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã.", reply_markup=subscription_inline(not_subscribed))
        return
    page = 1
    try:
        parts = message.text.split()
        if len(parts) > 1:
            page = int(parts[1])
    except:
        pass
    offset = (page - 1) * ITEMS_PER_PAGE
    async with db_pool.acquire() as conn:
        total = await conn.fetchval("SELECT COUNT(*) FROM shop_items")
        rows = await conn.fetch(
            "SELECT id, name, description, price, stock, photo_file_id FROM shop_items ORDER BY id LIMIT $1 OFFSET $2",
            ITEMS_PER_PAGE, offset
        )
    if not rows:
        await message.answer("üéÅ –í –º–∞–≥–∞–∑–∏–Ω–µ –ø–æ–∫–∞ –Ω–µ—Ç –ø–æ–¥–∞—Ä–∫–æ–≤.")
        return
    text = f"üéÅ –ü–æ–¥–∞—Ä–∫–∏ (—Å—Ç—Ä–∞–Ω–∏—Ü–∞ {page}):\n\n"
    kb = []
    for row in rows:
        item_id = row['id']
        name = row['name']
        desc = row['description']
        price = float(row['price'])
        stock = row['stock']
        stock_info = f" (–≤ –Ω–∞–ª–∏—á–∏–∏: {stock})" if stock != -1 else ""
        text += f"üîπ {name}\n{desc}\nüí∞ {price:.2f} –±–∞–∫—Å–æ–≤{stock_info}\n\n"
        button_text = f"–ö—É–ø–∏—Ç—å {name}"
        kb.append([InlineKeyboardButton(text=button_text, callback_data=f"buyproduct_{item_id}")])
    nav_buttons = []
    if page > 1:
        nav_buttons.append(InlineKeyboardButton(text="‚¨ÖÔ∏è", callback_data=f"shop_page_{page-1}"))
    if offset + ITEMS_PER_PAGE < total:
        nav_buttons.append(InlineKeyboardButton(text="‚û°Ô∏è", callback_data=f"shop_page_{page+1}"))
    if nav_buttons:
        kb.append(nav_buttons)
    await send_with_media(message.chat.id, text, media_key='shop', reply_markup=InlineKeyboardMarkup(inline_keyboard=kb))

@dp.callback_query(F.data.startswith("shop_page_"))
async def shop_page_callback(callback: CallbackQuery):
    page = int(callback.data.split("_")[2])
    # –°–æ–∑–¥–∞—ë–º –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –æ–±–Ω–æ–≤–ª—ë–Ω–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ–π
    await shop_handler(callback.message)
    await callback.answer()

# ==================== –ü–û–ö–£–ü–ö–ê –¢–û–í–ê–†–ê (–ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ü–ê–†–°–ò–ù–ì) ====================
@dp.callback_query(F.data.startswith("buyproduct_"))
async def buy_callback(callback: CallbackQuery):
    user_id = callback.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        await callback.answer("‚õî –í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã.", show_alert=True)
        return

    await ensure_user_exists(user_id, callback.from_user.username, callback.from_user.first_name)
    ok, not_subscribed = await check_subscription(user_id)
    if not ok:
        await callback.message.edit_text("‚ùóÔ∏è –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã.", reply_markup=subscription_inline(not_subscribed))
        await callback.answer()
        return

    try:
        # –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥: –æ—Ç–¥–µ–ª—è–µ–º –ø—Ä–µ—Ñ–∏–∫—Å –æ—Ç ID
        prefix, item_id_str = callback.data.split("_", 1)
        item_id = int(item_id_str)

        async with db_pool.acquire() as conn:
            row = await conn.fetchrow("SELECT name, price, stock FROM shop_items WHERE id=$1", item_id)
            if not row:
                await callback.answer("‚ùå –¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
                return
            name, price, stock = row['name'], float(row['price']), row['stock']
            if stock != -1 and stock <= 0:
                await callback.answer("‚ùå –¢–æ–≤–∞—Ä–∞ –Ω–µ—Ç –≤ –Ω–∞–ª–∏—á–∏–∏!", show_alert=True)
                return
            balance = await get_user_balance(user_id)
            if balance < price:
                await callback.answer(f"‚ùå –ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –±–∞–∫—Å–æ–≤! –ù—É–∂–Ω–æ {price:.2f}, —É —Ç–µ–±—è {balance:.2f}", show_alert=True)
                return
            async with conn.transaction():
                success, new_balance, _ = await update_user_balance(user_id, -price, conn=conn, allow_negative=False)
                if not success:
                    await callback.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–ø–∏—Å–∞–Ω–∏–∏ —Å—Ä–µ–¥—Å—Ç–≤.", show_alert=True)
                    return
                await update_user_total_spent(user_id, price)
                await conn.execute(
                    "INSERT INTO purchases (user_id, item_id, purchase_date) VALUES ($1, $2, $3)",
                    user_id, item_id, datetime.now()
                )
                if stock != -1:
                    await conn.execute("UPDATE shop_items SET stock = stock - 1 WHERE id=$1", item_id)

        phrase = "‚úÖ –ö—É–ø–ª–µ–Ω–æ! –ê–¥–º–∏–Ω —Å–∫–æ—Ä–æ —Å–≤—è–∂–µ—Ç—Å—è."
        await callback.answer(f"‚úÖ –¢—ã –∫—É–ø–∏–ª {name}! {phrase}", show_alert=True)

        if await get_setting("chat_notify_big_purchase") == "1" and price >= BIG_PURCHASE_THRESHOLD:
            user = callback.from_user
            chat_phrase = f"üõí {user.first_name} –∫—É–ø–∏–ª {name} –∑–∞ {price:.2f} –±–∞–∫—Å–æ–≤!"
            await notify_chats(chat_phrase)

        asyncio.create_task(notify_admins_about_purchase(callback.from_user, name, price))
        await send_with_media(user_id, f"‚úÖ –ü–æ–∫—É–ø–∫–∞ —Å–æ–≤–µ—Ä—à–µ–Ω–∞! {phrase}", media_key='purchase')
        await callback.message.delete()
        await callback.answer()

    except ValueError:
        await callback.answer("‚ùå –û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ –¥–∞–Ω–Ω—ã—Ö", show_alert=True)
    except Exception as e:
        logging.error(f"Purchase error: {e}")
        await callback.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∫—É–ø–∫–µ. –ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.", show_alert=True)

async def notify_admins_about_purchase(user: types.User, item_name: str, price: float):
    admins = SUPER_ADMINS.copy()
    async with db_pool.acquire() as conn:
        rows = await conn.fetch("SELECT user_id FROM admins")
        admins.extend([r['user_id'] for r in rows])
    text = f"üõç –ù–æ–≤–∞—è –ø–æ–∫—É–ø–∫–∞!\n–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user.first_name} (ID: {user.id})\n–¢–æ–≤–∞—Ä: {item_name}\n–¶–µ–Ω–∞: {price:.2f} –±–∞–∫—Å–æ–≤"
    for admin_id in admins:
        await safe_send_message(admin_id, text)

# ==================== –ú–û–ò –ü–û–ö–£–ü–ö–ò ====================
@dp.message(F.text == "üí∞ –ú–æ–∏ –ø–æ–∫—É–ø–∫–∏")
async def my_purchases(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        return
    await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)
    ok, not_subscribed = await check_subscription(user_id)
    if not ok:
        await message.answer("‚ùóÔ∏è –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã.", reply_markup=subscription_inline(not_subscribed))
        return
    
    page = 1
    try:
        parts = message.text.split()
        if len(parts) > 1:
            page = int(parts[1])
    except:
        pass
    
    offset = (page - 1) * ITEMS_PER_PAGE
    async with db_pool.acquire() as conn:
        total = await conn.fetchval("SELECT COUNT(*) FROM purchases WHERE user_id=$1", user_id)
        rows = await conn.fetch(
            "SELECT p.id, s.name, p.purchase_date, p.status, p.admin_comment FROM purchases p "
            "JOIN shop_items s ON p.item_id = s.id WHERE p.user_id=$1 ORDER BY p.purchase_date DESC LIMIT $2 OFFSET $3",
            user_id, ITEMS_PER_PAGE, offset
        )
    
    if not rows:
        await message.answer("–£ —Ç–µ–±—è –ø–æ–∫–∞ –Ω–µ—Ç –ø–æ–∫—É–ø–æ–∫.", reply_markup=main_menu_keyboard(await is_admin(user_id)))
        return
    
    text = f"üì¶ –¢–≤–æ–∏ –ø–æ–∫—É–ø–∫–∏ (—Å—Ç—Ä–∞–Ω–∏—Ü–∞ {page}):\n\n"
    for row in rows:
        pid, name, date, status, comment = row['id'], row['name'], row['purchase_date'].strftime("%Y-%m-%d %H:%M:%S"), row['status'], row['admin_comment']
        status_emoji = "‚è≥" if status == 'pending' else "‚úÖ" if status == 'completed' else "‚ùå"
        text += f"{status_emoji} {name} –æ—Ç {date}\n"
        if comment:
            text += f"   –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π: {comment}\n"
        text += "\n"
    
    kb = []
    nav_buttons = []
    if page > 1:
        nav_buttons.append(InlineKeyboardButton(text="‚¨ÖÔ∏è", callback_data=f"mypurchases_page_{page-1}"))
    if offset + ITEMS_PER_PAGE < total:
        nav_buttons.append(InlineKeyboardButton(text="‚û°Ô∏è", callback_data=f"mypurchases_page_{page+1}"))
    if nav_buttons:
        kb.append(nav_buttons)
    
    if kb:
        await message.answer(text, reply_markup=InlineKeyboardMarkup(inline_keyboard=kb))
    else:
        await message.answer(text, reply_markup=main_menu_keyboard(await is_admin(user_id)))

@dp.callback_query(F.data.startswith("mypurchases_page_"))
async def mypurchases_page_callback(callback: CallbackQuery):
    page = int(callback.data.split("_")[2])
    # –°–æ–∑–¥–∞—ë–º –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –æ–±–Ω–æ–≤–ª—ë–Ω–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ–π
    await my_purchases(callback.message)
    await callback.answer()

# ==================== –ü–†–û–ú–û–ö–û–î ====================
@dp.message(F.text == "üéü –ü—Ä–æ–º–æ–∫–æ–¥")
async def promo_handler(message: Message, state: FSMContext):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        return
    await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)
    ok, not_subscribed = await check_subscription(user_id)
    if not ok:
        await message.answer("‚ùóÔ∏è –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã.", reply_markup=subscription_inline(not_subscribed))
        return
    await send_with_media(user_id, "–í–≤–µ–¥–∏ –ø—Ä–æ–º–æ–∫–æ–¥:", media_key='promo', reply_markup=back_keyboard())
    await PromoActivate.code.set()

@dp.message(PromoActivate.code, F.text)
async def promo_activate(message: Message, state: FSMContext):
    if message.chat.type != 'private':
        await state.clear()
        return
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await message.answer("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=main_menu_keyboard(await is_admin(message.from_user.id)))
        return
    code = message.text.strip().upper()
    user_id = message.from_user.id
    ok, not_subscribed = await check_subscription(user_id)
    if not ok:
        await message.answer("‚ùóÔ∏è –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã.", reply_markup=subscription_inline(not_subscribed))
        await state.clear()
        return
    success, msg = await activate_promocode(user_id, code)
    await message.answer(msg, reply_markup=main_menu_keyboard(await is_admin(user_id)))
    await state.clear()

# ==================== –û–ì–†–ê–ë–õ–ï–ù–ò–ï ====================
async def perform_theft(message: Message, robber_id: int, victim_id: int, cost: float = 0):
    success_chance = await get_theft_success_chance(robber_id)
    defense_chance = await get_defense_chance(victim_id)
    defense_penalty = await get_setting_int("theft_defense_penalty")
    min_amount = await get_setting_float("min_theft_amount")
    max_amount = await get_setting_float("max_theft_amount")
    bitcoin_reward = await get_setting_int("bitcoin_per_theft")

    async with db_pool.acquire() as conn:
        async with conn.transaction():
            await conn.execute("SET LOCAL statement_timeout = '5s'")
            robber_balance = await get_user_balance(robber_id)
            if robber_balance < cost:
                await message.answer("üòï –£ —Ç–µ–±—è –Ω–µ—Ç –±–∞–∫—Å–æ–≤ –Ω–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫—É –∫ –∫—Ä–∞–∂–µ!", reply_markup=main_menu_keyboard(await is_admin(robber_id)))
                return

            victim_row = await conn.fetchrow("SELECT balance, username, first_name FROM users WHERE user_id=$1", victim_id)
            if not victim_row:
                await message.answer("‚ùå –¶–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –±–∞–∑–µ.")
                return
            victim_balance = float(victim_row['balance'])
            victim_username = victim_row['username']
            victim_first = victim_row['first_name']
            victim_name = victim_first if victim_first else str(victim_id)

            # –°–ø–∏—Å—ã–≤–∞–µ–º —Å—Ç–æ–∏–º–æ—Å—Ç—å –∞—Ç–∞–∫–∏
            if cost > 0:
                success, new_balance, _ = await update_user_balance(robber_id, -cost, conn=conn, allow_negative=False)
                if not success:
                    await message.answer("üòï –ù–µ —É–¥–∞–ª–æ—Å—å —Å–ø–∏—Å–∞—Ç—å —Å—Ç–æ–∏–º–æ—Å—Ç—å –∞—Ç–∞–∫–∏.")
                    return

            defense_triggered = random.random() * 100 <= defense_chance
            if defense_triggered:
                penalty = min(defense_penalty, robber_balance)
                if penalty > 0:
                    await update_user_balance(robber_id, -penalty, conn=conn, allow_negative=False)
                    await update_user_balance(victim_id, penalty, conn=conn, allow_negative=False)
                await conn.execute("UPDATE users SET theft_attempts = theft_attempts + 1, theft_failed = theft_failed + 1 WHERE user_id=$1", robber_id)
                await conn.execute("UPDATE users SET theft_protected = theft_protected + 1 WHERE user_id=$1", victim_id)
                await conn.execute("UPDATE users SET last_theft_time = $1 WHERE user_id=$2", datetime.now(), robber_id)

                exp_defense = await get_setting_int("exp_per_theft_defense")
                level_up_msg_v = await add_exp(victim_id, exp_defense, conn=conn)
                exp_fail = await get_setting_int("exp_per_theft_fail")
                level_up_msg_r = await add_exp(robber_id, exp_fail, conn=conn)
                if level_up_msg_v:
                    asyncio.create_task(safe_send_message(victim_id, level_up_msg_v))
                if level_up_msg_r:
                    asyncio.create_task(safe_send_message(robber_id, level_up_msg_r))

                robber_phrase = f"üõ°Ô∏è {victim_name} –æ—Ç—Ä–∞–∑–∏–ª –∞—Ç–∞–∫—É! –¢—ã –ø–æ—Ç–µ—Ä—è–ª {penalty} –±–∞–∫—Å–æ–≤."
                victim_phrase = f"üõ°Ô∏è –¢–≤–æ—è –∑–∞—â–∏—Ç–∞ —Å—Ä–∞–±–æ—Ç–∞–ª–∞! {message.from_user.first_name} –Ω–∏—á–µ–≥–æ –Ω–µ —É–∫—Ä–∞–ª –∏ –ø–æ—Ç–µ—Ä—è–ª {penalty} –±–∞–∫—Å–æ–≤."
                await message.answer(robber_phrase, reply_markup=main_menu_keyboard(await is_admin(robber_id)))
                await safe_send_message(victim_id, victim_phrase)
                return

            success = random.random() * 100 <= success_chance
            if success and victim_balance > 0:
                if victim_balance < min_amount:
                    steal_amount = 0
                else:
                    max_possible = min(max_amount, victim_balance)
                    steal_amount = round(random.uniform(min_amount, max_possible), 2)

                if steal_amount > 0:
                    await update_user_balance(victim_id, -steal_amount, conn=conn, allow_negative=False)
                    await update_user_balance(robber_id, steal_amount, conn=conn, allow_negative=False)
                    if bitcoin_reward > 0:
                        await update_user_bitcoin(robber_id, float(bitcoin_reward), conn=conn)
                    await conn.execute("UPDATE users SET theft_attempts = theft_attempts + 1, theft_success = theft_success + 1 WHERE user_id=$1", robber_id)

                    exp_success = await get_setting_int("exp_per_theft_success")
                    level_up_msg_r = await add_exp(robber_id, exp_success, conn=conn)
                    if level_up_msg_r:
                        asyncio.create_task(safe_send_message(robber_id, level_up_msg_r))

                    required_thefts = await get_setting_int("referral_required_thefts")
                    new_success = await conn.fetchval("SELECT theft_success FROM users WHERE user_id=$1", robber_id)
                    if new_success >= required_thefts:
                        ref = await conn.fetchrow("SELECT referrer_id FROM referrals WHERE referred_id=$1 AND reward_given=FALSE", robber_id)
                        if ref:
                            referrer_id = ref['referrer_id']
                            bonus_coins = await get_setting_float("referral_bonus")
                            bonus_rep = await get_setting_int("referral_reputation")
                            await update_user_balance(referrer_id, bonus_coins, conn=conn, allow_negative=False)
                            await update_user_reputation(referrer_id, bonus_rep)
                            await conn.execute("UPDATE referrals SET reward_given=TRUE WHERE referred_id=$1", robber_id)
                            await conn.execute("UPDATE referrals SET active=TRUE WHERE referred_id=$1", robber_id)
                            await safe_send_message(referrer_id, f"üéâ –í–∞—à —Ä–µ—Ñ–µ—Ä–∞–ª —Å–æ–≤–µ—Ä—à–∏–ª {required_thefts} —É—Å–ø–µ—à–Ω—ã—Ö –æ–≥—Ä–∞–±–ª–µ–Ω–∏–π! –í—ã –ø–æ–ª—É—á–∏–ª–∏ {bonus_coins:.2f} –±–∞–∫—Å–æ–≤ –∏ {bonus_rep} —Ä–µ–ø—É—Ç–∞—Ü–∏–∏.")

                    btc_text = f" –∏ {bitcoin_reward} BTC" if bitcoin_reward > 0 else ""
                    phrase = f"üî´ –û—Ç–ª–∏—á–Ω–æ! –¢—ã —É–∫—Ä–∞–ª {steal_amount} –±–∞–∫—Å–æ–≤ —É {victim_name}!"
                    await message.answer(f"{phrase}{btc_text}", reply_markup=main_menu_keyboard(await is_admin(robber_id)))
                    await safe_send_message(victim_id, f"üî´ –í–∞—Å –æ–≥—Ä–∞–±–∏–ª–∏! {message.from_user.first_name} —É–∫—Ä–∞–ª {steal_amount:.2f} –±–∞–∫—Å–æ–≤.")
                else:
                    await conn.execute("UPDATE users SET theft_attempts = theft_attempts + 1, theft_failed = theft_failed + 1 WHERE user_id=$1", robber_id)
                    exp_fail = await get_setting_int("exp_per_theft_fail")
                    level_up_msg_r = await add_exp(robber_id, exp_fail, conn=conn)
                    if level_up_msg_r:
                        asyncio.create_task(safe_send_message(robber_id, level_up_msg_r))
                    phrase = f"üò¢ –û–±–ª–æ–º, —Ç–µ–±—è —Å–ø–∞–ª–∏–ª–∏! –ù–∏—á–µ–≥–æ –Ω–µ —É–∫—Ä–∞–ª."
                    await message.answer(phrase, reply_markup=main_menu_keyboard(await is_admin(robber_id)))
            else:
                await conn.execute("UPDATE users SET theft_attempts = theft_attempts + 1, theft_failed = theft_failed + 1 WHERE user_id=$1", robber_id)
                exp_fail = await get_setting_int("exp_per_theft_fail")
                level_up_msg_r = await add_exp(robber_id, exp_fail, conn=conn)
                if level_up_msg_r:
                    asyncio.create_task(safe_send_message(robber_id, level_up_msg_r))
                phrase = f"üò¢ –û–±–ª–æ–º, —Ç–µ–±—è —Å–ø–∞–ª–∏–ª–∏! –ù–∏—á–µ–≥–æ –Ω–µ —É–∫—Ä–∞–ª."
                await message.answer(phrase, reply_markup=main_menu_keyboard(await is_admin(robber_id)))

            await conn.execute("UPDATE users SET last_theft_time = $1 WHERE user_id=$2", datetime.now(), robber_id)

@dp.message(F.text == "üî´ –û–≥—Ä–∞–±–∏—Ç—å")
async def theft_menu(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        return
    await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)
    ok, not_subscribed = await check_subscription(user_id)
    if not ok:
        await message.answer("‚ùóÔ∏è –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã.", reply_markup=subscription_inline(not_subscribed))
        return
    phrase = "üî´ –í—ã–±–µ—Ä–∏ —Ü–µ–ª—å:"
    await send_with_media(user_id, phrase, media_key='theft', reply_markup=theft_choice_keyboard())

@dp.message(F.text == "üé≤ –°–ª—É—á–∞–π–Ω–∞—è —Ü–µ–ª—å")
async def theft_random(message: Message, state: FSMContext):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    cooldown_minutes = await get_setting_int("theft_cooldown_minutes")
    async with db_pool.acquire() as conn:
        last_time_str = await conn.fetchval("SELECT last_theft_time FROM users WHERE user_id=$1", user_id)
        if last_time_str:
            last_time = last_time_str  # —ç—Ç–æ —É–∂–µ datetime
            diff = datetime.now() - last_time
            if diff < timedelta(minutes=cooldown_minutes):
                remaining = cooldown_minutes - int(diff.total_seconds() // 60)
                phrase = f"‚è≥ –¢—ã –µ—â—ë –Ω–µ –æ—Å—Ç—ã–ª. –ü–æ–¥–æ–∂–¥–∏ {remaining} –º–∏–Ω."
                await message.answer(phrase, reply_markup=main_menu_keyboard(await is_admin(user_id)))
                return
    target_id = await get_random_user(user_id)
    if not target_id:
        await message.answer("üòï –í –∏–≥—Ä–µ –ø–æ–∫–∞ –Ω–µ—Ç –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤.", reply_markup=main_menu_keyboard(await is_admin(user_id)))
        return
    cost = await get_setting_float("random_attack_cost")
    await perform_theft(message, user_id, target_id, cost)

@dp.message(F.text == "üë§ –í—ã–±—Ä–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
async def theft_choose_user(message: Message, state: FSMContext):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    cooldown_minutes = await get_setting_int("theft_cooldown_minutes")
    async with db_pool.acquire() as conn:
        last_time_str = await conn.fetchval("SELECT last_theft_time FROM users WHERE user_id=$1", user_id)
        if last_time_str:
            last_time = last_time_str
            diff = datetime.now() - last_time
            if diff < timedelta(minutes=cooldown_minutes):
                remaining = cooldown_minutes - int(diff.total_seconds() // 60)
                phrase = f"‚è≥ –¢—ã –µ—â—ë –Ω–µ –æ—Å—Ç—ã–ª. –ü–æ–¥–æ–∂–¥–∏ {remaining} –º–∏–Ω."
                await message.answer(phrase, reply_markup=main_menu_keyboard(await is_admin(user_id)))
                return
    await message.answer("–í–≤–µ–¥–∏ @username –∏–ª–∏ ID —Ç–æ–≥–æ, –∫–æ–≥–æ —Ö–æ—á–µ—à—å –æ–≥—Ä–∞–±–∏—Ç—å:", reply_markup=back_keyboard())
    await TheftTarget.target.set()

@dp.message(TheftTarget.target, F.text)
async def theft_target_entered(message: Message, state: FSMContext):
    if message.chat.type != 'private':
        await state.clear()
        return
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await message.answer("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=main_menu_keyboard(await is_admin(message.from_user.id)))
        return
    target_input = message.text.strip()
    robber_id = message.from_user.id

    target_data = await find_user_by_input(target_input)
    if not target_data:
        await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å username –∏–ª–∏ ID.")
        await state.clear()
        return
    target_id = target_data['user_id']

    if target_id == robber_id:
        await message.answer("–°–∞–º —Å–µ–±—è –Ω–µ –æ–≥—Ä–∞–±–∏—à—å, –±—Ä–æ! üòÜ")
        await state.clear()
        return

    if await is_banned(target_id):
        await message.answer("‚ùå –≠—Ç–æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ü–µ–ª—å—é.")
        await state.clear()
        return

    cost = await get_setting_float("targeted_attack_cost")
    await perform_theft(message, robber_id, target_id, cost)
    await state.clear()

# ==================== –†–ï–§–ï–†–ê–õ–¨–ù–ê–Ø –°–°–´–õ–ö–ê ====================
@dp.message(F.text == "üîó –†–µ—Ñ–µ—Ä–∞–ª–∫–∞")
async def referral_link(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    bot_username = (await bot.me()).username
    link = f"https://t.me/{bot_username}?start=ref{user_id}"
    bonus_coins = await get_setting_float("referral_bonus")
    bonus_rep = await get_setting_int("referral_reputation")
    required_thefts = await get_setting_int("referral_required_thefts")

    async with db_pool.acquire() as conn:
        clicks = await conn.fetchval("SELECT SUM(clicks) FROM referrals WHERE referrer_id=$1", user_id) or 0
        active = await conn.fetchval("SELECT COUNT(*) FROM referrals WHERE referrer_id=$1 AND active=TRUE", user_id) or 0
        earned = active * bonus_coins

    text = (
        f"üîó –¢–≤–æ—è —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞:\n{link}\n\n"
        f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n"
        f"‚Ä¢ –ü–µ—Ä–µ—Ö–æ–¥–æ–≤: {clicks}\n"
        f"‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤: {active}\n"
        f"‚Ä¢ –ó–∞—Ä–∞–±–æ—Ç–∞–Ω–æ –±–∞–∫—Å–æ–≤: {earned:.2f}\n\n"
        f"–ë–æ–Ω—É—Å: {bonus_coins:.2f} –±–∞–∫—Å–æ–≤ –∏ {bonus_rep} —Ä–µ–ø—É—Ç–∞—Ü–∏–∏ –∑–∞ –∫–∞–∂–¥–æ–≥–æ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ä–µ—Ñ–µ—Ä–∞–ª–∞ ({required_thefts} —É—Å–ø–µ—à–Ω—ã—Ö –∫—Ä–∞–∂)."
    )
    await send_with_media(user_id, text, media_key='referral', reply_markup=main_menu_keyboard(await is_admin(user_id)))

# ==================== –ó–ê–î–ê–ù–ò–Ø (–ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–¨–°–ö–ê–Ø –ß–ê–°–¢–¨) ====================
@dp.message(F.text == "üìã –ó–∞–¥–∞–Ω–∏—è")
async def tasks_user_menu(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        return
    await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)
    ok, not_subscribed = await check_subscription(user_id)
    if not ok:
        await message.answer("‚ùóÔ∏è –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã.", reply_markup=subscription_inline(not_subscribed))
        return

    async with db_pool.acquire() as conn:
        rows = await conn.fetch("SELECT id, name, description, reward_coins, reward_reputation, max_completions, completed_count, media_file_id, media_type, button_link FROM tasks WHERE active=TRUE")
    if not rows:
        await message.answer("üìã –ü–æ–∫–∞ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∑–∞–¥–∞–Ω–∏–π.", reply_markup=main_menu_keyboard(await is_admin(user_id)))
        return

    text = "üìã –î–æ—Å—Ç—É–ø–Ω—ã–µ –∑–∞–¥–∞–Ω–∏—è:\n\n"
    kb = []
    for row in rows:
        progress = f" (–≤—ã–ø–æ–ª–Ω–µ–Ω–æ {row['completed_count']}/{row['max_completions']})" if row['max_completions'] > 1 else ""
        text += f"üîπ {row['name']}{progress}\n{row['description']}\n–ù–∞–≥—Ä–∞–¥–∞: {float(row['reward_coins']):.2f} –±–∞–∫—Å–æ–≤, {row['reward_reputation']} —Ä–µ–ø—É—Ç–∞—Ü–∏–∏\n\n"
        kb.append([InlineKeyboardButton(text=f"üìå {row['name']}", callback_data=f"task_detail_{row['id']}")])
    await send_with_media(message.chat.id, text, media_key='tasks', reply_markup=InlineKeyboardMarkup(inline_keyboard=kb))

@dp.callback_query(F.data.startswith("task_detail_"))
async def task_detail_callback(callback: CallbackQuery):
    task_id = int(callback.data.split("_")[2])
    user_id = callback.from_user.id

    async with db_pool.acquire() as conn:
        task = await conn.fetchrow("SELECT * FROM tasks WHERE id=$1 AND active=TRUE", task_id)
        if not task:
            await callback.answer("‚ùå –ó–∞–¥–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –∏–ª–∏ –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ.", show_alert=True)
            return

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ –ª–∏ —É–∂–µ
        completed = await conn.fetchval("SELECT 1 FROM user_tasks WHERE user_id=$1 AND task_id=$2", user_id, task_id)
        if completed:
            await callback.answer("‚úÖ –¢—ã —É–∂–µ –≤—ã–ø–æ–ª–Ω–∏–ª —ç—Ç–æ –∑–∞–¥–∞–Ω–∏–µ!", show_alert=True)
            return

    text = (
        f"üìå <b>{task['name']}</b>\n\n"
        f"{task['description']}\n\n"
        f"–ù–∞–≥—Ä–∞–¥–∞: {float(task['reward_coins']):.2f} –±–∞–∫—Å–æ–≤, {task['reward_reputation']} —Ä–µ–ø—É—Ç–∞—Ü–∏–∏\n"
        f"–û—Å—Ç–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–π: {task['max_completions'] - task['completed_count'] if task['max_completions'] > 0 else '‚àû'}\n\n"
        f"–î–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –Ω–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –∏ –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª, –∑–∞—Ç–µ–º –ø—Ä–æ–≤–µ—Ä—å –ø–æ–¥–ø–∏—Å–∫—É."
    )

    if task['media_file_id'] and task['media_type'] == 'photo':
        await callback.message.delete()
        await callback.message.answer_photo(
            task['media_file_id'],
            caption=text,
            reply_markup=task_detail_keyboard(task_id, task['button_link'])
        )
    else:
        await callback.message.edit_text(text, reply_markup=task_detail_keyboard(task_id, task['button_link']))
    await callback.answer()

@dp.callback_query(F.data.startswith("check_task_"))
async def check_task_callback(callback: CallbackQuery):
    task_id = int(callback.data.split("_")[2])
    user_id = callback.from_user.id

    async with db_pool.acquire() as conn:
        task = await conn.fetchrow("SELECT * FROM tasks WHERE id=$1 AND active=TRUE", task_id)
        if not task:
            await callback.answer("‚ùå –ó–∞–¥–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", show_alert=True)
            return

        if task['task_type'] == 'subscribe':
            channel_id = task['target_id']
            subscribed = await check_user_subscription(user_id, channel_id)
            if not subscribed:
                await callback.answer("‚ùå –¢—ã –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω –Ω–∞ —ç—Ç–æ—Ç –∫–∞–Ω–∞–ª! –ü–æ–¥–ø–∏—à–∏—Å—å –∏ –ø–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.", show_alert=True)
                return

            success, msg = await complete_task(user_id, task_id)
            await callback.answer(msg, show_alert=True)
            if success:
                await callback.message.delete()
        else:
            await callback.answer("‚ùå –ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ç–∏–ø –∑–∞–¥–∞–Ω–∏—è.", show_alert=True)

@dp.callback_query(F.data == "tasks_back")
async def tasks_back_callback(callback: CallbackQuery):
    await tasks_user_menu(callback.message)
    await callback.answer()

# ==================== –ë–ò–ó–ù–ï–°–´ (–ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–¨–°–ö–ê–Ø –ß–ê–°–¢–¨) ====================
@dp.message(F.text == "üè™ –ú–æ–∏ –±–∏–∑–Ω–µ—Å—ã")
async def my_businesses(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        return
    await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)
    ok, not_subscribed = await check_subscription(user_id)
    if not ok:
        await message.answer("‚ùóÔ∏è –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã.", reply_markup=subscription_inline(not_subscribed))
        return

    businesses = await get_user_businesses(user_id)
    max_businesses = await get_setting_int("business_max_businesses")

    if not businesses:
        kb = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="üè™ –ö—É–ø–∏—Ç—å –±–∏–∑–Ω–µ—Å", callback_data="buy_business_menu")]
        ])
        await send_with_media(user_id, f"üì≠ –£ —Ç–µ–±—è –ø–æ–∫–∞ –Ω–µ—Ç –±–∏–∑–Ω–µ—Å–æ–≤.\nüìä –î–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è –ø–æ–∫—É–ø–∫–∏: 0/{max_businesses}", media_key='business', reply_markup=kb)
        return

    total_income_per_hour = 0
    for biz in businesses:
        total_income_per_hour += float(biz['base_income_per_hour']) * biz['level']

    text = (
        f"üè™ <b>–ú–æ–∏ –±–∏–∑–Ω–µ—Å—ã</b>\n"
        f"üìä –ö—É–ø–ª–µ–Ω–æ: {len(businesses)}/{max_businesses}\n"
        f"üí∞ –û–±—â–∏–π –¥–æ—Ö–æ–¥: <b>{total_income_per_hour:.2f} $/—á–∞—Å</b>\n\n"
        f"üëá –í—ã–±–µ—Ä–∏ –±–∏–∑–Ω–µ—Å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è:"
    )

    kb = business_main_keyboard(businesses)
    await send_with_media(user_id, text, media_key='business', reply_markup=kb)

@dp.callback_query(F.data == "buy_business_menu")
async def buy_business_menu(callback: CallbackQuery):
    user_id = callback.from_user.id
    all_types = await get_business_type_list(only_available=True)
    async with db_pool.acquire() as conn:
        owned = await conn.fetch("SELECT business_type_id FROM user_businesses WHERE user_id=$1", user_id)
        owned_ids = [r['business_type_id'] for r in owned]
    max_businesses = await get_setting_int("business_max_businesses")
    available = [bt for bt in all_types if bt['id'] not in owned_ids]

    if not available:
        await callback.answer("üéâ –¢—ã —É–∂–µ –∫—É–ø–∏–ª –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –±–∏–∑–Ω–µ—Å—ã!", show_alert=True)
        return

    text = (
        f"üè™ <b>–ü–æ–∫—É–ø–∫–∞ –±–∏–∑–Ω–µ—Å–∞</b>\n"
        f"üìä –ö—É–ø–ª–µ–Ω–æ: {len(owned_ids)}/{max_businesses}\n"
        f"üí∞ –î–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è –ø–æ–∫—É–ø–∫–∏: {len(available)}/{max_businesses - len(owned_ids)}\n\n"
        f"üëá –í—ã–±–µ—Ä–∏ –±–∏–∑–Ω–µ—Å –¥–ª—è –ø–æ–∫—É–ø–∫–∏:"
    )
    kb = business_buy_keyboard(available)
    await callback.message.edit_text(text, reply_markup=kb)
    await callback.answer()

@dp.callback_query(F.data.startswith("bizbuy_preview_"))
async def bizbuy_preview(callback: CallbackQuery, state: FSMContext):
    biz_type_id = int(callback.data.split("_")[2])
    user_id = callback.from_user.id

    biz_type = await get_business_type(biz_type_id)
    if not biz_type:
        await callback.answer("‚ùå –ë–∏–∑–Ω–µ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
        return

    existing = await get_user_business(user_id, biz_type_id)
    if existing:
        await callback.answer("‚ùå –£ —Ç–µ–±—è —É–∂–µ –µ—Å—Ç—å —Ç–∞–∫–æ–π –±–∏–∑–Ω–µ—Å!", show_alert=True)
        return

    max_businesses = await get_setting_int("business_max_businesses")
    async with db_pool.acquire() as conn:
        count = await conn.fetchval("SELECT COUNT(*) FROM user_businesses WHERE user_id=$1", user_id)

    if count >= max_businesses:
        await callback.answer(f"‚ùå –¢—ã —É–∂–µ –∫—É–ø–∏–ª –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–∏–∑–Ω–µ—Å–æ–≤ ({max_businesses})!", show_alert=True)
        return

    btc_balance = await get_user_bitcoin(user_id)
    price = float(biz_type['base_price_btc'])

    text = (
        f"{biz_type['emoji']} <b>{biz_type['name']}</b>\n"
        f"üìù {biz_type['description']}\n\n"
        f"üí∞ –¶–µ–Ω–∞: {price:.2f} BTC\n"
        f"üìä –î–æ—Ö–æ–¥: {biz_type['base_income_per_hour']} $/—á–∞—Å\n"
        f"üìà –ú–∞–∫—Å. —É—Ä–æ–≤–µ–Ω—å: {biz_type['max_level']}\n"
        f"‚è≥ –°—Ä–æ–∫ –∂–∏–∑–Ω–∏: {biz_type['lifetime_hours']} —á\n\n"
        f"–¢–≤–æ–π –±–∞–ª–∞–Ω—Å: {btc_balance:.4f} BTC\n"
        f"–ü–æ—Å–ª–µ –ø–æ–∫—É–ø–∫–∏ –æ—Å—Ç–∞–Ω–µ—Ç—Å—è: {(btc_balance - price):.4f} BTC\n\n"
        f"–ö—É–ø–∏—Ç—å —ç—Ç–æ—Ç –±–∏–∑–Ω–µ—Å?"
    )

    image_key = biz_type.get('image_key')
    file_id = None
    if image_key:
        file_id = await get_media_file_id(image_key)

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úÖ –ö—É–ø–∏—Ç—å", callback_data=f"bizbuy_confirm_{biz_type_id}")],
        [InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="buy_business_menu")]
    ])

    await state.update_data(biz_type_id=biz_type_id, price=price, biz_name=biz_type['name'], biz_emoji=biz_type['emoji'], lifetime=biz_type['lifetime_hours'])

    if file_id:
        await callback.message.delete()
        await callback.message.answer_photo(file_id, caption=text, reply_markup=kb)
    else:
        await callback.message.edit_text(text, reply_markup=kb)
    await callback.answer()

@dp.callback_query(F.data.startswith("bizbuy_confirm_"))
async def bizbuy_confirm(callback: CallbackQuery, state: FSMContext):
    biz_type_id = int(callback.data.split("_")[2])
    user_id = callback.from_user.id

    data = await state.get_data()
    if data.get('biz_type_id') != biz_type_id:
        await callback.answer("‚ùå –î–∞–Ω–Ω—ã–µ —É—Å—Ç–∞—Ä–µ–ª–∏, –ø–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞", show_alert=True)
        await state.clear()
        return

    # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—É—é —Ü–µ–Ω—É –∏–∑ –±–∞–∑—ã
    biz_type = await get_business_type(biz_type_id)
    if not biz_type:
        await callback.answer("‚ùå –ë–∏–∑–Ω–µ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
        await state.clear()
        return
    price = float(biz_type['base_price_btc'])
    biz_name = biz_type['name']
    lifetime = biz_type['lifetime_hours']

    try:
        async with db_pool.acquire() as conn:
            async with conn.transaction():
                await conn.execute("SET LOCAL statement_timeout = '5s'")
                btc = await get_user_bitcoin(user_id)
                if btc < price - 0.0001:
                    await callback.answer(f"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ BTC. –ù—É–∂–Ω–æ {price:.2f}, —É —Ç–µ–±—è {btc:.4f}", show_alert=True)
                    await state.clear()
                    return

                max_businesses = await get_setting_int("business_max_businesses")
                count = await conn.fetchval("SELECT COUNT(*) FROM user_businesses WHERE user_id=$1", user_id)
                if count >= max_businesses:
                    await callback.answer(f"‚ùå –õ–∏–º–∏—Ç –±–∏–∑–Ω–µ—Å–æ–≤ ({max_businesses}) –∏—Å—á–µ—Ä–ø–∞–Ω!", show_alert=True)
                    await state.clear()
                    return

                existing = await conn.fetchval("SELECT id FROM user_businesses WHERE user_id=$1 AND business_type_id=$2", user_id, biz_type_id)
                if existing:
                    await callback.answer("‚ùå –£ —Ç–µ–±—è —É–∂–µ –µ—Å—Ç—å —Ç–∞–∫–æ–π –±–∏–∑–Ω–µ—Å!", show_alert=True)
                    await state.clear()
                    return

                await update_user_bitcoin(user_id, -price, conn=conn)
                await create_user_business(user_id, biz_type_id, lifetime)

        await callback.answer(f"‚úÖ –¢—ã –ø—Ä–∏–æ–±—Ä—ë–ª –±–∏–∑–Ω–µ—Å ¬´{biz_name}¬ª!", show_alert=True)
        await callback.message.delete()
        await my_businesses(callback.message)
    except Exception as e:
        logging.error(f"Buy business error: {e}")
        await callback.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∫—É–ø–∫–µ –±–∏–∑–Ω–µ—Å–∞.", show_alert=True)
    await state.clear()

@dp.callback_query(F.data == "bizbuy_cancel")
async def bizbuy_cancel(callback: CallbackQuery):
    await callback.message.delete()
    await my_businesses(callback.message)
    await callback.answer()

@dp.callback_query(F.data.startswith("biz_view_"))
async def business_view(callback: CallbackQuery):
    biz_id = int(callback.data.split("_")[2])
    user_id = callback.from_user.id

    async with db_pool.acquire() as conn:
        biz = await conn.fetchrow("""
            SELECT ub.*, bt.name, bt.emoji, bt.base_price_btc, bt.base_income_per_hour, 
                   bt.max_level, bt.image_key, bt.description
            FROM user_businesses ub
            JOIN business_types bt ON ub.business_type_id = bt.id
            WHERE ub.id = $1 AND ub.user_id = $2
        """, biz_id, user_id)

        if not biz:
            await callback.answer("‚ùå –ë–∏–∑–Ω–µ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
            return

    collect_interval = await get_setting_int("business_collect_interval_minutes")
    max_storage_hours = await get_setting_int("business_max_storage_hours")

    last_col = biz['last_collection']
    if last_col:
        last_date = last_col
    else:
        last_date = datetime.now() - timedelta(days=365)

    minutes_passed = int((datetime.now() - last_date).total_seconds() / 60)
    max_storage_minutes = max_storage_hours * 60
    collectable_minutes = min(minutes_passed, max_storage_minutes)

    income_per_hour = float(biz['base_income_per_hour']) * biz['level']
    available = income_per_hour * (collectable_minutes / 60)
    available = round(available, 2)

    next_collect = last_date + timedelta(minutes=collect_interval)
    if next_collect > datetime.now():
        wait_minutes = int((next_collect - datetime.now()).total_seconds() / 60)
        next_collect_text = f"‚è≥ –î–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å–±–æ—Ä–∞: {wait_minutes} –º–∏–Ω."
    else:
        next_collect_text = "‚úÖ –ú–æ–∂–Ω–æ —Å–æ–±—Ä–∞—Ç—å –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å!"

    text = (
        f"{biz['emoji']} <b>{biz['name']}</b>\n"
        f"üìù {biz['description']}\n\n"
        f"üìä –£—Ä–æ–≤–µ–Ω—å: {biz['level']}/{biz['max_level']}\n"
        f"üí∞ –î–æ—Ö–æ–¥ –≤ —á–∞—Å: {income_per_hour:.2f} $\n"
        f"üè¶ –ù–∞–∫–æ–ø–ª–µ–Ω–æ: {available} $\n"
        f"{next_collect_text}\n\n"
        f"üìà –°–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å:\n"
    )

    if biz['level'] < biz['max_level']:
        upgrade_cost = await get_business_price({'base_price_btc': biz['base_price_btc']}, biz['level'] + 1)
        next_income = float(biz['base_income_per_hour']) * (biz['level'] + 1)
        text += f"   ‚Ä¢ –î–æ—Ö–æ–¥: {next_income:.2f} $/—á–∞—Å\n"
        text += f"   ‚Ä¢ –°—Ç–æ–∏–º–æ—Å—Ç—å: {upgrade_cost:.2f} BTC"
    else:
        text += "   ‚ö°Ô∏è –î–æ—Å—Ç–∏–≥–Ω—É—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å"

    image_key = biz.get('image_key')
    file_id = None
    if image_key:
        file_id = await get_media_file_id(image_key)

    kb = business_actions_keyboard(biz_id)

    if file_id:
        await callback.message.delete()
        await callback.message.answer_photo(file_id, caption=text, reply_markup=kb)
    else:
        await callback.message.edit_text(text, reply_markup=kb)
    await callback.answer()

@dp.callback_query(F.data.startswith("biz_collect_"))
async def business_collect(callback: CallbackQuery):
    biz_id = int(callback.data.split("_")[2])
    user_id = callback.from_user.id

    success, message_text, amount = await collect_business_income(user_id, biz_id)

    if success:
        await callback.answer(f"‚úÖ {message_text}", show_alert=True)
    else:
        await callback.answer(f"‚ùå {message_text}", show_alert=True)

    await business_view(callback)

@dp.callback_query(F.data.startswith("biz_upgrade_"))
async def business_upgrade(callback: CallbackQuery, state: FSMContext):
    biz_id = int(callback.data.split("_")[2])
    await state.update_data(biz_id=biz_id)
    await callback.message.answer("–¢—ã —É–≤–µ—Ä–µ–Ω, —á—Ç–æ —Ö–æ—á–µ—à—å —É–ª—É—á—à–∏—Ç—å –±–∏–∑–Ω–µ—Å? (–¥–∞/–Ω–µ—Ç)", reply_markup=back_keyboard())
    await UpgradeBusiness.confirming.set()
    await callback.answer()

@dp.message(UpgradeBusiness.confirming, F.text)
async def upgrade_confirm(message: Message, state: FSMContext):
    if message.text.lower() == '–Ω–µ—Ç' or message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await my_businesses(message)
        return
    if message.text.lower() == '–¥–∞':
        data = await state.get_data()
        biz_id = data['biz_id']
        user_id = message.from_user.id
        success, msg = await upgrade_business(user_id, biz_id)
        await message.answer(msg)
        await state.clear()
        await my_businesses(message)
    else:
        await message.answer("–í–≤–µ–¥–∏ '–¥–∞' –∏–ª–∏ '–Ω–µ—Ç'.")

@dp.callback_query(F.data == "biz_back")
async def business_back(callback: CallbackQuery):
    await my_businesses(callback.message)
    await callback.answer()

@dp.callback_query(F.data == "biz_back_to_main")
async def business_back_to_main(callback: CallbackQuery):
    await my_businesses(callback.message)
    await callback.answer()

# ==================== –ë–ò–¢–ö–û–ò–ù-–ë–ò–†–ñ–ê (–ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–¨–°–ö–ê–Ø –ß–ê–°–¢–¨) ====================
@dp.message(F.text == "üíº –ë–∏—Ç–∫–æ–∏–Ω-–±–∏—Ä–∂–∞")
async def bitcoin_exchange_menu(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        return
    await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)
    ok, not_subscribed = await check_subscription(user_id)
    if not ok:
        await message.answer("‚ùóÔ∏è –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã.", reply_markup=subscription_inline(not_subscribed))
        return
    await send_with_media(user_id, "üíº –ë–∏—Ç–∫–æ–∏–Ω-–±–∏—Ä–∂–∞: –ø—Ä–æ–¥–∞–≤–∞–π –∏ –ø–æ–∫—É–ø–∞–π BTC –∑–∞ –±–∞–∫—Å—ã.", media_key='exchange', reply_markup=bitcoin_exchange_keyboard())

@dp.message(F.text == "üìä –°—Ç–∞–∫–∞–Ω –∑–∞—è–≤–æ–∫")
async def exchange_order_book(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    book = await get_order_book()
    text = "üìä <b>–ë–∏—Ä–∂–µ–≤–æ–π —Å—Ç–∞–∫–∞–Ω</b>\n\n"
    text += "üìâ <b>–ü—Ä–æ–¥–∞–∂–∞ (ASK)</b>:\n"
    if book['asks']:
        for ask in book['asks'][:10]:
            text += f"‚Ä¢ {ask['price']} $ | {ask['total_amount']:.4f} BTC ({ask['count']} –∑–∞—è–≤–æ–∫)\n"
    else:
        text += "–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞—è–≤–æ–∫ –Ω–∞ –ø—Ä–æ–¥–∞–∂—É.\n"
    text += "\nüìà <b>–ü–æ–∫—É–ø–∫–∞ (BID)</b>:\n"
    if book['bids']:
        for bid in book['bids'][:10]:
            text += f"‚Ä¢ {bid['price']} $ | {bid['total_amount']:.4f} BTC ({bid['count']} –∑–∞—è–≤–æ–∫)\n"
    else:
        text += "–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞—è–≤–æ–∫ –Ω–∞ –ø–æ–∫—É–ø–∫—É.\n"
    text += "\n–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∏–∂–µ:"
    await message.answer(text, reply_markup=order_book_keyboard(book))

@dp.callback_query(F.data.startswith("buy_from_"))
async def buy_from_price(callback: CallbackQuery, state: FSMContext):
    price = int(callback.data.split("_")[2])
    user_id = callback.from_user.id
    async with db_pool.acquire() as conn:
        orders = await conn.fetch(
            "SELECT * FROM bitcoin_orders WHERE type='sell' AND status='active' AND price=$1 ORDER BY created_at ASC",
            price
        )
    if not orders:
        await callback.answer("–ó–∞—è–≤–æ–∫ –ø–æ —ç—Ç–æ–π —Ü–µ–Ω–µ –±–æ–ª—å—à–µ –Ω–µ—Ç.", show_alert=True)
        return
    orders_list = []
    total_available = 0.0
    for o in orders:
        d = dict(o)
        d['amount'] = float(d['amount'])
        d['total_locked'] = float(d['total_locked'])
        orders_list.append(d)
        total_available += d['amount']
    await state.update_data(price=price, orders=orders_list, total_available=total_available)
    await callback.message.answer(
        f"üìâ –ü—Ä–æ–¥–∞–∂–∞ –ø–æ —Ü–µ–Ω–µ {price} $/BTC. –î–æ—Å—Ç—É–ø–Ω–æ –≤—Å–µ–≥–æ: {total_available:.4f} BTC.\n"
        f"–í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ BTC, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—á–µ—à—å –∫—É–ø–∏—Ç—å (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω–æ–µ):",
        reply_markup=back_keyboard()
    )
    await BuyFromPrice.amount.set()
    await callback.answer()

@dp.message(BuyFromPrice.amount, F.text)
async def buy_from_price_amount(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await bitcoin_exchange_menu(message)
        return
    try:
        amount = float(message.text)
        if amount <= 0:
            raise ValueError
        amount = round(amount, 4)
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.")
        return
    data = await state.get_data()
    price = data['price']
    orders = data['orders']
    total_available = data['total_available']

    min_amount = await get_setting_float("exchange_min_amount_btc")
    if amount < min_amount:
        await message.answer(f"‚ùå –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–ª—è –ø–æ–∫—É–ø–∫–∏: {min_amount} BTC.")
        return

    if amount > total_available + 0.0001:
        await message.answer(f"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ BTC –¥–ª—è –ø–æ–∫—É–ø–∫–∏. –î–æ—Å—Ç—É–ø–Ω–æ {total_available:.4f} BTC.")
        return
    user_id = message.from_user.id
    total_cost = amount * price
    balance = await get_user_balance(user_id)
    if balance < total_cost:
        await message.answer(f"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∞–∫—Å–æ–≤. –ù—É–∂–Ω–æ {total_cost:.2f}.")
        return
    max_input = await get_setting_float("max_input_number")
    if total_cost > max_input:
        await message.answer(f"‚ùå –°—É–º–º–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è (–º–∞–∫—Å–∏–º—É–º {max_input:.2f}).")
        return
    remaining = amount
    async with db_pool.acquire() as conn:
        async with conn.transaction():
            await conn.execute("SET LOCAL statement_timeout = '5s'")
            for order in orders:
                if remaining <= 0.0001:
                    break
                order_id = order['id']
                seller_id = order['user_id']
                order_amount = order['amount']
                take = min(remaining, order_amount)
                current = await conn.fetchrow("SELECT * FROM bitcoin_orders WHERE id=$1 AND status='active' FOR UPDATE", order_id)
                if not current or float(current['amount']) < take - 0.0001:
                    continue
                await update_user_balance(user_id, -take * price, conn=conn, allow_negative=False)
                await update_user_bitcoin(user_id, take, conn=conn)
                await update_user_balance(seller_id, take * price, conn=conn, allow_negative=False)
                new_amount = float(current['amount']) - take
                new_locked = float(current['total_locked']) - take
                if new_amount <= 0.0001:
                    await conn.execute("UPDATE bitcoin_orders SET status='completed', amount=0, total_locked=0 WHERE id=$1", order_id)
                else:
                    await conn.execute("UPDATE bitcoin_orders SET amount=$1, total_locked=$2 WHERE id=$3", new_amount, new_locked, order_id)
                await conn.execute(
                    "INSERT INTO bitcoin_trades (sell_order_id, amount, price, buyer_id, seller_id) VALUES ($1, $2, $3, $4, $5)",
                    order_id, take, price, user_id, seller_id
                )
                remaining -= take
    await message.answer(f"‚úÖ –¢—ã –∫—É–ø–∏–ª {amount:.4f} BTC –∑–∞ {total_cost:.2f} –±–∞–∫—Å–æ–≤.", reply_markup=bitcoin_exchange_keyboard())
    await state.clear()

@dp.callback_query(F.data.startswith("sell_to_"))
async def sell_to_price(callback: CallbackQuery, state: FSMContext):
    price = int(callback.data.split("_")[2])
    user_id = callback.from_user.id
    async with db_pool.acquire() as conn:
        orders = await conn.fetch(
            "SELECT * FROM bitcoin_orders WHERE type='buy' AND status='active' AND price=$1 ORDER BY created_at ASC",
            price
        )
    if not orders:
        await callback.answer("–ó–∞—è–≤–æ–∫ –ø–æ —ç—Ç–æ–π —Ü–µ–Ω–µ –±–æ–ª—å—à–µ –Ω–µ—Ç.", show_alert=True)
        return
    orders_list = []
    total_available = 0.0
    for o in orders:
        d = dict(o)
        d['amount'] = float(d['amount'])
        d['total_locked'] = float(d['total_locked'])
        orders_list.append(d)
        total_available += d['amount']
    await state.update_data(price=price, orders=orders_list, total_available=total_available)
    await callback.message.answer(
        f"üìà –ü–æ–∫—É–ø–∫–∞ –ø–æ —Ü–µ–Ω–µ {price} $/BTC. –¢—Ä–µ–±—É–µ—Ç—Å—è –≤—Å–µ–≥–æ: {total_available:.4f} BTC.\n"
        f"–í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ BTC, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—á–µ—à—å –ø—Ä–æ–¥–∞—Ç—å (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω–æ–µ):",
        reply_markup=back_keyboard()
    )
    await SellToPrice.amount.set()
    await callback.answer()

@dp.message(SellToPrice.amount, F.text)
async def sell_to_price_amount(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await bitcoin_exchange_menu(message)
        return
    try:
        amount = float(message.text)
        if amount <= 0:
            raise ValueError
        amount = round(amount, 4)
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.")
        return
    data = await state.get_data()
    price = data['price']
    orders = data['orders']
    total_available = data['total_available']

    min_amount = await get_setting_float("exchange_min_amount_btc")
    if amount < min_amount:
        await message.answer(f"‚ùå –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏: {min_amount} BTC.")
        return

    if amount > total_available + 0.0001:
        await message.answer(f"‚ùå –°–ø—Ä–æ—Å –º–µ–Ω—å—à–µ. –ú–∞–∫—Å–∏–º—É–º –º–æ–∂–Ω–æ –ø—Ä–æ–¥–∞—Ç—å {total_available:.4f} BTC.")
        return
    user_id = message.from_user.id
    btc_balance = await get_user_bitcoin(user_id)
    if btc_balance < amount:
        await message.answer(f"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ BTC. –£ —Ç–µ–±—è {btc_balance:.4f} BTC.")
        return
    total_profit = amount * price
    max_input = await get_setting_float("max_input_number")
    if total_profit > max_input:
        await message.answer(f"‚ùå –°—É–º–º–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è (–º–∞–∫—Å–∏–º—É–º {max_input:.2f}).")
        return
    remaining = amount
    async with db_pool.acquire() as conn:
        async with conn.transaction():
            await conn.execute("SET LOCAL statement_timeout = '5s'")
            for order in orders:
                if remaining <= 0.0001:
                    break
                order_id = order['id']
                buyer_id = order['user_id']
                order_amount = order['amount']
                take = min(remaining, order_amount)
                current = await conn.fetchrow("SELECT * FROM bitcoin_orders WHERE id=$1 AND status='active' FOR UPDATE", order_id)
                if not current or float(current['amount']) < take - 0.0001:
                    continue
                await update_user_balance(user_id, take * price, conn=conn, allow_negative=False)
                await update_user_bitcoin(user_id, -take, conn=conn)
                await update_user_bitcoin(buyer_id, take, conn=conn)
                new_amount = float(current['amount']) - take
                new_locked = float(current['total_locked']) - take * price
                if new_amount <= 0.0001:
                    await conn.execute("UPDATE bitcoin_orders SET status='completed', amount=0, total_locked=0 WHERE id=$1", order_id)
                else:
                    await conn.execute("UPDATE bitcoin_orders SET amount=$1, total_locked=$2 WHERE id=$3", new_amount, new_locked, order_id)
                await conn.execute(
                    "INSERT INTO bitcoin_trades (buy_order_id, amount, price, buyer_id, seller_id) VALUES ($1, $2, $3, $4, $5)",
                    order_id, take, price, buyer_id, user_id
                )
                remaining -= take
    await message.answer(f"‚úÖ –¢—ã –ø—Ä–æ–¥–∞–ª {amount:.4f} BTC –∑–∞ {total_profit:.2f} –±–∞–∫—Å–æ–≤.", reply_markup=bitcoin_exchange_keyboard())
    await state.clear()

@dp.message(F.text == "üìâ –ü—Ä–æ–¥–∞—Ç—å BTC")
async def sell_bitcoin_start(message: Message, state: FSMContext):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    btc_balance = await get_user_bitcoin(user_id)
    min_amount = await get_setting_float("exchange_min_amount_btc")
    await message.answer(
        f"–£ —Ç–µ–±—è {btc_balance:.4f} BTC.\n"
        f"–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –∑–∞—è–≤–∫–∏: {min_amount} BTC.\n"
        f"–í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ BTC, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—á–µ—à—å –ø—Ä–æ–¥–∞—Ç—å (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω–æ–µ, –Ω–∞–ø—Ä–∏–º–µ—Ä 0.5):",
        reply_markup=back_keyboard()
    )
    await SellBitcoin.amount.set()

@dp.message(SellBitcoin.amount, F.text)
async def sell_bitcoin_amount(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await bitcoin_exchange_menu(message)
        return
    try:
        amount = float(message.text)
        if amount <= 0:
            raise ValueError
        amount = round(amount, 4)
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω–æ–µ).")
        return
    user_id = message.from_user.id
    btc_balance = await get_user_bitcoin(user_id)
    if btc_balance < amount - 0.0001:
        await message.answer(f"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ BTC. –£ —Ç–µ–±—è {btc_balance:.4f} BTC.")
        return
    min_amount = await get_setting_float("exchange_min_amount_btc")
    if amount < min_amount:
        await message.answer(f"‚ùå –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏: {min_amount} BTC.")
        return
    await state.update_data(amount=amount)
    await message.answer("–í–≤–µ–¥–∏ —Ü–µ–Ω—É –≤ –±–∞–∫—Å–∞—Ö –∑–∞ 1 BTC (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ):")
    await SellBitcoin.price.set()

@dp.message(SellBitcoin.price, F.text)
async def sell_bitcoin_price(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await bitcoin_exchange_menu(message)
        return
    try:
        price = int(message.text)
        if price <= 0:
            raise ValueError
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —Ü–µ–ª–æ–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.")
        return
    min_price = await get_setting_int("exchange_min_price")
    max_price = await get_setting_int("exchange_max_price")
    if price < min_price:
        await message.answer(f"‚ùå –¶–µ–Ω–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–Ω—å—à–µ {min_price}.")
        return
    if max_price > 0 and price > max_price:
        await message.answer(f"‚ùå –¶–µ–Ω–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –±–æ–ª—å—à–µ {max_price}.")
        return
    data = await state.get_data()
    amount = data['amount']
    user_id = message.from_user.id
    try:
        order_id = await create_bitcoin_order(user_id, 'sell', amount, price)
        await message.answer(
            f"‚úÖ –ó–∞—è–≤–∫–∞ –Ω–∞ –ø—Ä–æ–¥–∞–∂—É {amount:.4f} BTC –ø–æ —Ü–µ–Ω–µ {price} $/BTC —Å–æ–∑–¥–∞–Ω–∞!\n"
            f"ID –∑–∞—è–≤–∫–∏: {order_id}",
            reply_markup=bitcoin_exchange_keyboard()
        )
    except ValueError as e:
        await message.answer(f"‚ùå {e}")
    except Exception as e:
        logging.error(f"Sell bitcoin error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞—è–≤–∫–∏.")
    await state.clear()

@dp.message(F.text == "üìà –ö—É–ø–∏—Ç—å BTC")
async def buy_bitcoin_start(message: Message, state: FSMContext):
    if message.chat.type != 'private':
        return
    min_amount = await get_setting_float("exchange_min_amount_btc")
    await message.answer(
        f"–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –∑–∞—è–≤–∫–∏: {min_amount} BTC.\n"
        f"–í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ BTC, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—á–µ—à—å –∫—É–ø–∏—Ç—å (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω–æ–µ, –Ω–∞–ø—Ä–∏–º–µ—Ä 0.5):",
        reply_markup=back_keyboard()
    )
    await BuyBitcoin.amount.set()

@dp.message(BuyBitcoin.amount, F.text)
async def buy_bitcoin_amount(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await bitcoin_exchange_menu(message)
        return
    try:
        amount = float(message.text)
        if amount <= 0:
            raise ValueError
        amount = round(amount, 4)
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω–æ–µ).")
        return
    min_amount = await get_setting_float("exchange_min_amount_btc")
    if amount < min_amount:
        await message.answer(f"‚ùå –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–ª—è –ø–æ–∫—É–ø–∫–∏: {min_amount} BTC.")
        return
    await state.update_data(amount=amount)
    await message.answer("–í–≤–µ–¥–∏ —Ü–µ–Ω—É –≤ –±–∞–∫—Å–∞—Ö –∑–∞ 1 BTC (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ):")
    await BuyBitcoin.price.set()

@dp.message(BuyBitcoin.price, F.text)
async def buy_bitcoin_price(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await bitcoin_exchange_menu(message)
        return
    try:
        price = int(message.text)
        if price <= 0:
            raise ValueError
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —Ü–µ–ª–æ–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.")
        return
    min_price = await get_setting_int("exchange_min_price")
    max_price = await get_setting_int("exchange_max_price")
    if price < min_price:
        await message.answer(f"‚ùå –¶–µ–Ω–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–Ω—å—à–µ {min_price}.")
        return
    if max_price > 0 and price > max_price:
        await message.answer(f"‚ùå –¶–µ–Ω–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –±–æ–ª—å—à–µ {max_price}.")
        return
    data = await state.get_data()
    amount = data['amount']
    user_id = message.from_user.id
    try:
        order_id = await create_bitcoin_order(user_id, 'buy', amount, price)
        await message.answer(
            f"‚úÖ –ó–∞—è–≤–∫–∞ –Ω–∞ –ø–æ–∫—É–ø–∫—É {amount:.4f} BTC –ø–æ —Ü–µ–Ω–µ {price} $/BTC —Å–æ–∑–¥–∞–Ω–∞!\n"
            f"ID –∑–∞—è–≤–∫–∏: {order_id}",
            reply_markup=bitcoin_exchange_keyboard()
        )
    except ValueError as e:
        await message.answer(f"‚ùå {e}")
    except Exception as e:
        logging.error(f"Buy bitcoin error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞—è–≤–∫–∏.")
    await state.clear()

@dp.message(F.text == "üìã –ú–æ–∏ –∑–∞—è–≤–∫–∏")
async def my_orders(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    async with db_pool.acquire() as conn:
        rows = await conn.fetch(
            "SELECT * FROM bitcoin_orders WHERE user_id=$1 AND status='active' ORDER BY created_at DESC",
            user_id
        )
    if not rows:
        await message.answer("–£ —Ç–µ–±—è –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞—è–≤–æ–∫.", reply_markup=bitcoin_exchange_keyboard())
        return
    orders = []
    for r in rows:
        d = dict(r)
        d['amount'] = float(d['amount'])
        d['total_locked'] = float(d['total_locked'])
        orders.append(d)
    page = 1
    total_pages = (len(orders) + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE
    start = (page - 1) * ITEMS_PER_PAGE
    end = start + ITEMS_PER_PAGE
    page_orders = orders[start:end]
    kb = my_orders_keyboard(page_orders, page, total_pages)
    await message.answer("–¢–≤–æ–∏ –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–∞—è–≤–∫–∏:", reply_markup=kb)

@dp.callback_query(F.data.startswith("myorder_"))
async def my_order_detail(callback: CallbackQuery):
    order_id = int(callback.data.split("_")[1])
    async with db_pool.acquire() as conn:
        order = await conn.fetchrow("SELECT * FROM bitcoin_orders WHERE id=$1", order_id)
    if not order or order['status'] != 'active':
        await callback.answer("–ó–∞—è–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —É–∂–µ –Ω–µ –∞–∫—Ç–∏–≤–Ω–∞.", show_alert=True)
        return
    amount = float(order['amount'])
    total_locked = float(order['total_locked'])
    text = (
        f"üìÑ –ó–∞—è–≤–∫–∞ #{order['id']}\n"
        f"–¢–∏–ø: {'üìà –ü–æ–∫—É–ø–∫–∞' if order['type']=='buy' else 'üìâ –ü—Ä–æ–¥–∞–∂–∞'}\n"
        f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {amount:.4f} BTC\n"
        f"–¶–µ–Ω–∞: {order['price']} $/BTC\n"
        f"–í—Å–µ–≥–æ: {amount * order['price']:.2f} $\n"
        f"–°–æ–∑–¥–∞–Ω–∞: {order['created_at'].strftime('%Y-%m-%d %H:%M')}"
    )
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –∑–∞—è–≤–∫—É", callback_data=f"cancel_order_{order_id}")],
        [InlineKeyboardButton(text="¬´ –ù–∞–∑–∞–¥", callback_data="my_orders_back")]
    ])
    await callback.message.edit_text(text, reply_markup=kb)
    await callback.answer()

@dp.callback_query(F.data.startswith("cancel_order_"))
async def cancel_order_callback(callback: CallbackQuery, state: FSMContext):
    order_id = int(callback.data.split("_")[2])
    user_id = callback.from_user.id
    success = await cancel_bitcoin_order(order_id, user_id)
    if success:
        await callback.answer("‚úÖ –ó–∞—è–≤–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞, —Å—Ä–µ–¥—Å—Ç–≤–∞ –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã.", show_alert=True)
    else:
        await callback.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–º–µ–Ω–∏—Ç—å –∑–∞—è–≤–∫—É.", show_alert=True)
    await my_orders(callback.message)

@dp.callback_query(F.data == "my_orders_back")
async def my_orders_back(callback: CallbackQuery):
    await my_orders(callback.message)
    await callback.answer()

@dp.callback_query(F.data.startswith("myorders_page_"))
async def myorders_page_callback(callback: CallbackQuery):
    page = int(callback.data.split("_")[2])
    callback.message.text = f"üìã –ú–æ–∏ –∑–∞—è–≤–∫–∏ {page}"
    await my_orders(callback.message)
    await callback.answer()

@dp.callback_query(F.data == "exchange_back")
async def exchange_back(callback: CallbackQuery):
    await bitcoin_exchange_menu(callback.message)
    await callback.answer()

# ==================== –†–û–ó–´–ì–†–´–®–ò (–ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–¨–°–ö–ê–Ø –ß–ê–°–¢–¨) ====================
@dp.message(F.text == "üéÅ –†–æ–∑—ã–≥—Ä—ã—à–∏")
async def giveaways_user_menu(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        return
    await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)
    ok, not_subscribed = await check_subscription(user_id)
    if not ok:
        await message.answer("‚ùóÔ∏è –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã.", reply_markup=subscription_inline(not_subscribed))
        return
    await send_with_media(message.chat.id, "üéÅ –†–æ–∑—ã–≥—Ä—ã—à–∏:", media_key='giveaway', reply_markup=giveaways_user_keyboard())

@dp.message(F.text == "üìã –ê–∫—Ç–∏–≤–Ω—ã–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∏")
async def active_giveaways_user(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        return
    page = 1
    try:
        parts = message.text.split()
        if len(parts) > 1:
            page = int(parts[1])
    except:
        pass
    offset = (page - 1) * ITEMS_PER_PAGE
    async with db_pool.acquire() as conn:
        total = await conn.fetchval("SELECT COUNT(*) FROM giveaways WHERE status='active'")
        rows = await conn.fetch(
            "SELECT id, prize, description, end_date, media_file_id, media_type FROM giveaways WHERE status='active' ORDER BY end_date LIMIT $1 OFFSET $2",
            ITEMS_PER_PAGE, offset
        )
    if not rows:
        await message.answer("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π.")
        return
    text = f"üìã –ê–∫—Ç–∏–≤–Ω—ã–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∏ (—Å—Ç—Ä–∞–Ω–∏—Ü–∞ {page}):\n\n"
    for row in rows:
        end_str = row['end_date'].strftime("%Y-%m-%d %H:%M") if row['end_date'] else "–Ω–µ —É–∫–∞–∑–∞–Ω–æ"
        text += f"üéÅ #{row['id']} - {row['prize']}\n"
        text += f"{row['description']}\n"
        text += f"‚è≥ –û–∫–æ–Ω—á–∞–Ω–∏–µ: {end_str}\n\n"
    total_pages = (total + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE
    kb = active_giveaways_keyboard(rows, page, total_pages)
    await message.answer(text, reply_markup=kb)

@dp.callback_query(F.data.startswith("active_gw_") and not F.data.startswith("active_gw_page_"))
async def active_giveaway_detail(callback: CallbackQuery):
    gw_id = int(callback.data.split("_")[2])
    user_id = callback.from_user.id
    async with db_pool.acquire() as conn:
        gw = await conn.fetchrow("SELECT * FROM giveaways WHERE id=$1 AND status='active'", gw_id)
        if not gw:
            await callback.answer("–†–æ–∑—ã–≥—Ä—ã—à –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ —É–∂–µ –∑–∞–≤–µ—Ä—à—ë–Ω.", show_alert=True)
            return
        participant = await conn.fetchval("SELECT 1 FROM participants WHERE user_id=$1 AND giveaway_id=$2", user_id, gw_id)
        participants_count = await conn.fetchval("SELECT COUNT(*) FROM participants WHERE giveaway_id=$1", gw_id)
    end_str = gw['end_date'].strftime("%Y-%m-%d %H:%M") if gw['end_date'] else "–Ω–µ —É–∫–∞–∑–∞–Ω–æ"
    text = (
        f"üéÅ <b>{gw['prize']}</b>\n"
        f"üìù {gw['description']}\n"
        f"‚è≥ –û–∫–æ–Ω—á–∞–Ω–∏–µ: {end_str}\n"
        f"üë• –£—á–∞—Å—Ç–Ω–∏–∫–æ–≤: {participants_count}\n"
        f"üëë –ü–æ–±–µ–¥–∏—Ç–µ–ª–µ–π: {gw['winners_count']}\n"
    )
    kb = giveaway_detail_keyboard(gw_id, bool(participant), participants_count)
    if gw['media_file_id'] and gw['media_type'] == 'photo':
        await callback.message.delete()
        await callback.message.answer_photo(gw['media_file_id'], caption=text, reply_markup=kb)
    else:
        await callback.message.edit_text(text, reply_markup=kb)
    await callback.answer()

@dp.callback_query(F.data.startswith("join_giveaway_"))
async def join_giveaway(callback: CallbackQuery):
    gw_id = int(callback.data.split("_")[2])
    user_id = callback.from_user.id
    async with db_pool.acquire() as conn:
        status = await conn.fetchval("SELECT status FROM giveaways WHERE id=$1", gw_id)
        if status != 'active':
            await callback.answer("–†–æ–∑—ã–≥—Ä—ã—à —É–∂–µ –∑–∞–≤–µ—Ä—à—ë–Ω.", show_alert=True)
            return
        exists = await conn.fetchval("SELECT 1 FROM participants WHERE user_id=$1 AND giveaway_id=$2", user_id, gw_id)
        if exists:
            await callback.answer("–¢—ã —É–∂–µ —É—á–∞—Å—Ç–≤—É–µ—à—å.", show_alert=True)
            return
        await conn.execute("INSERT INTO participants (user_id, giveaway_id) VALUES ($1, $2)", user_id, gw_id)
    await callback.answer("‚úÖ –¢—ã —É—á–∞—Å—Ç–≤—É–µ—à—å –≤ —Ä–æ–∑—ã–≥—Ä—ã—à–µ!", show_alert=True)
    await active_giveaway_detail(callback)

@dp.callback_query(F.data.startswith("leave_giveaway_"))
async def leave_giveaway(callback: CallbackQuery):
    gw_id = int(callback.data.split("_")[2])
    user_id = callback.from_user.id
    async with db_pool.acquire() as conn:
        await conn.execute("DELETE FROM participants WHERE user_id=$1 AND giveaway_id=$2", user_id, gw_id)
    await callback.answer("‚ùå –¢—ã –æ—Ç–∫–∞–∑–∞–ª—Å—è –æ—Ç —É—á–∞—Å—Ç–∏—è.", show_alert=True)
    await active_giveaway_detail(callback)

@dp.callback_query(F.data == "active_gw_back")
async def active_gw_back(callback: CallbackQuery):
    await active_giveaways_user(callback.message)
    await callback.answer()

@dp.message(F.text == "üèÅ –ó–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∏")
async def completed_giveaways_user(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        return
    page = 1
    try:
        parts = message.text.split()
        if len(parts) > 1:
            page = int(parts[1])
    except:
        pass
    offset = (page - 1) * ITEMS_PER_PAGE
    async with db_pool.acquire() as conn:
        total = await conn.fetchval("SELECT COUNT(*) FROM giveaways WHERE status='completed'")
        rows = await conn.fetch(
            "SELECT id, prize, description, end_date, winners_list FROM giveaways WHERE status='completed' ORDER BY end_date DESC LIMIT $1 OFFSET $2",
            ITEMS_PER_PAGE, offset
        )
    if not rows:
        await message.answer("–ù–µ—Ç –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π.")
        return
    text = f"üèÅ –ó–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∏ (—Å—Ç—Ä–∞–Ω–∏—Ü–∞ {page}):\n\n"
    for row in rows:
        end_str = row['end_date'].strftime("%Y-%m-%d %H:%M") if row['end_date'] else "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
        text += f"üéÅ #{row['id']} - {row['prize']}\n"
        text += f"üìÖ –ó–∞–≤–µ—Ä—à—ë–Ω: {end_str}\n"
        winners = json.loads(row['winners_list']) if row['winners_list'] else []
        text += f"üëë –ü–æ–±–µ–¥–∏—Ç–µ–ª–∏: {', '.join(map(str, winners)) if winners else '–Ω–µ —É–∫–∞–∑–∞–Ω—ã'}\n\n"
    total_pages = (total + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE
    kb = completed_giveaways_keyboard(rows, page, total_pages)
    await message.answer(text, reply_markup=kb)

@dp.callback_query(F.data.startswith("completed_gw_") and not F.data.startswith("completed_gw_page_"))
async def completed_giveaway_detail(callback: CallbackQuery):
    gw_id = int(callback.data.split("_")[2])
    async with db_pool.acquire() as conn:
        gw = await conn.fetchrow("SELECT * FROM giveaways WHERE id=$1 AND status='completed'", gw_id)
        if not gw:
            await callback.answer("–†–æ–∑—ã–≥—Ä—ã—à –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
            return
        participants = await conn.fetch("SELECT user_id FROM participants WHERE giveaway_id=$1", gw_id)
    participants_list = "\n".join([f"‚Ä¢ {p['user_id']}" for p in participants]) or "–Ω–µ—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤"
    winners = json.loads(gw['winners_list']) if gw['winners_list'] else []
    end_str = gw['end_date'].strftime("%Y-%m-%d %H:%M") if gw['end_date'] else "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
    text = (
        f"üèÅ –†–æ–∑—ã–≥—Ä—ã—à #{gw['id']}\n"
        f"üéÅ –ü—Ä–∏–∑: {gw['prize']}\n"
        f"üìÑ –û–ø–∏—Å–∞–Ω–∏–µ: {gw['description']}\n"
        f"üìÖ –î–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è: {end_str}\n"
        f"üëë –ü–æ–±–µ–¥–∏—Ç–µ–ª–∏: {', '.join(map(str, winners)) if winners else '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}\n\n"
        f"üìã –£—á–∞—Å—Ç–Ω–∏–∫–∏:\n{participants_list}"
    )
    if gw['media_file_id'] and gw['media_type'] == 'photo':
        await callback.message.delete()
        await callback.message.answer_photo(gw['media_file_id'], caption=text)
    else:
        await callback.message.edit_text(text)
    await callback.answer()

@dp.callback_query(F.data.startswith("completed_gw_page_"))
async def completed_gw_page_callback(callback: CallbackQuery):
    page = int(callback.data.split("_")[3])
    callback.message.text = f"üèÅ –ó–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∏ {page}"
    await completed_giveaways_user(callback.message)
    await callback.answer()

@dp.callback_query(F.data == "completed_gw_back")
async def completed_gw_back(callback: CallbackQuery):
    await completed_giveaways_user(callback.message)
    await callback.answer()

# ==================== –ù–û–í–´–ï –•–ï–ù–î–õ–ï–†–´ –î–õ–Ø –ù–ê–õ–Å–¢–û–í (–í –õ–°) ====================
@dp.callback_query(F.data.startswith("betray_choice_"))
async def betray_choice_callback(callback: CallbackQuery, state: FSMContext):
    parts = callback.data.split("_")
    choice = parts[2]  # yes –∏–ª–∏ no
    heist_id = int(parts[3])
    user_id = callback.from_user.id

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –Ω–∞–ª—ë—Ç –µ—â—ë –≤ —Å—Ç–∞–¥–∏–∏ splitting
    async with db_pool.acquire() as conn:
        heist = await conn.fetchrow("SELECT * FROM heists WHERE id=$1 AND status='splitting'", heist_id)
        if not heist:
            await callback.answer("‚ùå –ù–∞–ª—ë—Ç —É–∂–µ –∑–∞–≤–µ—Ä—à—ë–Ω –∏–ª–∏ –Ω–µ –≤ —Å—Ç–∞–¥–∏–∏ —Ä–∞—Å–ø–∏–ª–∞.", show_alert=True)
            return

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—á–∞—Å—Ç–≤—É–µ—Ç
        participant = await conn.fetchrow("SELECT * FROM heist_participants WHERE heist_id=$1 AND user_id=$2", heist_id, user_id)
        if not participant:
            await callback.answer("‚ùå –¢—ã –Ω–µ —É—á–∞—Å—Ç–≤—É–µ—à—å –≤ —ç—Ç–æ–º –Ω–∞–ª—ë—Ç–µ.", show_alert=True)
            return

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–¥–µ–ª–∞–ª –ª–∏ —É–∂–µ –≤—ã–±–æ—Ä
        if participant['betray_choice'] is not None:
            await callback.answer("‚úÖ –¢—ã —É–∂–µ —Å–¥–µ–ª–∞–ª –≤—ã–±–æ—Ä.", show_alert=True)
            return

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–±–æ—Ä
        await conn.execute(
            "UPDATE heist_participants SET betray_choice=$1 WHERE heist_id=$2 AND user_id=$3",
            choice, heist_id, user_id
        )

    await callback.answer("‚úÖ –¢–≤–æ–π –≤—ã–±–æ—Ä –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω. –û–∂–∏–¥–∞–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤.", show_alert=False)
    await callback.message.edit_text("‚úÖ –¢–≤–æ–π –≤—ã–±–æ—Ä –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω. –û–∂–∏–¥–∞–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –≤ —á–∞—Ç–µ.")

# ==================== –ö–û–ù–ï–¶ –ß–ê–°–¢–ò 3 ====================
# ==================== –ß–ê–°–¢–¨ 4: –ì–†–£–ü–ü–û–í–´–ï –•–ï–ù–î–õ–ï–†–´ ====================
# –ü–æ–ª–Ω–æ—Å—Ç—å—é –ø–µ—Ä–µ–ø–∏—Å–∞–Ω–æ –¥–ª—è aiogram 3.x. –í—Å–µ –æ—à–∏–±–∫–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã.
# - –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –ª–æ–≥–∏–∫–∞ –∫—É–ª–¥–∞—É–Ω–æ–≤
# - –î–æ–±–∞–≤–ª–µ–Ω—ã –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
# - –£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–∞ —Ä–∞–±–æ—Ç–∞ —Å –∞–≤—Ç–æ—É–¥–∞–ª–µ–Ω–∏–µ–º
# - –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ —Ä–∞–±–æ—Ç–∞ —Å –¥–∞—Ç–∞–º–∏ (datetime –∏–∑ –ë–î, —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ date –æ–±—ä–µ–∫—Ç–æ–≤)
# - –î–æ–±–∞–≤–ª–µ–Ω –∏–º–ø–æ—Ä—Ç types –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π —Ä–∞–±–æ—Ç—ã
# - –ò—Å–ø—Ä–∞–≤–ª–µ–Ω –ø–æ–¥—Å—á—ë—Ç –ø–æ–¥–≥–æ–Ω–æ–≤ –≤ —á–∞—Ç–µ (—Å—Ä–∞–≤–Ω–µ–Ω–∏–µ –¥–∞—Ç)

import asyncio
import logging
import random
from datetime import datetime, timedelta, date

from aiogram import F, types
from aiogram.filters import Command
from aiogram.types import CallbackQuery, Message, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.fsm.context import FSMContext

# –í—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ —á–∞—Å—Ç–µ–π 1-3 –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞—é—Ç—Å—è –¥–æ—Å—Ç—É–ø–Ω—ã–º–∏
# (bot, dp, db_pool, redis_client, –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã, —Å–æ—Å—Ç–æ—è–Ω–∏—è)

# ==================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ì–†–£–ü–ü ====================
async def check_chat(message: Message) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –≥—Ä—É–ø–ø—ã –∏ —á–∞—Ç –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω."""
    if message.chat.type == 'private':
        return False
    if not await is_chat_confirmed(message.chat.id):
        await auto_delete_command(message, "‚ùå –≠—Ç–æ—Ç —á–∞—Ç –Ω–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /activate_chat –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏.")
        return False
    return True

# ==================== –ö–û–ú–ê–ù–î–ê /activate_chat ====================
@dp.message(Command("activate_chat"))
async def activate_chat_command(message: Message):
    if message.chat.type == 'private':
        await message.reply("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–∞—Ö.")
        return

    chat_id = message.chat.id
    user_id = message.from_user.id

    if await is_chat_confirmed(chat_id):
        await auto_delete_command(message, "‚úÖ –≠—Ç–æ—Ç —á–∞—Ç —É–∂–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!")
        return

    await create_chat_confirmation_request(
        chat_id,
        message.chat.title or "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è",
        message.chat.type,
        user_id
    )

    await auto_delete_command(message, "üì® –ó–∞–ø—Ä–æ—Å –Ω–∞ –∞–∫—Ç–∏–≤–∞—Ü–∏—é —á–∞—Ç–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º!")

    # –£–≤–µ–¥–æ–º–ª—è–µ–º –∞–¥–º–∏–Ω–æ–≤ —Å –∫–Ω–æ–ø–∫–∞–º–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
    admins = SUPER_ADMINS.copy()
    async with db_pool.acquire() as conn:
        rows = await conn.fetch("SELECT user_id FROM admins")
        admins.extend([r['user_id'] for r in rows])

    for admin_id in admins:
        await safe_send_message(
            admin_id,
            f"üîî –ó–∞–ø—Ä–æ—Å –Ω–∞ –∞–∫—Ç–∏–≤–∞—Ü–∏—é —á–∞—Ç–∞!\n"
            f"–ß–∞—Ç: {message.chat.title} (ID: {chat_id})\n"
            f"–ó–∞–ø—Ä–æ—Å–∏–ª: {message.from_user.first_name} (ID: {user_id})",
            reply_markup=confirm_chat_inline(chat_id)
        )

# ==================== –û–ë–†–ê–ë–û–¢–ß–ò–ö –ö–õ–Æ–ß–ï–í–´–• –°–õ–û–í –ù–ê–õ–Å–¢–û–í ====================
@dp.message(F.text & ~F.text.startswith('/'))
async def heist_keyword_handler(message: Message):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –Ω–∞–ª—ë—Ç–æ–≤ –≤ —á–∞—Ç–∞—Ö. –ü—Ä–∏ –≤–≤–æ–¥–µ –∫–æ–¥–æ–≤–æ–≥–æ —Å–ª–æ–≤–∞ –¥–æ–±–∞–≤–ª—è–µ—Ç —É—á–∞—Å—Ç–Ω–∏–∫–∞."""
    if not await check_chat(message):
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        await auto_delete_command(message, "‚õî –í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã.")
        return

    await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π –∫—É–ª–¥–∞—É–Ω –¥–ª—è —á–∞—Ç–æ–≤ (1 —á–∞—Å)
    cooldown_hours = await get_setting_int("global_chat_cooldown_hours")
    ok, remaining = await check_global_cooldown(user_id, "chat_activity", cooldown_hours * 3600)
    if not ok:
        await auto_delete_command(message, f"‚è≥ –ì–ª–æ–±–∞–ª—å–Ω—ã–π –∫—É–ª–¥–∞—É–Ω! –¢—ã —Å–º–æ–∂–µ—à—å —Å–Ω–æ–≤–∞ —É—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å —á–µ—Ä–µ–∑ {format_time_remaining(remaining)}")
        return

    text = message.text.strip().upper()
    chat_id = message.chat.id

    async with db_pool.acquire() as conn:
        async with conn.transaction():
            heist = await conn.fetchrow(
                "SELECT * FROM heists WHERE chat_id=$1 AND status='joining' AND join_until > NOW()",
                chat_id
            )
            if not heist:
                return  # –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –Ω–∞–ª—ë—Ç–∞ ‚Äì –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º

            if text != heist['keyword']:
                return  # —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–æ–º ‚Äì –Ω–µ —É–¥–∞–ª—è–µ–º

            # –ï—Å–ª–∏ –¥–æ—à–ª–∏ —Å—é–¥–∞, –∑–Ω–∞—á–∏—Ç —ç—Ç–æ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ ‚Äì —É–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            if await can_delete_message(message.chat.id, message):
                await message.delete()

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —É—á–∞—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ
            exists = await conn.fetchval(
                "SELECT 1 FROM heist_participants WHERE heist_id=$1 AND user_id=$2",
                heist['id'], user_id
            )
            if exists:
                await auto_delete_reply(message, "–¢—ã —É–∂–µ –≤ –¥–µ–ª–µ! –ñ–¥–∏ –Ω–∞—á–∞–ª–∞ —Ä–∞—Å–ø–∏–ª–∞.")
                return

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—É–ª–¥–∞—É–Ω —É—á–∞—Å—Ç–∏—è –≤ –Ω–∞–ª—ë—Ç–µ (1 —á–∞—Å)
            participant_cooldown = await get_setting_int("heist_participant_cooldown_hours") * 3600
            ok, remaining = await check_global_cooldown(user_id, "heist_participate", participant_cooldown)
            if not ok:
                await auto_delete_reply(message, f"‚è≥ –¢—ã –µ—â—ë –Ω–µ –æ—Å—Ç—ã–ª –ø–æ—Å–ª–µ –ø—Ä–æ—à–ª–æ–≥–æ –Ω–∞–ª—ë—Ç–∞. –ü–æ–¥–æ–∂–¥–∏ {format_time_remaining(remaining)}.")
                return

            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–ª—É—á–∞–π–Ω—É—é —Å—É–º–º—É –¥–ª—è —É—á–∞—Å—Ç–Ω–∏–∫–∞ (–æ—Ç 5 –¥–æ 10) ‚Äì —Å–∫—Ä—ã—Ç–æ
            share = random.randint(5, 10)
            # –ù–∞—á–∏—Å–ª—è–µ–º –∏–≥—Ä–æ–∫—É
            success, new_balance, _ = await update_user_balance(user_id, share, conn=conn, allow_negative=False)
            if not success:
                await auto_delete_reply(message, "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞—á–∏—Å–ª–µ–Ω–∏–∏ –¥–æ–ª–∏.")
                return
            # –û–±–Ω–æ–≤–ª—è–µ–º –±–∞–Ω–∫ –Ω–∞–ª—ë—Ç–∞
            new_total = float(heist['total_pot']) + share
            new_remaining = float(heist['remaining_pot']) + share
            await conn.execute(
                "UPDATE heists SET total_pot=$1, remaining_pot=$2 WHERE id=$3",
                new_total, new_remaining, heist['id']
            )
            # –í—Å—Ç–∞–≤–ª—è–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞
            await conn.execute(
                "INSERT INTO heist_participants (heist_id, user_id, base_share, current_share, defense_bonus, joined_at) "
                "VALUES ($1, $2, $3, $3, 0, $4)",
                heist['id'], user_id, share, datetime.now()
            )

            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫—É–ª–¥–∞—É–Ω —É—á–∞—Å—Ç–∏—è
            await set_global_cooldown(user_id, "heist_participate", participant_cooldown)

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Ñ—Ä–∞–∑—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è (–±–µ–∑ —Å—É–º–º—ã)
            user_info = await conn.fetchrow("SELECT first_name FROM users WHERE user_id=$1", user_id)
            name = user_info['first_name'] if user_info else f"ID{user_id}"
            config = HEIST_TYPES[heist['event_type']]
            phrase = get_random_phrase(config.get('phrases_join', ["‚úÖ {name} –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ –Ω–∞–ª—ë—Ç—É!"]),
                                      name=name)
            await auto_delete_reply(message, phrase)

# ==================== –ö–û–ú–ê–ù–î–ê /mlb_heist (–°–¢–ê–¢–£–° –ù–ê–õ–Å–¢–ê) ====================
@dp.message(Command("mlb_heist"))
async def cmd_chat_heist_status(message: Message):
    if not await check_chat(message):
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        await auto_delete_command(message, "‚õî –í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã.")
        return

    await auto_delete_message(message)

    chat_id = message.chat.id
    async with db_pool.acquire() as conn:
        heist = await conn.fetchrow(
            "SELECT * FROM heists WHERE chat_id=$1 AND status IN ('joining', 'splitting')",
            chat_id
        )
        if not heist:
            await auto_delete_reply(message, "‚ùå –í —ç—Ç–æ–º —á–∞—Ç–µ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –Ω–∞–ª—ë—Ç–∞.")
            return
        count = await conn.fetchval("SELECT COUNT(*) FROM heist_participants WHERE heist_id=$1", heist['id'])
        status_emoji = "üü°" if heist['status'] == 'joining' else "üî¥"
        join_until = heist['join_until'] if heist['status'] == 'joining' else None
        split_until = heist['split_until'] if heist['status'] == 'splitting' else None
        if heist['status'] == 'joining':
            time_remaining = (join_until - datetime.now()).total_seconds()
            time_str = format_time_remaining(int(time_remaining)) if time_remaining > 0 else "–∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è"
        else:
            time_remaining = (split_until - datetime.now()).total_seconds()
            time_str = format_time_remaining(int(time_remaining)) if time_remaining > 0 else "–∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è"

        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–∞–ª—ë—Ç–∞, –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –∏ –≤—Ä–µ–º—è (–±–µ–∑ —Å—É–º–º—ã –±–∞–Ω–∫–∞)
        text = (
            f"{status_emoji} –ù–∞–ª—ë—Ç: {HEIST_TYPES[heist['event_type']]['name']}\n"
            f"üë• –£—á–∞—Å—Ç–Ω–∏–∫–æ–≤: {count}\n"
            f"‚è≥ –î–æ {'—Å–±–æ—Ä–∞' if heist['status']=='joining' else '—Ä–∞—Å–ø–∏–ª–∞'}: {time_str}"
        )
        await auto_delete_reply(message, text)

# ==================== –ö–û–ú–ê–ù–î–ê /mlb_smuggle (–ö–û–ù–¢–†–ê–ë–ê–ù–î–ê) ====================
@dp.message(Command("mlb_smuggle"))
async def cmd_smuggle(message: Message):
    if not await check_chat(message):
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        await auto_delete_command(message, "‚õî –í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã.")
        return

    await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ –∫—É–ª–¥–∞—É–Ω–∞
    cooldown_hours = await get_setting_int("global_chat_cooldown_hours")
    ok, remaining = await check_global_cooldown(user_id, "chat_activity", cooldown_hours * 3600)
    if not ok:
        await auto_delete_command(message, f"‚è≥ –ì–ª–æ–±–∞–ª—å–Ω—ã–π –∫—É–ª–¥–∞—É–Ω! –ü–æ–¥–æ–∂–¥–∏ {format_time_remaining(remaining)}.")
        return

    # –ü—Ä–æ–≤–µ—Ä–∫–∞, –Ω–µ—Ç –ª–∏ —É–∂–µ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ä–µ–π—Å–∞
    async with db_pool.acquire() as conn:
        active_run = await conn.fetchval(
            "SELECT 1 FROM smuggle_runs WHERE user_id=$1 AND status='in_progress'",
            user_id
        )
        if active_run:
            await auto_delete_command(message, "‚ùå –¢—ã —É–∂–µ –≤ —Ä–µ–π—Å–µ. –î–æ–∂–¥–∏—Å—å –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏—è.")
            return

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–æ–≥–æ –∫—É–ª–¥–∞—É–Ω–∞ –∫–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥—ã
    ok, remaining = await check_smuggle_cooldown(user_id)
    if not ok:
        minutes = remaining // 60
        seconds = remaining % 60
        await auto_delete_command(message, f"‚è≥ –¢—ã –µ—â—ë –Ω–µ –≤–µ—Ä–Ω—É–ª—Å—è –∏–∑ —Ä–µ–π—Å–∞. –ü–æ–¥–æ–∂–¥–∏ {minutes} –º–∏–Ω {seconds} —Å–µ–∫.")
        return

    min_dur = await get_setting_int("smuggle_min_duration")
    max_dur = await get_setting_int("smuggle_max_duration")
    duration = random.randint(min_dur, max_dur)
    end_time = datetime.now() + timedelta(minutes=duration)
    cargo_list = ["—è—â–∏–∫–∏ —Å —Å–∏–≥–∞—Ä–∞–º–∏", "–ø–∞—Ä—Ç–∏—è –≤–∏—Å–∫–∏", "–∫–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥–Ω–æ–µ –æ—Ä—É–∂–∏–µ", "–¥—Ä–∞–≥–æ—Ü–µ–Ω–Ω—ã–µ –∫–∞–º–Ω–∏", "–∑–æ–ª–æ—Ç—ã–µ —Å–ª–∏—Ç–∫–∏"]
    cargo = random.choice(cargo_list)

    async with db_pool.acquire() as conn:
        run_id = await conn.fetchval(
            "INSERT INTO smuggle_runs (user_id, start_time, end_time, chat_id) VALUES ($1, $2, $3, $4) RETURNING id",
            user_id, datetime.now(), end_time, message.chat.id
        )
    await set_smuggle_cooldown(user_id, 0)

    name = message.from_user.first_name
    phrase = get_random_phrase(SMUGGLE_START_PHRASES, name=name, cargo=cargo, duration=duration)

    file_id = await get_media_file_id('smuggle_start')
    if file_id:
        sent = await bot.send_photo(message.chat.id, file_id, caption=phrase)
        delete_seconds = int(await get_setting("auto_delete_commands_seconds"))
        asyncio.create_task(delete_after(sent, delete_seconds))
    else:
        await auto_delete_command(message, phrase)

# ==================== –ö–û–ú–ê–ù–î–ê /mlb_jail (–¢–Æ–†–¨–ú–ê) ====================
@dp.message(Command("mlb_jail"))
async def cmd_jail(message: Message, state: FSMContext):
    if not await check_chat(message):
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        await auto_delete_command(message, "‚õî –í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã.")
        return

    await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ –∫—É–ª–¥–∞—É–Ω–∞
    cooldown_hours = await get_setting_int("global_chat_cooldown_hours")
    ok, remaining = await check_global_cooldown(user_id, "chat_activity", cooldown_hours * 3600)
    if not ok:
        await auto_delete_command(message, f"‚è≥ –ì–ª–æ–±–∞–ª—å–Ω—ã–π –∫—É–ª–¥–∞—É–Ω! –ü–æ–¥–æ–∂–¥–∏ {format_time_remaining(remaining)}.")
        return

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Å—Ä–æ–∫–∞
    async with db_pool.acquire() as conn:
        active = await conn.fetchval(
            "SELECT 1 FROM jail_sentences WHERE user_id=$1 AND status='serving'",
            user_id
        )
        if active:
            await auto_delete_command(message, "‚ùå –¢—ã —É–∂–µ –æ—Ç–±—ã–≤–∞–µ—à—å —Å—Ä–æ–∫. –î–æ–∂–¥–∏—Å—å –æ–∫–æ–Ω—á–∞–Ω–∏—è.")
            return

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞ —Ç—é—Ä—å–º—ã
    cooldown_hours_jail = await get_setting_int("jail_cooldown_hours")
    ok, remaining = await check_global_cooldown(user_id, 'jail', cooldown_hours_jail * 3600)
    if not ok:
        await auto_delete_command(message, f"‚è≥ –í —Ç—é—Ä—å–º—É –º–æ–∂–Ω–æ –ø–æ–ø–∞—Å—Ç—å —Ä–∞–∑ –≤ {cooldown_hours_jail} —á. –û—Å—Ç–∞–ª–æ—Å—å {format_time_remaining(remaining)}.")
        return

    # –£–¥–∞–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É
    await auto_delete_message(message)

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º chat_id –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
    await state.update_data(chat_id=message.chat.id)

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ –õ–° –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –¥–ª—è –≤—ã–±–æ—Ä–∞ –∫–∞–º–µ—Ä—ã
    try:
        await bot.send_message(
            user_id,
            "üîí –í—ã–±–µ—Ä–∏ –Ω–æ–º–µ—Ä –∫–∞–º–µ—Ä—ã, –≤ –∫–æ—Ç–æ—Ä—É—é —Ö–æ—á–µ—à—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å—Å—è (–æ—Ç 1 –¥–æ 15):",
            reply_markup=jail_cell_keyboard()
        )
        # –ü–µ—Ä–µ–≤–æ–¥–∏–º –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–∂–∏–¥–∞–Ω–∏—è –≤—ã–±–æ—Ä–∞ –∫–∞–º–µ—Ä—ã
        await state.set_state(JailProcess.cell)
    except Exception as e:
        logging.error(f"Failed to send jail menu to {user_id}: {e}")
        await auto_delete_reply(message, "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –õ–°. –ù–∞–ø–∏—à–∏ –±–æ—Ç—É –≤ –ª–∏—á–∫—É —Å–Ω–∞—á–∞–ª–∞.")

# ==================== –û–ë–†–ê–ë–û–¢–ß–ò–ö –í–´–ë–û–†–ê –ö–ê–ú–ï–†–´ (–ò–ó –õ–°) ====================
@dp.callback_query(JailProcess.cell, F.data.startswith("jail_cell_"))
async def jail_cell_callback(callback: CallbackQuery, state: FSMContext):
    cell = int(callback.data.split("_")[2])
    user_id = callback.from_user.id
    await state.update_data(cell=cell)
    await callback.message.answer("üî¢ –í–≤–µ–¥–∏ –Ω–æ–º–µ—Ä —Å—Ç–∞—Ç—å–∏ (–æ—Ç 1 –¥–æ 300):")
    await state.set_state(JailProcess.article)
    await callback.answer()

@dp.message(JailProcess.article, F.text)
async def jail_article_message(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await message.answer("‚ùå –ü—Ä–æ—Ü–µ—Å—Å –æ—Ç–º–µ–Ω—ë–Ω.", reply_markup=main_menu_keyboard(await is_admin(message.from_user.id)))
        return
    try:
        article = int(message.text)
        if article < 1 or article > 300:
            raise ValueError
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 300.")
        return

    data = await state.get_data()
    chat_id = data.get('chat_id')
    cell = data.get('cell')
    user_id = message.from_user.id

    min_duration = await get_setting_int("jail_min_duration")
    max_duration = await get_setting_int("jail_max_duration")
    duration = random.randint(min_duration, max_duration)

    await start_jail_sentence(user_id, chat_id, duration, cell, article)
    name = message.from_user.first_name
    phrase = get_random_phrase(JAIL_START_PHRASES, name=name, duration=duration)

    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫—É–ª–¥–∞—É–Ω —Ç—é—Ä—å–º—ã
    cooldown_hours = await get_setting_int("jail_cooldown_hours")
    await set_global_cooldown(user_id, 'jail', cooldown_hours * 3600)

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —á–∞—Ç, –æ—Ç–∫—É–¥–∞ –ø—Ä–∏—à–ª–∞ –∫–æ–º–∞–Ω–¥–∞
    if chat_id:
        try:
            await safe_send_chat(chat_id, phrase)
        except Exception as e:
            logging.error(f"Failed to send jail start to chat {chat_id}: {e}")
            await message.answer(phrase)
    else:
        await message.answer(phrase)

    await state.clear()

# ==================== –ö–û–ú–ê–ù–î–ê /mlb_top (–¢–û–ü –í –ß–ê–¢–ï) ====================
@dp.message(Command("mlb_top"))
async def cmd_chat_top(message: Message):
    if not await check_chat(message):
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        await auto_delete_command(message, "‚õî –í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã.")
        return

    await auto_delete_message(message)  # —É–¥–∞–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton("üí∞ –ü–æ –±–æ–≥–∞—Ç—Å—Ç–≤—É", callback_data="chat_top_balance_1"),
         InlineKeyboardButton("‚≠êÔ∏è –ü–æ —Ä–µ–ø—É—Ç–∞—Ü–∏–∏", callback_data="chat_top_reputation_1")]
    ])
    await auto_delete_reply(message, "üèÜ –í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é —Ç–æ–ø–∞:", reply_markup=kb)

@dp.callback_query(F.data.startswith("chat_top_"))
async def chat_top_callback(callback: CallbackQuery):
    parts = callback.data.split("_")
    category = parts[2]
    page = int(parts[3])

    offset = (page - 1) * ITEMS_PER_PAGE
    if category == "balance":
        order_field = "balance"
        title = "üí∞ –°–∞–º—ã–µ –±–æ–≥–∞—Ç—ã–µ"
    else:
        order_field = "reputation"
        title = "‚≠êÔ∏è –ü–æ —Ä–µ–ø—É—Ç–∞—Ü–∏–∏"

    async with db_pool.acquire() as conn:
        total = await conn.fetchval("SELECT COUNT(*) FROM users")
        rows = await conn.fetch(
            f"SELECT first_name, {order_field} as value FROM users ORDER BY value DESC LIMIT $1 OFFSET $2",
            ITEMS_PER_PAGE, offset
        )

    if not rows:
        await callback.message.edit_text("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö.")
        await callback.answer()
        return

    text = f"{title} (—Å—Ç—Ä–∞–Ω–∏—Ü–∞ {page}):\n\n"
    for idx, row in enumerate(rows, start=offset+1):
        val = row['value']
        if category == "balance":
            val = f"{float(val):.2f} $"
        else:
            val = f"{val} ‚≠ê"
        text += f"{idx}. {row['first_name']} ‚Äì {val}\n"

    nav = []
    if page > 1:
        nav.append(InlineKeyboardButton("‚¨ÖÔ∏è", callback_data=f"chat_top_{category}_{page-1}"))
    if offset + ITEMS_PER_PAGE < total:
        nav.append(InlineKeyboardButton("‚û°Ô∏è", callback_data=f"chat_top_{category}_{page+1}"))

    kb = InlineKeyboardMarkup(inline_keyboard=[nav] if nav else [])
    await callback.message.edit_text(text, reply_markup=kb)
    await callback.answer()

# ==================== –ö–û–ú–ê–ù–î–ê /mlb_profile (–ü–†–û–§–ò–õ–¨ –í –ß–ê–¢–ï) ====================
@dp.message(Command("mlb_profile"))
async def cmd_chat_profile(message: Message):
    if not await check_chat(message):
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        await auto_delete_command(message, "‚õî –í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã.")
        return

    await auto_delete_message(message)

    balance = await get_user_balance(user_id)
    bitcoin = await get_user_bitcoin(user_id)
    authority = await get_user_authority(user_id)
    level = await get_user_level(user_id)
    rep = await get_user_reputation(user_id)

    text = (
        f"üë§ –ü—Ä–æ—Ñ–∏–ª—å {message.from_user.first_name}:\n"
        f"üìä –£—Ä–æ–≤–µ–Ω—å: {level}\n"
        f"üí∞ –ë–∞–ª–∞–Ω—Å: {balance:.2f} –±–∞–∫—Å–æ–≤\n"
        f"‚Çø –ë–∏—Ç–∫–æ–∏–Ω—ã: {bitcoin:.4f} BTC\n"
        f"‚≠êÔ∏è –†–µ–ø—É—Ç–∞—Ü–∏—è: {rep}\n"
        f"‚öîÔ∏è –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç: {authority}"
    )
    await auto_delete_reply(message, text)

# ==================== –ö–û–ú–ê–ù–î–ê /myheist (–ú–û–ô –¢–ï–ö–£–©–ò–ô –ù–ê–õ–Å–¢) ====================
@dp.message(Command("myheist"))
async def cmd_my_heist(message: Message):
    if not await check_chat(message):
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        await auto_delete_command(message, "‚õî –í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã.")
        return

    await auto_delete_message(message)

    async with db_pool.acquire() as conn:
        row = await conn.fetchrow("""
            SELECT hp.*, h.event_type, h.total_pot, h.btc_pot, h.split_until, h.status
            FROM heist_participants hp
            JOIN heists h ON hp.heist_id = h.id
            WHERE hp.user_id=$1 AND h.status IN ('joining', 'splitting')
            ORDER BY h.started_at DESC LIMIT 1
        """, user_id)
        if not row:
            await auto_delete_reply(message, "‚ùå –¢—ã –Ω–µ —É—á–∞—Å—Ç–≤—É–µ—à—å –≤ –∞–∫—Ç–∏–≤–Ω—ã—Ö –Ω–∞–ª—ë—Ç–∞—Ö.")
            return
        text = (
            f"üî´ –¢–≤–æ–π —Ç–µ–∫—É—â–∏–π –Ω–∞–ª—ë—Ç ({row['event_type']}):\n"
            f"–°—Ç–∞—Ç—É—Å: {'—Å–±–æ—Ä' if row['status']=='joining' else '—Ä–∞—Å–ø–∏–ª'}\n"
            f"–¢–≤–æ—è —Ç–µ–∫—É—â–∞—è –¥–æ–ª—è: {float(row['current_share']):.2f} $"
        )
        if row['btc_pot'] > 0:
            text += f"\n‚Çø –í –±–∞–Ω–∫–µ BTC: {float(row['btc_pot']):.4f} (–±—É–¥–µ—Ç —Ä–∞–∑–¥–µ–ª–µ–Ω –ø–æ—Ä–æ–≤–Ω—É –ø–æ—Å–ª–µ —Ä–∞—Å–ø–∏–ª–∞)"
        if row['status'] == 'splitting':
            remaining = (row['split_until'] - datetime.now()).total_seconds()
            if remaining > 0:
                text += f"\n‚è≥ –î–æ –∫–æ–Ω—Ü–∞ —Ä–∞—Å–ø–∏–ª–∞: {format_time_remaining(int(remaining))}"
        await auto_delete_reply(message, text)

# ==================== –ü–û–î–ì–û–ù (GIFT) –í –ß–ê–¢–ï (–ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø) ====================
@dp.message(F.text == "üéÅ –ü–æ–¥–≥–æ–Ω")
async def chat_gift(message: Message):
    if not await check_chat(message):
        return
    user_id = message.from_user.id
    if await is_banned(user_id) and not await is_admin(user_id):
        await auto_delete_command(message, "‚õî –í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã.")
        return

    await ensure_user_exists(user_id, message.from_user.username, message.from_user.first_name)

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ –∫—É–ª–¥–∞—É–Ω–∞
    cooldown_hours = await get_setting_int("global_chat_cooldown_hours")
    ok, remaining = await check_global_cooldown(user_id, "chat_activity", cooldown_hours * 3600)
    if not ok:
        await auto_delete_command(message, f"‚è≥ –ì–ª–æ–±–∞–ª—å–Ω—ã–π –∫—É–ª–¥–∞—É–Ω! –ü–æ–¥–æ–∂–¥–∏ {format_time_remaining(remaining)}.")
        return

    await auto_delete_message(message)  # —É–¥–∞–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É

    gift_amount = await get_setting_float("gift_amount")
    gift_limit_per_chat = await get_setting_int("gift_limit_per_day")
    gift_global_limit = await get_setting_int("gift_global_limit_per_user")
    gift_cooldown = await get_setting_int("gift_cooldown")
    today_date = date.today()  # –æ–±—ä–µ–∫—Ç date –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
    now = datetime.now()

    async with db_pool.acquire() as conn:
        async with conn.transaction():
            await conn.execute("SET LOCAL statement_timeout = '5s'")
            chat_info = await conn.fetchrow("SELECT * FROM confirmed_chats WHERE chat_id=$1 FOR UPDATE", message.chat.id)
            if not chat_info:
                return
            last_gift_date = chat_info['last_gift_date']  # –æ–±—ä–µ–∫—Ç date –∏–ª–∏ None
            gift_count_today = chat_info['gift_count_today'] if last_gift_date == today_date else 0

            if gift_count_today >= gift_limit_per_chat:
                await auto_delete_reply(message, f"‚ùå –°–µ–≥–æ–¥–Ω—è –≤ —ç—Ç–æ–º —á–∞—Ç–µ —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ {gift_count_today} –∏–∑ {gift_limit_per_chat} –ø–æ–¥–≥–æ–Ω–æ–≤.")
                return

            user = await conn.fetchrow("SELECT last_gift_time, gift_count_today FROM users WHERE user_id=$1 FOR UPDATE", user_id)
            if not user:
                user = {'last_gift_time': None, 'gift_count_today': 0}
            if user['last_gift_time'] and user['last_gift_time'].date() == today_date:
                user_gift_count = user['gift_count_today']
            else:
                user_gift_count = 0

            if user_gift_count >= gift_global_limit:
                await auto_delete_reply(message, f"‚ùå –°–µ–≥–æ–¥–Ω—è —Ç—ã —É–∂–µ –ø–æ–ª—É—á–∏–ª {user_gift_count} –∏–∑ {gift_global_limit} –ø–æ–¥–≥–æ–Ω–æ–≤ –≤–æ –≤—Å–µ—Ö —á–∞—Ç–∞—Ö.")
                return

            if user['last_gift_time']:
                last_gift = user['last_gift_time']
                diff = (now - last_gift).total_seconds() / 60
                if diff < gift_cooldown:
                    remaining_minutes = int(gift_cooldown - diff)
                    await auto_delete_reply(message, f"‚è≥ –ü–æ–¥–≥–æ–Ω –º–æ–∂–Ω–æ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —á–µ—Ä–µ–∑ {remaining_minutes} –º–∏–Ω.")
                    return

            try:
                admins = await bot.get_chat_administrators(message.chat.id)
                eligible = [a.user for a in admins if a.user.id != user_id and a.user.id != (await bot.me()).id and not await is_banned(a.user.id)]
                if not eligible:
                    await auto_delete_reply(message, "‚ùå –ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –ø–æ–ª—É—á–∞—Ç–µ–ª–µ–π –¥–ª—è –ø–æ–¥–∞—Ä–∫–∞.")
                    return
                recipient = random.choice(eligible)
            except Exception as e:
                logging.error(f"Gift error: {e}")
                await auto_delete_reply(message, "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–±—Ä–∞—Ç—å –ø–æ–ª—É—á–∞—Ç–µ–ª—è.")
                return

            # –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –ø–æ–ª—É—á–∞—Ç–µ–ª—å –µ—Å—Ç—å –≤ –ë–î
            await conn.execute(
                "INSERT INTO users (user_id, username, first_name, joined_date) VALUES ($1, $2, $3, $4) ON CONFLICT DO NOTHING",
                recipient.id, recipient.username, recipient.first_name, datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            )

            success, new_balance, _ = await update_user_balance(recipient.id, gift_amount, conn=conn, allow_negative=False)
            if not success:
                await auto_delete_reply(message, "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞—á–∏—Å–ª–µ–Ω–∏–∏ –ø–æ–¥–∞—Ä–∫–∞.")
                return

            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—á—ë—Ç—á–∏–∫ —á–∞—Ç–∞
            if last_gift_date == today_date:
                await conn.execute("UPDATE confirmed_chats SET gift_count_today = gift_count_today + 1 WHERE chat_id=$1", message.chat.id)
            else:
                await conn.execute("UPDATE confirmed_chats SET last_gift_date=$1, gift_count_today=1 WHERE chat_id=$2", today_date, message.chat.id)

            new_user_gift_count = user_gift_count + 1
            await conn.execute(
                "UPDATE users SET last_gift_time=$1, gift_count_today=$2 WHERE user_id=$3",
                now, new_user_gift_count, user_id
            )

            remaining_chat = gift_limit_per_chat - (gift_count_today + 1)
            await auto_delete_reply(message,
                f"üéÅ {message.from_user.first_name} –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–ª –ø–æ–¥–≥–æ–Ω!\n"
                f"–°—á–∞—Å—Ç–ª–∏–≤—á–∏–∫: {recipient.first_name} –ø–æ–ª—É—á–∞–µ—Ç {gift_amount:.2f} –±–∞–∫—Å–æ–≤! üéâ\n"
                f"üìä –°–µ–≥–æ–¥–Ω—è –≤ —ç—Ç–æ–º —á–∞—Ç–µ –æ—Å—Ç–∞–ª–æ—Å—å –ø–æ–¥–≥–æ–Ω–æ–≤: {remaining_chat}"
            )

# ==================== –ö–û–ù–ï–¶ –ß–ê–°–¢–ò 4 ====================
# ==================== –ß–ê–°–¢–¨ 5.1: –ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–ò–í–ù–ê–Ø –ü–ê–ù–ï–õ–¨ (–£–ü–†–ê–í–õ–ï–ù–ò–ï –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø–ú–ò, –ú–ê–ì–ê–ó–ò–ù–û–ú, –ö–ê–ù–ê–õ–ê–ú–ò, –ü–†–û–ú–û–ö–û–î–ê–ú–ò, –ß–ê–¢–ê–ú–ò) ====================
# –ü–æ–ª–Ω–æ—Å—Ç—å—é –ø–µ—Ä–µ–ø–∏—Å–∞–Ω–æ –¥–ª—è aiogram 3.x. –í—Å–µ –æ—à–∏–±–∫–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã.
# - –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –ø–∞–≥–∏–Ω–∞—Ü–∏—è –≤–æ –≤—Å–µ—Ö —Å–ø–∏—Å–∫–∞—Ö (—É–±—Ä–∞–Ω—ã –±–ª–æ–∫–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞ –∏–∑ —Ç–µ–∫—Å—Ç–∞)
# - –î–æ–±–∞–≤–ª–µ–Ω—ã –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ –∏–º–ø–æ—Ä—Ç—ã
# - –£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–∞ —Ä–∞–±–æ—Ç–∞ —Å —Å–æ—Å—Ç–æ—è–Ω–∏—è–º–∏
# - –î–æ–±–∞–≤–ª–µ–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä allow_negative=False –≤–æ –≤—Å–µ –≤—ã–∑–æ–≤—ã update_user_balance
# - –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ —Ä–∞–±–æ—Ç–∞ —Å –¥–∞—Ç–∞–º–∏ (datetime)

import asyncio
import io
import csv
import json
import logging
from datetime import datetime, timedelta

from aiogram import F, types
from aiogram.filters import Command, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery, Message, InlineKeyboardMarkup, InlineKeyboardButton, BufferedInputFile
from aiogram.exceptions import TelegramBadRequest, TelegramForbiddenError, TelegramRetryAfter, TelegramAPIError

# –í—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ —á–∞—Å—Ç–µ–π 1-4 –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞—é—Ç—Å—è –¥–æ—Å—Ç—É–ø–Ω—ã–º–∏
# (bot, dp, db_pool, redis_client, –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã, —Å–æ—Å—Ç–æ—è–Ω–∏—è)

# ==================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ê–î–ú–ò–ù–ö–ò ====================
async def check_admin_permissions(user_id: int, permission: str) -> bool:
    return await has_permission(user_id, permission)

def safe_split_text(text: str, limit: int = 4000) -> list:
    """–†–∞–∑–±–∏–≤–∞–µ—Ç –¥–ª–∏–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –Ω–∞ —á–∞—Å—Ç–∏, –Ω–µ —Ä–∞–∑—Ä—ã–≤–∞—è —Å—Ç—Ä–æ–∫–∏."""
    lines = text.split('\n')
    parts = []
    current = ""
    for line in lines:
        if len(current) + len(line) + 1 > limit:
            parts.append(current)
            current = line
        else:
            if current:
                current += '\n' + line
            else:
                current = line
    if current:
        parts.append(current)
    return parts

# ==================== –ö–ê–¢–ï–ì–û–†–ò–ò –ù–ê–°–¢–†–û–ï–ö (—Ç–æ–ª—å–∫–æ –¥–ª—è —Å—Å—ã–ª–∫–∏, –ø–æ–ª–Ω—ã–π —Å–ø–∏—Å–æ–∫ –≤ —á–∞—Å—Ç–∏ 5.2) ====================
# –ó–¥–µ—Å—å –Ω–µ –Ω—É–∂–µ–Ω, –æ—Å—Ç–∞–≤–ª—è–µ–º –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏, –Ω–æ —Å–∞–º —Å–ø–∏—Å–æ–∫ –±—É–¥–µ—Ç –≤ 5.2

# ==================== –ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ –ê–î–ú–ò–ù–ö–ò ====================
@dp.message(F.text == "‚öôÔ∏è –ê–¥–º–∏–Ω –ø–∞–Ω–µ–ª—å")
async def admin_panel(message: Message):
    if message.chat.type != 'private':
        return
    user_id = message.from_user.id
    logging.info(f"üîç –ê–¥–º–∏–Ω–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id}")
    logging.info(f"üîç is_super_admin: {await is_super_admin(user_id)}")
    logging.info(f"üîç is_junior_admin: {await is_junior_admin(user_id)}")
    logging.info(f"üîç is_admin: {await is_admin(user_id)}")
    
    if not await is_admin(user_id):
        await message.answer("‚ùå –£ —Ç–µ–±—è –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.")
        return
    
    try:
        permissions = await get_admin_permissions(user_id)
        logging.info(f"üîç permissions: {permissions}")
        await send_with_media(message.chat.id, "–ü–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:", media_key='admin', reply_markup=admin_main_keyboard(permissions))
        logging.info("‚úÖ –ê–¥–º–∏–Ω–∫–∞ —É—Å–ø–µ—à–Ω–æ –æ—Ç–∫—Ä—ã—Ç–∞")
    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞: {e}")
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {e}")


@dp.message(F.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω–∫—É")
async def back_to_admin(message: Message):
    if message.chat.type != 'private':
        return
    if not await is_admin(message.from_user.id):
        return
    permissions = await get_admin_permissions(message.from_user.id)
    await send_with_media(message.chat.id, "–ü–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:", media_key='admin', reply_markup=admin_main_keyboard(permissions))

# ==================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø–ú–ò ====================
@dp.message(F.text == "üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏")
async def admin_users_menu(message: Message):
    if not await check_admin_permissions(message.from_user.id, "manage_users"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await send_with_media(message.chat.id, "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏:", media_key='admin_users', reply_markup=admin_users_keyboard())

# ----- –ù–∞—á–∏—Å–ª–µ–Ω–∏–µ/—Å–ø–∏—Å–∞–Ω–∏–µ –±–∞–∫—Å–æ–≤ -----
@dp.message(F.text == "üí∞ –ù–∞—á–∏—Å–ª–∏—Ç—å –±–∞–∫—Å—ã")
async def add_balance_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_users"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await message.answer("–í–≤–µ–¥–∏ ID –∏–ª–∏ @username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:", reply_markup=back_keyboard())
    await state.set_state(AddBalance.user_id)

@dp.message(AddBalance.user_id, F.text)
async def add_balance_user(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    user_data = await find_user_by_input(message.text)
    if not user_data:
        await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await state.clear()
        return
    uid = user_data['user_id']
    await state.update_data(user_id=uid)
    await message.answer("–í–≤–µ–¥–∏ —Å—É–º–º—É –Ω–∞—á–∏—Å–ª–µ–Ω–∏—è (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω—É—é, –Ω–∞–ø—Ä–∏–º–µ—Ä 10.50):")
    await state.set_state(AddBalance.amount)

@dp.message(AddBalance.amount, F.text)
async def add_balance_amount(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    try:
        amount = float(message.text)
        if amount <= 0:
            raise ValueError
        amount = round(amount, 2)
        max_input = await get_setting_float("max_input_number")
        if amount > max_input:
            await message.answer(f"‚ùå –°—É–º–º–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è (–º–∞–∫—Å–∏–º—É–º {max_input:.2f}).")
            return
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ —Å —Ç–æ—á–Ω–æ—Å—Ç—å—é –¥–æ —Å–æ—Ç—ã—Ö.")
        return
    data = await state.get_data()
    uid = data['user_id']
    try:
        success, new_balance, _ = await update_user_balance(uid, amount, allow_negative=False)
        if not success:
            await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞—á–∏—Å–ª–∏—Ç—å —Å—Ä–µ–¥—Å—Ç–≤–∞ (–≤–æ–∑–º–æ–∂–Ω–æ, –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å –Ω–µ —Ä–∞–∑—Ä–µ—à—ë–Ω).")
            return
        await message.answer(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {uid} –Ω–∞—á–∏—Å–ª–µ–Ω–æ {amount:.2f} –±–∞–∫—Å–æ–≤.")
        await safe_send_message(uid, f"üí∞ –í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω–æ {amount:.2f} –±–∞–∫—Å–æ–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")
    except Exception as e:
        logging.error(f"Add balance error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")
    await state.clear()

@dp.message(F.text == "üí∏ –°–ø–∏—Å–∞—Ç—å –±–∞–∫—Å—ã")
async def remove_balance_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_users"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await message.answer("–í–≤–µ–¥–∏ ID –∏–ª–∏ @username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:", reply_markup=back_keyboard())
    await state.set_state(RemoveBalance.user_id)

@dp.message(RemoveBalance.user_id, F.text)
async def remove_balance_user(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    user_data = await find_user_by_input(message.text)
    if not user_data:
        await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await state.clear()
        return
    uid = user_data['user_id']
    await state.update_data(user_id=uid)
    await message.answer("–í–≤–µ–¥–∏ —Å—É–º–º—É —Å–ø–∏—Å–∞–Ω–∏—è (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω—É—é):")
    await state.set_state(RemoveBalance.amount)

@dp.message(RemoveBalance.amount, F.text)
async def remove_balance_amount(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    try:
        amount = float(message.text)
        if amount <= 0:
            raise ValueError
        amount = round(amount, 2)
        max_input = await get_setting_float("max_input_number")
        if amount > max_input:
            await message.answer(f"‚ùå –°—É–º–º–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è (–º–∞–∫—Å–∏–º—É–º {max_input:.2f}).")
            return
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.")
        return
    data = await state.get_data()
    uid = data['user_id']
    try:
        success, new_balance, _ = await update_user_balance(uid, -amount, allow_negative=False)
        if not success:
            await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è —Å–ø–∏—Å–∞–Ω–∏—è.")
            return
        await message.answer(f"‚úÖ –£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {uid} —Å–ø–∏—Å–∞–Ω–æ {amount:.2f} –±–∞–∫—Å–æ–≤.")
        await safe_send_message(uid, f"üí∏ –£ –≤–∞—Å —Å–ø–∏—Å–∞–Ω–æ {amount:.2f} –±–∞–∫—Å–æ–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")
    except Exception as e:
        logging.error(f"Remove balance error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")
    await state.clear()

# ----- –ù–∞—á–∏—Å–ª–µ–Ω–∏–µ/—Å–ø–∏—Å–∞–Ω–∏–µ —Ä–µ–ø—É—Ç–∞—Ü–∏–∏ -----
@dp.message(F.text == "‚≠êÔ∏è –ù–∞—á–∏—Å–ª–∏—Ç—å —Ä–µ–ø—É—Ç–∞—Ü–∏—é")
async def add_reputation_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_users"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await message.answer("–í–≤–µ–¥–∏ ID –∏–ª–∏ @username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:", reply_markup=back_keyboard())
    await state.set_state(AddReputation.user_id)

@dp.message(AddReputation.user_id, F.text)
async def add_reputation_user(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    user_data = await find_user_by_input(message.text)
    if not user_data:
        await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await state.clear()
        return
    uid = user_data['user_id']
    await state.update_data(user_id=uid)
    await message.answer("–í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–ø—É—Ç–∞—Ü–∏–∏ –¥–ª—è –Ω–∞—á–∏—Å–ª–µ–Ω–∏—è (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ):")
    await state.set_state(AddReputation.amount)

@dp.message(AddReputation.amount, F.text)
async def add_reputation_amount(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    try:
        amount = int(message.text)
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.")
        return
    data = await state.get_data()
    uid = data['user_id']
    try:
        await update_user_reputation(uid, amount)
        await message.answer(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {uid} –Ω–∞—á–∏—Å–ª–µ–Ω–æ {amount} —Ä–µ–ø—É—Ç–∞—Ü–∏–∏.")
        await safe_send_message(uid, f"‚≠êÔ∏è –í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω–æ {amount} —Ä–µ–ø—É—Ç–∞—Ü–∏–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")
    except Exception as e:
        logging.error(f"Add reputation error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")
    await state.clear()

@dp.message(F.text == "üîª –°–Ω—è—Ç—å —Ä–µ–ø—É—Ç–∞—Ü–∏—é")
async def remove_reputation_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_users"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await message.answer("–í–≤–µ–¥–∏ ID –∏–ª–∏ @username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:", reply_markup=back_keyboard())
    await state.set_state(RemoveReputation.user_id)

@dp.message(RemoveReputation.user_id, F.text)
async def remove_reputation_user(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    user_data = await find_user_by_input(message.text)
    if not user_data:
        await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await state.clear()
        return
    uid = user_data['user_id']
    await state.update_data(user_id=uid)
    await message.answer("–í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–ø—É—Ç–∞—Ü–∏–∏ –¥–ª—è —Å–Ω—è—Ç–∏—è (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ):")
    await state.set_state(RemoveReputation.amount)

@dp.message(RemoveReputation.amount, F.text)
async def remove_reputation_amount(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    try:
        amount = int(message.text)
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.")
        return
    data = await state.get_data()
    uid = data['user_id']
    try:
        await update_user_reputation(uid, -amount)
        await message.answer(f"‚úÖ –£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {uid} —Å–Ω—è—Ç–æ {amount} —Ä–µ–ø—É—Ç–∞—Ü–∏–∏.")
        await safe_send_message(uid, f"üîª –£ –≤–∞—Å —Å–Ω—è—Ç–æ {amount} —Ä–µ–ø—É—Ç–∞—Ü–∏–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")
    except Exception as e:
        logging.error(f"Remove reputation error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")
    await state.clear()

# ----- –ù–∞—á–∏—Å–ª–µ–Ω–∏–µ –æ–ø—ã—Ç–∞ -----
@dp.message(F.text == "üìà –ù–∞—á–∏—Å–ª–∏—Ç—å –æ–ø—ã—Ç")
async def add_exp_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_users"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await message.answer("–í–≤–µ–¥–∏ ID –∏–ª–∏ @username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:", reply_markup=back_keyboard())
    await state.set_state(AddExp.user_id)

@dp.message(AddExp.user_id, F.text)
async def add_exp_user(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    user_data = await find_user_by_input(message.text)
    if not user_data:
        await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await state.clear()
        return
    uid = user_data['user_id']
    await state.update_data(user_id=uid)
    await message.answer("–í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–ø—ã—Ç–∞ –¥–ª—è –Ω–∞—á–∏—Å–ª–µ–Ω–∏—è (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ):")
    await state.set_state(AddExp.amount)

@dp.message(AddExp.amount, F.text)
async def add_exp_amount(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    try:
        amount = int(message.text)
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.")
        return
    data = await state.get_data()
    uid = data['user_id']
    try:
        await add_exp(uid, amount)
        await message.answer(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {uid} –Ω–∞—á–∏—Å–ª–µ–Ω–æ {amount} –æ–ø—ã—Ç–∞.")
    except Exception as e:
        logging.error(f"Add exp error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")
    await state.clear()

# ----- –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —É—Ä–æ–≤–Ω—è -----
@dp.message(F.text == "üîù –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å")
async def set_level_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_users"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await message.answer("–í–≤–µ–¥–∏ ID –∏–ª–∏ @username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:", reply_markup=back_keyboard())
    await state.set_state(SetLevel.user_id)

@dp.message(SetLevel.user_id, F.text)
async def set_level_user(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    user_data = await find_user_by_input(message.text)
    if not user_data:
        await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await state.clear()
        return
    uid = user_data['user_id']
    await state.update_data(user_id=uid)
    await message.answer("–í–≤–µ–¥–∏ –Ω–æ–≤—ã–π —É—Ä–æ–≤–µ–Ω—å (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ ‚â• 1):")
    await state.set_state(SetLevel.level)

@dp.message(SetLevel.level, F.text)
async def set_level_value(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    try:
        level = int(message.text)
        if level < 1:
            raise ValueError
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ ‚â• 1.")
        return
    data = await state.get_data()
    uid = data['user_id']
    try:
        async with db_pool.acquire() as conn:
            await conn.execute("UPDATE users SET level=$1 WHERE user_id=$2", level, uid)
        await message.answer(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {uid} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —É—Ä–æ–≤–µ–Ω—å {level}.")
        await safe_send_message(uid, f"üîù –í–∞—à —É—Ä–æ–≤–µ–Ω—å –∏–∑–º–µ–Ω—ë–Ω –Ω–∞ {level} –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")
    except Exception as e:
        logging.error(f"Set level error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")
    await state.clear()

# ----- –ù–∞—á–∏—Å–ª–µ–Ω–∏–µ/—Å–ø–∏—Å–∞–Ω–∏–µ –±–∏—Ç–∫–æ–∏–Ω–æ–≤ -----
@dp.message(F.text == "‚Çø –ù–∞—á–∏—Å–ª–∏—Ç—å –±–∏—Ç–∫–æ–∏–Ω—ã")
async def add_bitcoin_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_users"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await message.answer("–í–≤–µ–¥–∏ ID –∏–ª–∏ @username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:", reply_markup=back_keyboard())
    await state.set_state(AddBitcoin.user_id)

@dp.message(AddBitcoin.user_id, F.text)
async def add_bitcoin_user(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    user_data = await find_user_by_input(message.text)
    if not user_data:
        await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await state.clear()
        return
    uid = user_data['user_id']
    await state.update_data(user_id=uid)
    await message.answer("–í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–∏—Ç–∫–æ–∏–Ω–æ–≤ (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω–æ–µ, –Ω–∞–ø—Ä–∏–º–µ—Ä 1.5):")
    await state.set_state(AddBitcoin.amount)

@dp.message(AddBitcoin.amount, F.text)
async def add_bitcoin_amount(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    try:
        amount = float(message.text)
        if amount <= 0:
            raise ValueError
        amount = round(amount, 4)
        max_input = await get_setting_float("max_input_number")
        if amount > max_input:
            await message.answer(f"‚ùå –°—É–º–º–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è (–º–∞–∫—Å–∏–º—É–º {max_input:.4f}).")
            return
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω–æ–µ).")
        return
    data = await state.get_data()
    uid = data['user_id']
    try:
        success, new_balance = await update_user_bitcoin(uid, amount)
        if not success:
            await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞—á–∏—Å–ª–µ–Ω–∏–∏ –±–∏—Ç–∫–æ–∏–Ω–æ–≤.")
            return
        await message.answer(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {uid} –Ω–∞—á–∏—Å–ª–µ–Ω–æ {amount:.4f} BTC.")
        await safe_send_message(uid, f"‚Çø –í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω–æ {amount:.4f} BTC –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")
    except Exception as e:
        logging.error(f"Add bitcoin error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")
    await state.clear()

@dp.message(F.text == "‚Çø –°–ø–∏—Å–∞—Ç—å –±–∏—Ç–∫–æ–∏–Ω—ã")
async def remove_bitcoin_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_users"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await message.answer("–í–≤–µ–¥–∏ ID –∏–ª–∏ @username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:", reply_markup=back_keyboard())
    await state.set_state(RemoveBitcoin.user_id)

@dp.message(RemoveBitcoin.user_id, F.text)
async def remove_bitcoin_user(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    user_data = await find_user_by_input(message.text)
    if not user_data:
        await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await state.clear()
        return
    uid = user_data['user_id']
    await state.update_data(user_id=uid)
    await message.answer("–í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–∏—Ç–∫–æ–∏–Ω–æ–≤ –¥–ª—è —Å–ø–∏—Å–∞–Ω–∏—è:")
    await state.set_state(RemoveBitcoin.amount)

@dp.message(RemoveBitcoin.amount, F.text)
async def remove_bitcoin_amount(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    try:
        amount = float(message.text)
        if amount <= 0:
            raise ValueError
        amount = round(amount, 4)
        max_input = await get_setting_float("max_input_number")
        if amount > max_input:
            await message.answer(f"‚ùå –°—É–º–º–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è (–º–∞–∫—Å–∏–º—É–º {max_input:.4f}).")
            return
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.")
        return
    data = await state.get_data()
    uid = data['user_id']
    try:
        success, new_balance = await update_user_bitcoin(uid, -amount)
        if not success:
            await message.answer(f"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ BTC —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {uid}.")
            return
        await message.answer(f"‚úÖ –£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {uid} —Å–ø–∏—Å–∞–Ω–æ {amount:.4f} BTC.")
        await safe_send_message(uid, f"‚Çø –£ –≤–∞—Å —Å–ø–∏—Å–∞–Ω–æ {amount:.4f} BTC –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")
    except Exception as e:
        logging.error(f"Remove bitcoin error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")
    await state.clear()

# ----- –ù–∞—á–∏—Å–ª–µ–Ω–∏–µ/—Å–ø–∏—Å–∞–Ω–∏–µ –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞ -----
@dp.message(F.text == "‚öîÔ∏è –ù–∞—á–∏—Å–ª–∏—Ç—å –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç")
async def add_authority_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_users"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await message.answer("–í–≤–µ–¥–∏ ID –∏–ª–∏ @username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:", reply_markup=back_keyboard())
    await state.set_state(AddAuthority.user_id)

@dp.message(AddAuthority.user_id, F.text)
async def add_authority_user(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    user_data = await find_user_by_input(message.text)
    if not user_data:
        await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await state.clear()
        return
    uid = user_data['user_id']
    await state.update_data(user_id=uid)
    await message.answer("–í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞ (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ):")
    await state.set_state(AddAuthority.amount)

@dp.message(AddAuthority.amount, F.text)
async def add_authority_amount(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    try:
        amount = int(message.text)
        if amount <= 0:
            raise ValueError
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.")
        return
    data = await state.get_data()
    uid = data['user_id']
    try:
        await update_user_authority(uid, amount)
        await message.answer(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {uid} –Ω–∞—á–∏—Å–ª–µ–Ω–æ {amount} –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞.")
        await safe_send_message(uid, f"‚öîÔ∏è –í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω–æ {amount} –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")
    except Exception as e:
        logging.error(f"Add authority error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")
    await state.clear()

@dp.message(F.text == "‚öîÔ∏è –°–ø–∏—Å–∞—Ç—å –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç")
async def remove_authority_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_users"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await message.answer("–í–≤–µ–¥–∏ ID –∏–ª–∏ @username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:", reply_markup=back_keyboard())
    await state.set_state(RemoveAuthority.user_id)

@dp.message(RemoveAuthority.user_id, F.text)
async def remove_authority_user(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    user_data = await find_user_by_input(message.text)
    if not user_data:
        await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await state.clear()
        return
    uid = user_data['user_id']
    await state.update_data(user_id=uid)
    await message.answer("–í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞ –¥–ª—è —Å–Ω—è—Ç–∏—è:")
    await state.set_state(RemoveAuthority.amount)

@dp.message(RemoveAuthority.amount, F.text)
async def remove_authority_amount(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    try:
        amount = int(message.text)
        if amount <= 0:
            raise ValueError
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.")
        return
    data = await state.get_data()
    uid = data['user_id']
    try:
        await update_user_authority(uid, -amount)
        await message.answer(f"‚úÖ –£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {uid} —Å–Ω—è—Ç–æ {amount} –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞.")
        await safe_send_message(uid, f"‚öîÔ∏è –£ –≤–∞—Å —Å–Ω—è—Ç–æ {amount} –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")
    except Exception as e:
        logging.error(f"Remove authority error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")
    await state.clear()

# ----- –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è -----
@dp.message(F.text == "üë• –ù–∞–π—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
async def find_user_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_users"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await message.answer("–í–≤–µ–¥–∏ ID –∏–ª–∏ @username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:", reply_markup=back_keyboard())
    await state.set_state(FindUser.query)

@dp.message(FindUser.query, F.text)
async def find_user_result(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        permissions = await get_admin_permissions(message.from_user.id)
        await message.answer("–ü–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:", reply_markup=admin_main_keyboard(permissions))
        return
    user_data = await find_user_by_input(message.text)
    if not user_data:
        await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await state.clear()
        return
    uid = user_data['user_id']
    name = user_data['first_name']
    bal = float(user_data['balance'])
    rep = user_data['reputation']
    spent = float(user_data['total_spent'])
    joined = user_data['joined_date']
    attempts = user_data['theft_attempts']
    success = user_data['theft_success']
    failed = user_data['theft_failed']
    protected = user_data['theft_protected']
    level = user_data['level']
    exp = user_data['exp']
    bitcoin = float(user_data['bitcoin_balance']) if user_data['bitcoin_balance'] is not None else 0.0
    authority = user_data['authority_balance'] or 0
    smuggle_success = user_data.get('smuggle_success', 0)
    smuggle_fail = user_data.get('smuggle_fail', 0)
    banned = await is_banned(uid)
    ban_status = "‚õî –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω" if banned else "‚úÖ –ê–∫—Ç–∏–≤–µ–Ω"
    text = (
        f"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {name} (ID: {uid})\n"
        f"üìä –£—Ä–æ–≤–µ–Ω—å: {level}, –æ–ø—ã—Ç: {exp}\n"
        f"üí∞ –ë–∞–ª–∞–Ω—Å: {bal:.2f} –±–∞–∫—Å–æ–≤\n"
        f"‚Çø –ë–∏—Ç–∫–æ–∏–Ω—ã: {bitcoin:.4f} BTC\n"
        f"‚öîÔ∏è –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç: {authority}\n"
        f"‚≠êÔ∏è –†–µ–ø—É—Ç–∞—Ü–∏—è: {rep}\n"
        f"üí∏ –ü–æ—Ç—Ä–∞—á–µ–Ω–æ: {spent:.2f} –±–∞–∫—Å–æ–≤\n"
        f"üìÖ –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è: {joined}\n"
        f"üî´ –û–≥—Ä–∞–±–ª–µ–Ω–∏–π: {attempts} (—É—Å–ø–µ—à–Ω–æ: {success}, –ø—Ä–æ–≤–∞–ª: {failed})\n"
        f"üì¶ –ö–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥–∞: —É—Å–ø–µ—à–Ω–æ {smuggle_success}, –ø—Ä–æ–≤–∞–ª {smuggle_fail}\n"
        f"–°—Ç–∞—Ç—É—Å: {ban_status}"
    )
    await message.answer(text)
    await state.clear()  # —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ

# ----- –≠–∫—Å–ø–æ—Ä—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π -----
@dp.message(F.text == "üìä –≠–∫—Å–ø–æ—Ä—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π")
async def export_users(message: Message):
    if not await check_admin_permissions(message.from_user.id, "manage_users"):
        return
    try:
        csv_data = await export_users_to_csv()
        if not csv_data:
            await message.answer("–ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞.")
            return
        await message.answer_document(
            BufferedInputFile(csv_data, filename="users.csv"),
            caption="üìä –°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"
        )
    except Exception as e:
        logging.error(f"Export error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ.")

# ----- –°–±—Ä–æ—Å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ (–¥–ª—è –∞–¥–º–∏–Ω–∞, —Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º –ø–æ –∫–ª—é—á—É) -----
@dp.message(F.text == "üîÑ –°–±—Ä–æ—Å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏")
async def reset_stats_admin_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_users"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await message.answer("–í–≤–µ–¥–∏ ID –∏–ª–∏ @username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, —á—å—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –Ω—É–∂–Ω–æ —Å–±—Ä–æ—Å–∏—Ç—å:", reply_markup=back_keyboard())
    await state.set_state(AdminResetStats.user_id)

@dp.message(AdminResetStats.user_id, F.text)
async def reset_stats_admin_user(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    user_data = await find_user_by_input(message.text)
    if not user_data:
        await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await state.clear()
        return
    uid = user_data['user_id']
    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–ª—é—á
    key = await generate_reset_key(uid)
    await state.update_data(target_uid=uid, generated_key=key)
    await message.answer(
        f"üîë –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω –∫–ª—é—á –¥–ª—è —Å–±—Ä–æ—Å–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {uid}:\n"
        f"<code>{key}</code>\n\n"
        f"‚ö†Ô∏è –î–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Å–±—Ä–æ—Å–∞ –Ω–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ.\n"
        f"–ö–ª—é—á –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω 10 –º–∏–Ω—É—Ç.",
        reply_markup=reset_stats_confirm_keyboard(uid)
    )
    # –°–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–µ –∑–∞–≤–µ—Ä—à–∞–µ–º, –∂–¥—ë–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –ø–æ –∫–Ω–æ–ø–∫–µ

@dp.callback_query(F.data.startswith("reset_stats_confirm_"))
async def reset_stats_confirm(callback: CallbackQuery, state: FSMContext):
    if not await check_admin_permissions(callback.from_user.id, "manage_users"):
        await callback.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    uid = int(callback.data.split("_")[3])
    data = await state.get_data()
    if data.get('target_uid') != uid:
        await callback.answer("‚ùå –î–∞–Ω–Ω—ã–µ —É—Å—Ç–∞—Ä–µ–ª–∏, –Ω–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.", show_alert=True)
        await state.clear()
        return
    key = data.get('generated_key')
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª—é—á (–æ–Ω –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º, —Ç.–∫. –º—ã –µ–≥–æ —Ç–æ–ª—å–∫–æ —á—Ç–æ —Å–æ–∑–¥–∞–ª–∏)
    if await verify_reset_key(key, uid):
        await reset_user_stats(uid)
        await callback.message.edit_text(f"‚úÖ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {uid} —É—Å–ø–µ—à–Ω–æ —Å–±—Ä–æ—à–µ–Ω–∞.")
        await safe_send_message(uid, "üîÑ –í–∞—à–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±—ã–ª–∞ —Å–±—Ä–æ—à–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")
    else:
        await callback.message.edit_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–±—Ä–æ—Å–µ (–∫–ª—é—á –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω). –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
    await state.clear()
    await callback.answer()

@dp.callback_query(F.data == "reset_stats_cancel")
async def reset_stats_cancel(callback: CallbackQuery, state: FSMContext):
    await state.clear()
    await callback.message.edit_text("‚ùå –°–±—Ä–æ—Å –æ—Ç–º–µ–Ω—ë–Ω.")
    await callback.answer()

# ----- –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –∏ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π -----
@dp.message(F.text == "‚õî –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å")
async def block_user_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_users"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await message.answer("–í–≤–µ–¥–∏ ID –∏–ª–∏ @username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏:", reply_markup=back_keyboard())
    await state.set_state(BlockUser.user_id)

@dp.message(BlockUser.user_id, F.text)
async def block_user_id(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    user_data = await find_user_by_input(message.text)
    if not user_data:
        await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await state.clear()
        return
    uid = user_data['user_id']
    if await is_admin(uid):
        await message.answer("‚ùå –ù–µ–ª—å–∑—è –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.")
        await state.clear()
        return
    await state.update_data(user_id=uid)
    await message.answer("–í–≤–µ–¥–∏ –ø—Ä–∏—á–∏–Ω—É –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ (–∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å '-'):")
    await state.set_state(BlockUser.reason)

@dp.message(BlockUser.reason, F.text)
async def block_user_reason(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    reason = message.text if message.text != '-' else None
    data = await state.get_data()
    uid = data['user_id']
    try:
        async with db_pool.acquire() as conn:
            await conn.execute(
                "INSERT INTO banned_users (user_id, banned_by, banned_date, reason) VALUES ($1, $2, $3, $4) ON CONFLICT (user_id) DO UPDATE SET banned_by=$2, banned_date=$3, reason=$4",
                uid, message.from_user.id, datetime.now().strftime("%Y-%m-%d %H:%M:%S"), reason
            )
        await message.answer(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {uid} –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω.")
        await safe_send_message(uid, f"‚õî –í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –≤ –±–æ—Ç–µ. –ü—Ä–∏—á–∏–Ω–∞: {reason if reason else '–Ω–µ —É–∫–∞–∑–∞–Ω–∞'}")
    except Exception as e:
        logging.error(f"Block user error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")
    await state.clear()

@dp.message(F.text == "‚úÖ –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å")
async def unblock_user_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_users"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await message.answer("–í–≤–µ–¥–∏ ID –∏–ª–∏ @username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏:", reply_markup=back_keyboard())
    await state.set_state(UnblockUser.user_id)

@dp.message(UnblockUser.user_id, F.text)
async def unblock_user_finish(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_users_menu(message)
        return
    user_data = await find_user_by_input(message.text)
    if not user_data:
        await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await state.clear()
        return
    uid = user_data['user_id']
    try:
        async with db_pool.acquire() as conn:
            await conn.execute("DELETE FROM banned_users WHERE user_id=$1", uid)
        await message.answer(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {uid} —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω.")
        await safe_send_message(uid, f"‚úÖ –í—ã —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –≤ –±–æ—Ç–µ.")
    except Exception as e:
        logging.error(f"Unblock user error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")
    await state.clear()

# ==================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ú–ê–ì–ê–ó–ò–ù–û–ú ====================
@dp.message(F.text == "üõí –ú–∞–≥–∞–∑–∏–Ω")
async def admin_shop_menu(message: Message):
    if not await check_admin_permissions(message.from_user.id, "manage_shop"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await send_with_media(message.chat.id, "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–∞–≥–∞–∑–∏–Ω–æ–º:", media_key='admin_shop', reply_markup=admin_shop_keyboard())

@dp.message(F.text == "‚ûï –î–æ–±–∞–≤–∏—Ç—å —Ç–æ–≤–∞—Ä")
async def add_shop_item_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_shop"):
        return
    await message.answer("–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞:", reply_markup=back_keyboard())
    await state.set_state(AddShopItem.name)

@dp.message(AddShopItem.name, F.text)
async def add_shop_item_name(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_shop_menu(message)
        return
    await state.update_data(name=message.text)
    await message.answer("–í–≤–µ–¥–∏ –æ–ø–∏—Å–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞:")
    await state.set_state(AddShopItem.description)

@dp.message(AddShopItem.description, F.text)
async def add_shop_item_description(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_shop_menu(message)
        return
    await state.update_data(description=message.text)
    await message.answer("–í–≤–µ–¥–∏ —Ü–µ–Ω—É (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω—É—é):")
    await state.set_state(AddShopItem.price)

@dp.message(AddShopItem.price, F.text)
async def add_shop_item_price(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_shop_menu(message)
        return
    try:
        price = float(message.text)
        if price <= 0:
            raise ValueError
        price = round(price, 2)
        max_input = await get_setting_float("max_input_number")
        if price > max_input:
            await message.answer(f"‚ùå –¶–µ–Ω–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è (–º–∞–∫—Å–∏–º—É–º {max_input:.2f}).")
            return
    except ValueError:
        await message.answer("‚ùå –¶–µ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω—ã–º).")
        return
    await state.update_data(price=price)
    await message.answer("–í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–≤–∞—Ä–∞ (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ, -1 –¥–ª—è –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–≥–æ):")
    await state.set_state(AddShopItem.stock)

@dp.message(AddShopItem.stock, F.text)
async def add_shop_item_stock(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_shop_menu(message)
        return
    try:
        stock = int(message.text)
        max_input = await get_setting_float("max_input_number")
        if stock > max_input:
            await message.answer(f"‚ùå –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ (–º–∞–∫—Å–∏–º—É–º {max_input}).")
            return
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.")
        return
    await state.update_data(stock=stock)
    await message.answer("–û—Ç–ø—Ä–∞–≤—å —Ñ–æ—Ç–æ –¥–ª—è —Ç–æ–≤–∞—Ä–∞ (–∏–ª–∏ '–Ω–µ—Ç'):")
    await state.set_state(AddShopItem.photo)

@dp.message(AddShopItem.photo, F.photo | F.text)
async def add_shop_item_photo(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_shop_menu(message)
        return
    photo_file_id = None
    if message.photo:
        photo_file_id = message.photo[-1].file_id
    elif message.text and message.text.lower() == '–Ω–µ—Ç':
        pass
    else:
        await message.answer("–û—Ç–ø—Ä–∞–≤—å —Ñ–æ—Ç–æ –∏–ª–∏ '–Ω–µ—Ç'.")
        return
    data = await state.get_data()
    try:
        async with db_pool.acquire() as conn:
            await conn.execute(
                "INSERT INTO shop_items (name, description, price, stock, photo_file_id) VALUES ($1, $2, $3, $4, $5)",
                data['name'], data['description'], data['price'], data['stock'], photo_file_id
            )
        await message.answer("‚úÖ –¢–æ–≤–∞—Ä –¥–æ–±–∞–≤–ª–µ–Ω!", reply_markup=admin_shop_keyboard())
    except Exception as e:
        logging.error(f"Add shop item error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Ç–æ–≤–∞—Ä–∞.")
    await state.clear()

@dp.message(F.text == "‚ûñ –£–¥–∞–ª–∏—Ç—å —Ç–æ–≤–∞—Ä")
async def remove_shop_item_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_shop"):
        return
    try:
        async with db_pool.acquire() as conn:
            items = await conn.fetch("SELECT id, name FROM shop_items ORDER BY id")
        if not items:
            await message.answer("–í –º–∞–≥–∞–∑–∏–Ω–µ –Ω–µ—Ç —Ç–æ–≤–∞—Ä–æ–≤.")
            return
        text = "–¢–æ–≤–∞—Ä—ã:\n" + "\n".join([f"ID {i['id']}: {i['name']}" for i in items])
        await message.answer(text + "\n\n–í–≤–µ–¥–∏ ID —Ç–æ–≤–∞—Ä–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=back_keyboard())
    except Exception as e:
        logging.error(f"List items for remove error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")
        return
    await state.set_state(RemoveShopItem.item_id)

@dp.message(RemoveShopItem.item_id, F.text)
async def remove_shop_item(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_shop_menu(message)
        return
    try:
        item_id = int(message.text)
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.")
        return
    try:
        async with db_pool.acquire() as conn:
            await conn.execute("DELETE FROM shop_items WHERE id=$1", item_id)
        await message.answer("‚úÖ –¢–æ–≤–∞—Ä —É–¥–∞–ª—ë–Ω, –µ—Å–ª–∏ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–ª.", reply_markup=admin_shop_keyboard())
    except Exception as e:
        logging.error(f"Remove shop item error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")
    await state.clear()

@dp.message(F.text == "‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–æ–≤–∞—Ä")
async def edit_shop_item_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_shop"):
        return
    await message.answer("–í–≤–µ–¥–∏ ID —Ç–æ–≤–∞—Ä–∞ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:", reply_markup=back_keyboard())
    await state.set_state(EditShopItem.item_id)

@dp.message(EditShopItem.item_id, F.text)
async def edit_shop_item_id(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_shop_menu(message)
        return
    try:
        item_id = int(message.text)
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.")
        return
    await state.update_data(item_id=item_id)
    await message.answer("–ß—Ç–æ —Ö–æ—á–µ—à—å –∏–∑–º–µ–Ω–∏—Ç—å? (price/stock)")
    await state.set_state(EditShopItem.field)

@dp.message(EditShopItem.field, F.text)
async def edit_shop_item_field(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_shop_menu(message)
        return
    field = message.text.lower()
    if field not in ['price', 'stock']:
        await message.answer("‚ùå –ú–æ–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å —Ç–æ–ª—å–∫–æ price –∏–ª–∏ stock.")
        return
    await state.update_data(field=field)
    await message.answer(f"–í–≤–µ–¥–∏ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è {field}:")
    await state.set_state(EditShopItem.value)

@dp.message(EditShopItem.value, F.text)
async def edit_shop_item_value(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_shop_menu(message)
        return
    data = await state.get_data()
    item_id = data['item_id']
    field = data['field']

    try:
        if field == 'price':
            value = float(message.text)
            if value <= 0:
                raise ValueError
            value = round(value, 2)
            max_input = await get_setting_float("max_input_number")
            if value > max_input:
                await message.answer(f"‚ùå –¶–µ–Ω–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è (–º–∞–∫—Å–∏–º—É–º {max_input:.2f}).")
                return
        else:  # stock
            value = int(message.text)
            max_input = await get_setting_float("max_input_number")
            if value > max_input:
                await message.answer(f"‚ùå –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ (–º–∞–∫—Å–∏–º—É–º {max_input}).")
                return
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ.")
        return

    async with db_pool.acquire() as conn:
        if field == 'price':
            await conn.execute("UPDATE shop_items SET price=$1 WHERE id=$2", value, item_id)
        else:  # stock
            await conn.execute("UPDATE shop_items SET stock=$1 WHERE id=$2", value, item_id)
    await message.answer("‚úÖ –¢–æ–≤–∞—Ä –æ–±–Ω–æ–≤–ª—ë–Ω.", reply_markup=admin_shop_keyboard())
    await state.clear()

# ----- –°–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤ (—Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–π –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π) -----
@dp.message(F.text == "üìã –°–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤")
async def list_shop_items(message: Message, page: int = 1):
    if not await check_admin_permissions(message.from_user.id, "manage_shop"):
        return
    
    offset = (page - 1) * ITEMS_PER_PAGE
    try:
        async with db_pool.acquire() as conn:
            total = await conn.fetchval("SELECT COUNT(*) FROM shop_items")
            items = await conn.fetch(
                "SELECT id, name, description, price, stock, photo_file_id FROM shop_items ORDER BY id LIMIT $1 OFFSET $2",
                ITEMS_PER_PAGE, offset
            )
        if not items:
            await message.answer("–í –º–∞–≥–∞–∑–∏–Ω–µ –Ω–µ—Ç —Ç–æ–≤–∞—Ä–æ–≤.")
            return
        text = f"üì¶ –¢–æ–≤–∞—Ä—ã (—Å—Ç—Ä–∞–Ω–∏—Ü–∞ {page}):\n"
        for item in items:
            text += f"\nID {item['id']} | {item['name']}\n{item['description']}\nüí∞ {float(item['price']):.2f} | –Ω–∞–ª–∏—á–∏–µ: {item['stock'] if item['stock']!=-1 else '‚àû'}\n"
        kb = []
        nav_buttons = []
        if page > 1:
            nav_buttons.append(InlineKeyboardButton(text="‚¨ÖÔ∏è", callback_data=f"shopitems_page_{page-1}"))
        if offset + ITEMS_PER_PAGE < total:
            nav_buttons.append(InlineKeyboardButton(text="‚û°Ô∏è", callback_data=f"shopitems_page_{page+1}"))
        if nav_buttons:
            kb.append(nav_buttons)
        if kb:
            await message.answer(text, reply_markup=InlineKeyboardMarkup(inline_keyboard=kb))
        else:
            await message.answer(text, reply_markup=admin_shop_keyboard())
    except Exception as e:
        logging.error(f"List shop items error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")

@dp.callback_query(F.data.startswith("shopitems_page_"))
async def shopitems_page_callback(callback: CallbackQuery):
    page = int(callback.data.split("_")[2])
    await list_shop_items(callback.message, page=page)
    await callback.answer()

# ----- –°–ø–∏—Å–æ–∫ –ø–æ–∫—É–ø–æ–∫ (—Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–π –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π) -----
@dp.message(F.text == "üõçÔ∏è –°–ø–∏—Å–æ–∫ –ø–æ–∫—É–ø–æ–∫")
async def admin_purchases(message: Message, page: int = 1):
    """–í—ã–≤–æ–¥ —Å–ø–∏—Å–∫–∞ –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö –ø–æ–∫—É–ø–æ–∫ —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π."""
    if not await check_admin_permissions(message.from_user.id, "manage_shop"):
        return
    
    offset = (page - 1) * ITEMS_PER_PAGE
    try:
        async with db_pool.acquire() as conn:
            total = await conn.fetchval(
                "SELECT COUNT(*) FROM purchases WHERE status='pending'"
            )
            rows = await conn.fetch(
                "SELECT p.id, u.user_id, u.username, s.name, p.purchase_date, p.status FROM purchases p "
                "JOIN users u ON p.user_id = u.user_id JOIN shop_items s ON p.item_id = s.id "
                "WHERE p.status='pending' ORDER BY p.purchase_date LIMIT $1 OFFSET $2",
                ITEMS_PER_PAGE, offset
            )
        if not rows:
            await message.answer("–ù–µ—Ç –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö –ø–æ–∫—É–ø–æ–∫.")
            return

        text = f"üõçÔ∏è –ù–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ –ø–æ–∫—É–ø–∫–∏ (—Å—Ç—Ä–∞–Ω–∏—Ü–∞ {page}):\n\n"
        for row in rows:
            pid, uid, username, item_name, date, status = row['id'], row['user_id'], row['username'] or "–Ω–µ—Ç username", row['name'], row['purchase_date'].strftime("%Y-%m-%d %H:%M:%S"), row['status']
            text += f"üÜî {pid}\n–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {uid} (@{username})\n–¢–æ–≤–∞—Ä: {item_name}\n–î–∞—Ç–∞: {date}\n\n"

        # –ü–∞–≥–∏–Ω–∞—Ü–∏—è
        kb = []
        nav_buttons = []
        if page > 1:
            nav_buttons.append(InlineKeyboardButton(text="‚¨ÖÔ∏è", callback_data=f"admin_purchases_page_{page-1}"))
        if offset + ITEMS_PER_PAGE < total:
            nav_buttons.append(InlineKeyboardButton(text="‚û°Ô∏è", callback_data=f"admin_purchases_page_{page+1}"))
        if nav_buttons:
            kb.append(nav_buttons)
        await message.answer(text, reply_markup=InlineKeyboardMarkup(inline_keyboard=kb) if kb else None)
    except Exception as e:
        logging.error(f"Admin purchases error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø–æ–∫—É–ø–æ–∫.")

@dp.callback_query(F.data.startswith("admin_purchases_page_"))
async def admin_purchases_page_callback(callback: CallbackQuery):
    page = int(callback.data.split("_")[3])
    await admin_purchases(callback.message, page=page)
    await callback.answer()

@dp.callback_query(F.data.startswith("purchase_done_"))
async def purchase_done(callback: CallbackQuery):
    if not await check_admin_permissions(callback.from_user.id, "manage_shop"):
        await callback.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤", show_alert=True)
        return
    purchase_id = int(callback.data.split("_")[2])
    try:
        async with db_pool.acquire() as conn:
            await conn.execute("UPDATE purchases SET status='completed' WHERE id=$1", purchase_id)
            user_id = await conn.fetchval("SELECT user_id FROM purchases WHERE id=$1", purchase_id)
            if user_id:
                await safe_send_message(user_id, "‚úÖ –¢–≤–æ—è –ø–æ–∫—É–ø–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞! –ê–¥–º–∏–Ω –≤—ã—Å–ª–∞–ª –ø–æ–¥–∞—Ä–æ–∫.")
        await callback.answer("–ü–æ–∫—É–ø–∫–∞ –æ—Ç–º–µ—á–µ–Ω–∞ –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω–∞—è")
        await callback.message.delete()
    except Exception as e:
        logging.error(f"Purchase done error: {e}")
        await callback.answer("–û—à–∏–±–∫–∞", show_alert=True)

@dp.callback_query(F.data.startswith("purchase_reject_"))
async def purchase_reject(callback: CallbackQuery, state: FSMContext):
    if not await check_admin_permissions(callback.from_user.id, "manage_shop"):
        await callback.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤", show_alert=True)
        return
    purchase_id = int(callback.data.split("_")[2])
    await state.update_data(purchase_id=purchase_id)
    await callback.message.answer("–í–≤–µ–¥–∏ –ø—Ä–∏—á–∏–Ω—É –æ—Ç–∫–∞–∑–∞ (–∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å '-'):", reply_markup=back_keyboard())
    await state.set_state(PurchaseReject.comment)

@dp.message(PurchaseReject.comment, F.text)
async def purchase_reject_comment(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_purchases(message)
        return
    comment = message.text if message.text != '-' else None
    data = await state.get_data()
    purchase_id = data.get('purchase_id')
    if not purchase_id:
        await message.answer("‚ùå –û—à–∏–±–∫–∞: ID –ø–æ–∫—É–ø–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await state.clear()
        return
    try:
        async with db_pool.acquire() as conn:
            await conn.execute("UPDATE purchases SET status='rejected', admin_comment=$1 WHERE id=$2", comment, purchase_id)
            user_id = await conn.fetchval("SELECT user_id FROM purchases WHERE id=$1", purchase_id)
            if user_id:
                await safe_send_message(user_id, f"‚ùå –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —Ç–≤–æ—è –ø–æ–∫—É–ø–∫–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∞. –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∞–¥–º–∏–Ω–∞: {comment if comment else '–Ω–µ —É–∫–∞–∑–∞–Ω'}")
        await message.answer("‚úÖ –ü–æ–∫—É–ø–∫–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞, –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π —Å–æ—Ö—Ä–∞–Ω—ë–Ω.")
    except Exception as e:
        logging.error(f"Purchase reject error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")
    await state.clear()
    await admin_purchases(message)

# ==================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ö–ê–ù–ê–õ–ê–ú–ò ====================
@dp.message(F.text == "üì¢ –ö–∞–Ω–∞–ª—ã")
async def admin_channel_menu(message: Message):
    if not await check_admin_permissions(message.from_user.id, "manage_channels"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await send_with_media(message.chat.id, "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–∞–º–∏:", media_key='admin_channels', reply_markup=admin_channel_keyboard())

@dp.message(F.text == "‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–∞–Ω–∞–ª")
async def add_channel_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_channels"):
        return
    await message.answer("–í–≤–µ–¥–∏ chat_id –∫–∞–Ω–∞–ª–∞ (–º–æ–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å —É @username_to_id_bot):", reply_markup=back_keyboard())
    await state.set_state(AddChannel.chat_id)

@dp.message(AddChannel.chat_id, F.text)
async def add_channel_chat_id(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_channel_menu(message)
        return
    await state.update_data(chat_id=message.text.strip())
    await message.answer("–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–∞:")
    await state.set_state(AddChannel.title)

@dp.message(AddChannel.title, F.text)
async def add_channel_title(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_channel_menu(message)
        return
    await state.update_data(title=message.text)
    await message.answer("–í–≤–µ–¥–∏ invite-—Å—Å—ã–ª–∫—É (–∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å '–Ω–µ—Ç'):")
    await state.set_state(AddChannel.invite_link)

@dp.message(AddChannel.invite_link, F.text)
async def add_channel_link(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_channel_menu(message)
        return
    link = None if message.text.lower() == '–Ω–µ—Ç' else message.text.strip()
    data = await state.get_data()
    try:
        async with db_pool.acquire() as conn:
            await conn.execute(
                "INSERT INTO channels (chat_id, title, invite_link) VALUES ($1, $2, $3)",
                data['chat_id'], data['title'], link
            )
        await message.answer("‚úÖ –ö–∞–Ω–∞–ª –¥–æ–±–∞–≤–ª–µ–Ω!", reply_markup=admin_channel_keyboard())
    except asyncpg.UniqueViolationError:
        await message.answer("‚ùå –ö–∞–Ω–∞–ª —Å —Ç–∞–∫–∏–º chat_id —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.")
    except Exception as e:
        logging.error(f"Add channel error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")
    await state.clear()

@dp.message(F.text == "‚ûñ –£–¥–∞–ª–∏—Ç—å –∫–∞–Ω–∞–ª")
async def remove_channel_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_channels"):
        return
    await message.answer("–í–≤–µ–¥–∏ chat_id –∫–∞–Ω–∞–ª–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=back_keyboard())
    await state.set_state(RemoveChannel.chat_id)

@dp.message(RemoveChannel.chat_id, F.text)
async def remove_channel(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_channel_menu(message)
        return
    chat_id = message.text.strip()
    try:
        async with db_pool.acquire() as conn:
            await conn.execute("DELETE FROM channels WHERE chat_id=$1", chat_id)
        await message.answer("‚úÖ –ö–∞–Ω–∞–ª —É–¥–∞–ª—ë–Ω, –µ—Å–ª–∏ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–ª.", reply_markup=admin_channel_keyboard())
    except Exception as e:
        logging.error(f"Remove channel error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")
    await state.clear()

@dp.message(F.text == "üìã –°–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤")
async def list_channels(message: Message):
    if not await check_admin_permissions(message.from_user.id, "manage_channels"):
        return
    channels = await get_channels()
    if not channels:
        await message.answer("–ù–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤.")
        return
    text = "üì∫ –ö–∞–Ω–∞–ª—ã –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏:\n"
    for chat_id, title, link in channels:
        text += f"‚Ä¢ {title} (chat_id: {chat_id})\n  –°—Å—ã–ª–∫–∞: {link or '–Ω–µ—Ç'}\n"
    parts = safe_split_text(text)
    for part in parts:
        await message.answer(part, reply_markup=admin_channel_keyboard())

# ==================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ü–†–û–ú–û–ö–û–î–ê–ú–ò ====================
@dp.message(F.text == "üé´ –ü—Ä–æ–º–æ–∫–æ–¥—ã")
async def admin_promo_menu(message: Message):
    if not await check_admin_permissions(message.from_user.id, "manage_promocodes"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await send_with_media(message.chat.id, "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–º–æ–∫–æ–¥–∞–º–∏:", media_key='admin_promo', reply_markup=admin_promo_keyboard())

@dp.message(F.text == "‚ûï –°–æ–∑–¥–∞—Ç—å –ø—Ä–æ–º–æ–∫–æ–¥")
async def create_promo_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_promocodes"):
        return
    await message.answer("–í–≤–µ–¥–∏ –∫–æ–¥ –ø—Ä–æ–º–æ–∫–æ–¥–∞ (–ª–∞—Ç–∏–Ω–∏—Ü–∞, —Ü–∏—Ñ—Ä—ã):", reply_markup=back_keyboard())
    await state.set_state(CreatePromocode.code)

@dp.message(CreatePromocode.code, F.text)
async def create_promo_code(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_promo_menu(message)
        return
    code = message.text.strip().upper()
    await state.update_data(code=code)
    await message.answer("–í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ (–±–∞–∫—Å–æ–≤ –∏–ª–∏ –±–∏—Ç–∫–æ–∏–Ω–æ–≤):")
    await state.set_state(CreatePromocode.reward)

@dp.message(CreatePromocode.reward, F.text)
async def create_promo_reward(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_promo_menu(message)
        return
    try:
        reward = float(message.text)
        if reward <= 0:
            raise ValueError
        reward = round(reward, 4) if reward < 1 else round(reward, 2)
        max_input = await get_setting_float("max_input_number")
        if reward > max_input:
            await message.answer(f"‚ùå –°—É–º–º–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è (–º–∞–∫—Å–∏–º—É–º {max_input:.4f}).")
            return
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω–æ–µ).")
        return
    await state.update_data(reward=reward)
    await message.answer("–í—ã–±–µ—Ä–∏ —Ç–∏–ø –Ω–∞–≥—Ä–∞–¥—ã:", reply_markup=promo_type_keyboard())
    await state.set_state(CreatePromocode.reward_type)

@dp.callback_query(CreatePromocode.reward_type, F.data.startswith("promo_type_"))
async def create_promo_reward_type(callback: CallbackQuery, state: FSMContext):
    reward_type = callback.data.split("_")[2]
    await state.update_data(reward_type=reward_type)
    await callback.message.edit_text("–í–≤–µ–¥–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ):")
    await state.set_state(CreatePromocode.max_uses)
    await callback.answer()

@dp.message(CreatePromocode.max_uses, F.text)
async def create_promo_max_uses(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_promo_menu(message)
        return
    try:
        max_uses = int(message.text)
        if max_uses <= 0:
            raise ValueError
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.")
        return
    data = await state.get_data()
    try:
        async with db_pool.acquire() as conn:
            await conn.execute(
                "INSERT INTO promocodes (code, reward, reward_type, max_uses, created_at, created_by) VALUES ($1, $2, $3, $4, $5, $6)",
                data['code'], data['reward'], data['reward_type'], max_uses, datetime.now().strftime("%Y-%m-%d %H:%M:%S"), message.from_user.id
            )
        await message.answer("‚úÖ –ü—Ä–æ–º–æ–∫–æ–¥ —Å–æ–∑–¥–∞–Ω!", reply_markup=admin_promo_keyboard())
    except asyncpg.UniqueViolationError:
        await message.answer("‚ùå –ü—Ä–æ–º–æ–∫–æ–¥ —Å —Ç–∞–∫–∏–º –∫–æ–¥–æ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.")
    except Exception as e:
        logging.error(f"Create promo error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")
    await state.clear()

# ----- –°–ø–∏—Å–æ–∫ –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤ (—Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–π –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π) -----
@dp.message(F.text == "üìã –°–ø–∏—Å–æ–∫ –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤")
async def list_promos(message: Message, page: int = 1):
    if not await check_admin_permissions(message.from_user.id, "manage_promocodes"):
        return
    
    offset = (page - 1) * ITEMS_PER_PAGE
    try:
        async with db_pool.acquire() as conn:
            total = await conn.fetchval("SELECT COUNT(*) FROM promocodes")
            rows = await conn.fetch(
                "SELECT code, reward, reward_type, max_uses, used_count FROM promocodes LIMIT $1 OFFSET $2",
                ITEMS_PER_PAGE, offset
            )
        if not rows:
            await message.answer("–ù–µ—Ç –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤.")
            return
        text = f"üé´ –ü—Ä–æ–º–æ–∫–æ–¥—ã (—Å—Ç—Ä–∞–Ω–∏—Ü–∞ {page}):\n"
        for row in rows:
            reward_type_str = "‚Çø" if row['reward_type'] == 'bitcoin' else "üí∞"
            reward_val = float(row['reward'])
            if row['reward_type'] == 'bitcoin':
                reward_str = f"{reward_val:.4f} BTC"
            else:
                reward_str = f"{reward_val:.2f} –±–∞–∫—Å–æ–≤"
            text += f"‚Ä¢ {row['code']}: {reward_type_str} {reward_str}, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ {row['used_count']}/{row['max_uses']}\n"
        kb = []
        nav_buttons = []
        if page > 1:
            nav_buttons.append(InlineKeyboardButton(text="‚¨ÖÔ∏è", callback_data=f"promos_page_{page-1}"))
        if offset + ITEMS_PER_PAGE < total:
            nav_buttons.append(InlineKeyboardButton(text="‚û°Ô∏è", callback_data=f"promos_page_{page+1}"))
        if nav_buttons:
            kb.append(nav_buttons)
        if kb:
            await message.answer(text, reply_markup=InlineKeyboardMarkup(inline_keyboard=kb))
        else:
            await message.answer(text, reply_markup=admin_promo_keyboard())
    except Exception as e:
        logging.error(f"List promos error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")

@dp.callback_query(F.data.startswith("promos_page_"))
async def promos_page_callback(callback: CallbackQuery):
    page = int(callback.data.split("_")[2])
    await list_promos(callback.message, page=page)
    await callback.answer()

# ==================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ß–ê–¢–ê–ú–ò ====================
@dp.message(F.text == "ü§ñ –ß–∞—Ç—ã")
async def admin_chats_menu(message: Message):
    if not await check_admin_permissions(message.from_user.id, "manage_chats"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await send_with_media(message.chat.id, "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —á–∞—Ç–∞–º–∏:", media_key='admin_chats', reply_markup=admin_chats_keyboard())

@dp.message(F.text == "üìã –°–ø–∏—Å–æ–∫ –∑–∞–ø—Ä–æ—Å–æ–≤ –Ω–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ")
async def list_pending_requests(message: Message):
    if not await check_admin_permissions(message.from_user.id, "manage_chats"):
        return
    requests = await get_pending_chat_requests()
    if not requests:
        await message.answer("–ù–µ—Ç –æ–∂–∏–¥–∞—é—â–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤.")
        return
    text = "üìã –û–∂–∏–¥–∞—é—â–∏–µ –∑–∞–ø—Ä–æ—Å—ã:\n\n"
    for req in requests:
        text += f"‚Ä¢ {req['title']} (ID: {req['chat_id']})\n  –ó–∞–ø—Ä–æ—Å–∏–ª: {req['requested_by']} ({req['request_date']})\n"
    parts = safe_split_text(text)
    for part in parts:
        await message.answer(part)

@dp.message(F.text == "‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å —á–∞—Ç")
async def confirm_chat_manual(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_chats"):
        return
    await message.answer("–í–≤–µ–¥–∏ ID —á–∞—Ç–∞, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—á–µ—à—å –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å:", reply_markup=back_keyboard())
    await state.set_state(ManageChats.chat_id)
    await state.update_data(action="confirm")

@dp.message(F.text == "‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å –∑–∞–ø—Ä–æ—Å")
async def reject_chat_manual(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_chats"):
        return
    await message.answer("–í–≤–µ–¥–∏ ID —á–∞—Ç–∞, –∑–∞–ø—Ä–æ—Å –∫–æ—Ç–æ—Ä–æ–≥–æ —Ö–æ—á–µ—à—å –æ—Ç–∫–ª–æ–Ω–∏—Ç—å:", reply_markup=back_keyboard())
    await state.set_state(ManageChats.chat_id)
    await state.update_data(action="reject")

@dp.message(F.text == "üóë –£–¥–∞–ª–∏—Ç—å —á–∞—Ç –∏–∑ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã—Ö")
async def remove_confirmed_chat_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_chats"):
        return
    await message.answer("–í–≤–µ–¥–∏ ID —á–∞—Ç–∞, –∫–æ—Ç–æ—Ä—ã–π –Ω—É–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å –∏–∑ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã—Ö:", reply_markup=back_keyboard())
    await state.set_state(ManageChats.chat_id)
    await state.update_data(action="remove")

@dp.message(ManageChats.chat_id, F.text)
async def process_chat_id(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_chats_menu(message)
        return
    try:
        chat_id = int(message.text)
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.")
        await state.clear()
        return
    data = await state.get_data()
    action = data.get('action')
    async with db_pool.acquire() as conn:
        if action == "confirm":
            request = await conn.fetchrow("SELECT * FROM chat_confirmation_requests WHERE chat_id=$1", chat_id)
            if request:
                await add_confirmed_chat(chat_id, request['title'], request['type'], message.from_user.id)
                await update_chat_request_status(chat_id, 'approved')
                await message.answer(f"‚úÖ –ß–∞—Ç {request['title']} –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω.")
                await safe_send_message(request['requested_by'], f"‚úÖ –í–∞—à —á–∞—Ç ¬´{request['title']}¬ª –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!")
            else:
                try:
                    chat = await bot.get_chat(chat_id)
                    await add_confirmed_chat(chat_id, chat.title, chat.type, message.from_user.id)
                    await message.answer(f"‚úÖ –ß–∞—Ç {chat.title} –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω.")
                except:
                    await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —á–∞—Ç–µ.")
        elif action == "reject":
            request = await conn.fetchrow("SELECT * FROM chat_confirmation_requests WHERE chat_id=$1", chat_id)
            if not request:
                await message.answer("‚ùå –ó–∞–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
                await state.clear()
                return
            await update_chat_request_status(chat_id, 'rejected')
            await message.answer(f"‚ùå –ó–∞–ø—Ä–æ—Å –¥–ª—è —á–∞—Ç–∞ {request['title']} –æ—Ç–∫–ª–æ–Ω—ë–Ω.")
            await safe_send_message(request['requested_by'], f"‚ùå –ó–∞–ø—Ä–æ—Å –Ω–∞ –∞–∫—Ç–∏–≤–∞—Ü–∏—é —á–∞—Ç–∞ ¬´{request['title']}¬ª –æ—Ç–∫–ª–æ–Ω—ë–Ω.")
        elif action == "remove":
            await remove_confirmed_chat(chat_id)
            await message.answer(f"‚úÖ –ß–∞—Ç {chat_id} —É–¥–∞–ª—ë–Ω –∏–∑ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã—Ö.")
    await state.clear()

@dp.message(F.text == "üìã –°–ø–∏—Å–æ–∫ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã—Ö —á–∞—Ç–æ–≤")
async def list_confirmed_chats(message: Message):
    if not await check_admin_permissions(message.from_user.id, "manage_chats"):
        return
    confirmed = await get_confirmed_chats(force_update=True)
    if not confirmed:
        await message.answer("–ù–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã—Ö —á–∞—Ç–æ–≤.")
        return
    text = "‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã–µ —á–∞—Ç—ã:\n\n"
    for chat_id, data in confirmed.items():
        text += f"‚Ä¢ {data['title']} (ID: {chat_id})\n  –ü–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω: {data.get('confirmed_date', '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')}\n"
    parts = safe_split_text(text)
    for part in parts:
        await message.answer(part)

# ==================== –ö–û–ù–ï–¶ –ß–ê–°–¢–ò 5.1 ====================
# ==================== –ß–ê–°–¢–¨ 5.2: –ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–ò–í–ù–ê–Ø –ü–ê–ù–ï–õ–¨ (–ü–†–û–î–û–õ–ñ–ï–ù–ò–ï) ====================
# - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–∏–∑–Ω–µ—Å–∞–º–∏
# - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–∏—Ä–∂–µ–π
# - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–µ–¥–∏–∞
# - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è–º–∏
# - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∞–º–∏
# - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º–∏
# - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
# - –†–∞—Å—Å—ã–ª–∫–∞
# - –ù–∞—Å—Ç—Ä–æ–π–∫–∏
# - –û—á–∏—Å—Ç–∫–∞
#
# –í—Å–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∞–≤, –ø–∞–≥–∏–Ω–∞—Ü–∏—è, —Ä–∞–±–æ—Ç–∞ —Å –¥–∞—Ç–∞–º–∏, –∏–º–ø–æ—Ä—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ ID/username –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã.

import asyncio
import io
import csv
import json
import logging
from datetime import datetime, timedelta

from aiogram import F, types
from aiogram.filters import Command, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery, Message, InlineKeyboardMarkup, InlineKeyboardButton, BufferedInputFile
from aiogram.exceptions import TelegramBadRequest, TelegramForbiddenError, TelegramRetryAfter, TelegramAPIError

# –í—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ —á–∞—Å—Ç–µ–π 1-4 –∏ 5.1 –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞—é—Ç—Å—è –¥–æ—Å—Ç—É–ø–Ω—ã–º–∏
# (bot, dp, db_pool, redis_client, –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã, —Å–æ—Å—Ç–æ—è–Ω–∏—è)

# ==================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ë–ò–ó–ù–ï–°–ê–ú–ò ====================
@dp.message(F.text == "üè™ –ë–∏–∑–Ω–µ—Å—ã")
async def admin_business_menu(message: Message):
    if not await check_admin_permissions(message.from_user.id, "manage_businesses"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await send_with_media(message.chat.id, "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–∏–∑–Ω–µ—Å–∞–º–∏:", media_key='admin_business', reply_markup=admin_business_keyboard())

@dp.message(F.text == "üìã –°–ø–∏—Å–æ–∫ –±–∏–∑–Ω–µ—Å–æ–≤")
async def admin_list_businesses(message: Message):
    if not await check_admin_permissions(message.from_user.id, "manage_businesses"):
        return
    types = await get_business_type_list(only_available=False)
    if not types:
        await message.answer("–ù–µ—Ç —Ç–∏–ø–æ–≤ –±–∏–∑–Ω–µ—Å–æ–≤.")
        return
    text = "üè™ –¢–∏–ø—ã –±–∏–∑–Ω–µ—Å–æ–≤:\n\n"
    for bt in types:
        available = "‚úÖ" if bt['available'] else "‚ùå"
        text += f"{available} ID {bt['id']}: {bt['emoji']} {bt['name']}\n"
        text += f"  –¶–µ–Ω–∞: {bt['base_price_btc']:.2f} BTC, –¥–æ—Ö–æ–¥ –≤ —á–∞—Å: {bt['base_income_per_hour']:.2f} $\n"
        text += f"  –û–ø–∏—Å–∞–Ω–∏–µ: {bt['description']}\n"
        text += f"  –ú–∞–∫—Å. —É—Ä–æ–≤–µ–Ω—å: {bt['max_level']}\n"
        text += f"  –°—Ä–æ–∫ –∂–∏–∑–Ω–∏: {bt['lifetime_hours']} —á\n"
        text += f"  –ö–∞—Ä—Ç–∏–Ω–∫–∞: {bt.get('image_key', '–Ω–µ—Ç')}\n\n"
    parts = safe_split_text(text)
    for part in parts:
        await message.answer(part, reply_markup=admin_business_keyboard())

@dp.message(F.text == "‚ûï –î–æ–±–∞–≤–∏—Ç—å –±–∏–∑–Ω–µ—Å")
async def add_business_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_businesses"):
        return
    await message.answer("–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –±–∏–∑–Ω–µ—Å–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, '–°—É–ø–µ—Ä–º–∞—Ä–∫–µ—Ç'):", reply_markup=back_keyboard())
    await state.set_state(AddBusiness.name)

@dp.message(AddBusiness.name, F.text)
async def add_business_name(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_business_menu(message)
        return
    await state.update_data(name=message.text)
    await message.answer("–í–≤–µ–¥–∏ —ç–º–æ–¥–∑–∏ –¥–ª—è –±–∏–∑–Ω–µ—Å–∞ (–æ–¥–∏–Ω —Å–∏–º–≤–æ–ª, –Ω–∞–ø—Ä–∏–º–µ—Ä, üè™):")
    await state.set_state(AddBusiness.emoji)

@dp.message(AddBusiness.emoji, F.text)
async def add_business_emoji(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_business_menu(message)
        return
    await state.update_data(emoji=message.text)
    await message.answer("–í–≤–µ–¥–∏ —Ü–µ–Ω—É –≤ BTC (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω—É—é, –Ω–∞–ø—Ä–∏–º–µ—Ä 1000.50):")
    await state.set_state(AddBusiness.price)

@dp.message(AddBusiness.price, F.text)
async def add_business_price(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_business_menu(message)
        return
    try:
        price = float(message.text)
        if price <= 0:
            raise ValueError
        price = round(price, 2)
        max_input = await get_setting_float("max_input_number")
        if price > max_input:
            await message.answer(f"‚ùå –¶–µ–Ω–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è (–º–∞–∫—Å–∏–º—É–º {max_input:.2f}).")
            return
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω–æ–µ).")
        return
    await state.update_data(price=price)
    await message.answer("–í–≤–µ–¥–∏ –±–∞–∑–æ–≤—ã–π –¥–æ—Ö–æ–¥ –≤ –±–∞–∫—Å–∞—Ö –≤ —á–∞—Å (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω–æ–µ, –Ω–∞–ø—Ä–∏–º–µ—Ä 1.5):")
    await state.set_state(AddBusiness.income)

@dp.message(AddBusiness.income, F.text)
async def add_business_income(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_business_menu(message)
        return
    try:
        income = float(message.text)
        if income <= 0:
            raise ValueError
        income = round(income, 2)
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω–æ–µ).")
        return
    await state.update_data(income=income)
    await message.answer("–í–≤–µ–¥–∏ –æ–ø–∏—Å–∞–Ω–∏–µ –±–∏–∑–Ω–µ—Å–∞:")
    await state.set_state(AddBusiness.description)

@dp.message(AddBusiness.description, F.text)
async def add_business_description(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_business_menu(message)
        return
    await state.update_data(description=message.text)
    await message.answer("–í–≤–µ–¥–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–∫–∞—á–∫–∏ (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ, –Ω–∞–ø—Ä–∏–º–µ—Ä 3):")
    await state.set_state(AddBusiness.max_level)

@dp.message(AddBusiness.max_level, F.text)
async def add_business_max_level(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_business_menu(message)
        return
    try:
        max_level = int(message.text)
        if max_level < 1:
            raise ValueError
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.")
        return
    await state.update_data(max_level=max_level)
    await message.answer("–í–≤–µ–¥–∏ —Å—Ä–æ–∫ –∂–∏–∑–Ω–∏ –±–∏–∑–Ω–µ—Å–∞ –≤ —á–∞—Å–∞—Ö (0 - –±–µ—Å—Å—Ä–æ—á–Ω–æ):")
    await state.set_state(AddBusiness.lifetime_hours)

@dp.message(AddBusiness.lifetime_hours, F.text)
async def add_business_lifetime(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_business_menu(message)
        return
    try:
        lt = int(message.text)
        if lt < 0:
            raise ValueError
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —Ü–µ–ª–æ–µ –Ω–µ–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.")
        return
    await state.update_data(lifetime_hours=lt)
    await message.answer("–í–≤–µ–¥–∏ –∫–ª—é—á –∫–∞—Ä—Ç–∏–Ω–∫–∏ –¥–ª—è –±–∏–∑–Ω–µ—Å–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 'business_kiosk'):")
    await state.set_state(AddBusiness.image_key)

@dp.message(AddBusiness.image_key, F.text)
async def add_business_image_key(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_business_menu(message)
        return
    image_key = message.text.strip()
    data = await state.get_data()
    try:
        async with db_pool.acquire() as conn:
            await conn.execute(
                "INSERT INTO business_types (name, emoji, base_price_btc, base_income_per_hour, description, max_level, image_key, available, lifetime_hours) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)",
                data['name'], data['emoji'], data['price'], data['income'], data['description'], data['max_level'], image_key, True, data['lifetime_hours']
            )
        await message.answer("‚úÖ –ë–∏–∑–Ω–µ—Å —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω!", reply_markup=admin_business_keyboard())
    except asyncpg.UniqueViolationError:
        await message.answer("‚ùå –ë–∏–∑–Ω–µ—Å —Å —Ç–∞–∫–∏–º –Ω–∞–∑–≤–∞–Ω–∏–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.")
    except Exception as e:
        logging.error(f"Add business error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –±–∏–∑–Ω–µ—Å–∞.")
    await state.clear()

@dp.message(F.text == "‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –±–∏–∑–Ω–µ—Å")
async def edit_business_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_businesses"):
        return
    await message.answer("–í–≤–µ–¥–∏ ID –±–∏–∑–Ω–µ—Å–∞ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:", reply_markup=back_keyboard())
    await state.set_state(EditBusiness.business_id)

@dp.message(EditBusiness.business_id, F.text)
async def edit_business_id(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_business_menu(message)
        return
    try:
        bid = int(message.text)
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.")
        await state.clear()
        return
    biz = await get_business_type(bid)
    if not biz:
        await message.answer("‚ùå –ë–∏–∑–Ω–µ—Å —Å —Ç–∞–∫–∏–º ID –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await state.clear()
        return
    await state.update_data(business_id=bid)
    await message.answer("–ß—Ç–æ —Ö–æ—á–µ—à—å –∏–∑–º–µ–Ω–∏—Ç—å? (name/emoji/price/income/description/max_level/available/image_key/lifetime_hours)")
    await state.set_state(EditBusiness.field)

@dp.message(EditBusiness.field, F.text)
async def edit_business_field(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_business_menu(message)
        return
    field = message.text.lower()
    allowed = ['name', 'emoji', 'price', 'income', 'description', 'max_level', 'available', 'image_key', 'lifetime_hours']
    if field not in allowed:
        await message.answer(f"‚ùå –ú–æ–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å —Ç–æ–ª—å–∫–æ: {', '.join(allowed)}")
        return
    await state.update_data(field=field)
    if field == 'available':
        await message.answer("–í–≤–µ–¥–∏ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ (True/False):")
    elif field == 'price':
        await message.answer("–í–≤–µ–¥–∏ –Ω–æ–≤—É—é —Ü–µ–Ω—É –≤ BTC (–¥—Ä–æ–±–Ω–æ–µ —á–∏—Å–ª–æ):")
    elif field == 'income':
        await message.answer("–í–≤–µ–¥–∏ –Ω–æ–≤—ã–π –±–∞–∑–æ–≤—ã–π –¥–æ—Ö–æ–¥ –≤ –±–∞–∫—Å–∞—Ö/—á–∞—Å (–¥—Ä–æ–±–Ω–æ–µ —á–∏—Å–ª–æ):")
    elif field == 'max_level':
        await message.answer("–í–≤–µ–¥–∏ –Ω–æ–≤—ã–π –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ):")
    elif field == 'lifetime_hours':
        await message.answer("–í–≤–µ–¥–∏ –Ω–æ–≤—ã–π —Å—Ä–æ–∫ –∂–∏–∑–Ω–∏ –≤ —á–∞—Å–∞—Ö (0 - –±–µ—Å—Å—Ä–æ—á–Ω–æ):")
    else:
        await message.answer(f"–í–≤–µ–¥–∏ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è {field}:")
    await state.set_state(EditBusiness.value)

@dp.message(EditBusiness.value, F.text)
async def edit_business_value(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_business_menu(message)
        return
    data = await state.get_data()
    bid = data['business_id']
    field = data['field']

    if field == 'available':
        val = message.text.lower() in ['true', '1', '–¥–∞', 'yes']
    elif field in ['price', 'income']:
        try:
            val = float(message.text)
            if val <= 0:
                raise ValueError
            val = round(val, 2)
            max_input = await get_setting_float("max_input_number")
            if val > max_input:
                await message.answer(f"‚ùå –°—É–º–º–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è (–º–∞–∫—Å–∏–º—É–º {max_input:.2f}).")
                return
        except:
            await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.")
            return
    elif field in ['max_level', 'lifetime_hours']:
        try:
            val = int(message.text)
            if val < 0:
                raise ValueError
        except:
            await message.answer("‚ùå –í–≤–µ–¥–∏ —Ü–µ–ª–æ–µ –Ω–µ–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.")
            return
    else:
        val = message.text

    try:
        async with db_pool.acquire() as conn:
            column_map = {
                'name': 'name',
                'emoji': 'emoji',
                'price': 'base_price_btc',
                'income': 'base_income_per_hour',
                'description': 'description',
                'max_level': 'max_level',
                'available': 'available',
                'image_key': 'image_key',
                'lifetime_hours': 'lifetime_hours'
            }
            db_column = column_map[field]
            await conn.execute(f"UPDATE business_types SET {db_column}=$1 WHERE id=$2", val, bid)
        await message.answer(f"‚úÖ –ü–æ–ª–µ {field} –æ–±–Ω–æ–≤–ª–µ–Ω–æ.", reply_markup=admin_business_keyboard())
    except Exception as e:
        logging.error(f"Edit business error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏.")
    await state.clear()

@dp.message(F.text == "üîÑ –ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å")
async def toggle_business_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_businesses"):
        return
    await message.answer("–í–≤–µ–¥–∏ ID –±–∏–∑–Ω–µ—Å–∞, –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –∫–æ—Ç–æ—Ä–æ–≥–æ –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å:", reply_markup=back_keyboard())
    await state.set_state(ToggleBusiness.business_id)

@dp.message(ToggleBusiness.business_id, F.text)
async def toggle_business_confirm(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_business_menu(message)
        return
    try:
        bid = int(message.text)
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.")
        await state.clear()
        return
    biz = await get_business_type(bid)
    if not biz:
        await message.answer("‚ùå –ë–∏–∑–Ω–µ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await state.clear()
        return
    current = biz['available']
    new_status = not current
    await state.update_data(business_id=bid, new_status=new_status)
    await message.answer(f"–¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å: {'‚úÖ –¥–æ—Å—Ç—É–ø–µ–Ω' if current else '‚ùå –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω'}. –ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –Ω–∞ {'‚ùå –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω' if current else '‚úÖ –¥–æ—Å—Ç—É–ø–µ–Ω'}? (–¥–∞/–Ω–µ—Ç)")
    await state.set_state(ToggleBusiness.confirm)

@dp.message(ToggleBusiness.confirm, F.text)
async def toggle_business_finish(message: Message, state: FSMContext):
    if message.text.lower() == '–Ω–µ—Ç' or message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_business_menu(message)
        return
    if message.text.lower() == '–¥–∞':
        data = await state.get_data()
        bid = data['business_id']
        new_status = data['new_status']
        try:
            async with db_pool.acquire() as conn:
                await conn.execute("UPDATE business_types SET available=$1 WHERE id=$2", new_status, bid)
            await message.answer(f"‚úÖ –î–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –±–∏–∑–Ω–µ—Å–∞ –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ {'‚úÖ –¥–æ—Å—Ç—É–ø–µ–Ω' if new_status else '‚ùå –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω'}.", reply_markup=admin_business_keyboard())
        except Exception as e:
            logging.error(f"Toggle business error: {e}")
            await message.answer("‚ùå –û—à–∏–±–∫–∞.")
        await state.clear()
    else:
        await message.answer("–í–≤–µ–¥–∏ '–¥–∞' –∏–ª–∏ '–Ω–µ—Ç'.")

# ==================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ë–ò–†–ñ–ï–ô ====================
@dp.message(F.text == "üíº –ë–∏—Ä–∂–∞")
async def admin_exchange_menu(message: Message):
    if not await check_admin_permissions(message.from_user.id, "manage_exchange"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await send_with_media(message.chat.id, "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–∏—Ç–∫–æ–∏–Ω-–±–∏—Ä–∂–µ–π:", media_key='admin_exchange', reply_markup=admin_exchange_keyboard())

@dp.message(F.text == "üìã –ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞—è–≤–∫–∏")
async def admin_list_orders(message: Message):
    if not await check_admin_permissions(message.from_user.id, "manage_exchange"):
        return
    orders = await get_active_orders()
    if not orders:
        await message.answer("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞—è–≤–æ–∫.")
        return
    text = "üìã –ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞—è–≤–∫–∏:\n\n"
    for o in orders:
        text += f"ID {o['id']}: {'üìà' if o['type']=='buy' else 'üìâ'} {o['amount']:.4f} BTC @ {o['price']} $ (–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {o['user_id']})\n"
    parts = safe_split_text(text)
    for part in parts:
        await message.answer(part, reply_markup=admin_exchange_keyboard())

@dp.message(F.text == "‚ùå –£–¥–∞–ª–∏—Ç—å –∑–∞—è–≤–∫—É (–ø–æ ID)")
async def admin_remove_order_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_exchange"):
        return
    await message.answer("–í–≤–µ–¥–∏ ID –∑–∞—è–≤–∫–∏ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=back_keyboard())
    await state.set_state(CancelBitcoinOrder.order_id)

@dp.message(CancelBitcoinOrder.order_id, F.text)
async def admin_remove_order_finish(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_exchange_menu(message)
        return
    try:
        order_id = int(message.text)
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.")
        await state.clear()
        return
    async with db_pool.acquire() as conn:
        async with conn.transaction():
            await conn.execute("SET LOCAL statement_timeout = '5s'")
            order = await conn.fetchrow("SELECT * FROM bitcoin_orders WHERE id=$1 AND status='active' FOR UPDATE", order_id)
            if not order:
                await message.answer("‚ùå –ó–∞—è–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —É–∂–µ –Ω–µ –∞–∫—Ç–∏–≤–Ω–∞.")
                await state.clear()
                return
            total_locked = float(order['total_locked'])
            if order['type'] == 'sell':
                await update_user_bitcoin(order['user_id'], total_locked, conn=conn)
            else:
                await update_user_balance(order['user_id'], total_locked, conn=conn, allow_negative=False)
            await conn.execute("UPDATE bitcoin_orders SET status='cancelled' WHERE id=$1", order_id)
    await message.answer(f"‚úÖ –ó–∞—è–≤–∫–∞ {order_id} –æ—Ç–º–µ–Ω–µ–Ω–∞, —Å—Ä–µ–¥—Å—Ç–≤–∞ –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é.")
    await state.clear()

@dp.message(F.text == "üìä –ò—Å—Ç–æ—Ä–∏—è —Å–¥–µ–ª–æ–∫")
async def admin_trade_history(message: Message):
    if not await check_admin_permissions(message.from_user.id, "manage_exchange"):
        return
    async with db_pool.acquire() as conn:
        rows = await conn.fetch("SELECT * FROM bitcoin_trades ORDER BY traded_at DESC LIMIT 50")
    if not rows:
        await message.answer("–ù–µ—Ç —Å–¥–µ–ª–æ–∫.")
        return
    text = "üìä –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–¥–µ–ª–∫–∏:\n\n"
    for r in rows:
        text += f"ID {r['id']}: {float(r['amount']):.4f} BTC @ {r['price']} $ (–ø–æ–∫—É–ø–∞—Ç–µ–ª—å {r['buyer_id']}, –ø—Ä–æ–¥–∞–≤–µ—Ü {r['seller_id']}) –≤ {r['traded_at'].strftime('%Y-%m-%d %H:%M')}\n"
    parts = safe_split_text(text)
    for part in parts:
        await message.answer(part, reply_markup=admin_exchange_keyboard())

# ==================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ú–ï–î–ò–ê ====================
@dp.message(F.text == "üñº –ú–µ–¥–∏–∞")
async def admin_media_menu(message: Message):
    if not await check_admin_permissions(message.from_user.id, "manage_media"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await send_with_media(message.chat.id, "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–µ–¥–∏–∞—Ñ–∞–π–ª–∞–º–∏:", media_key='admin_media', reply_markup=admin_media_keyboard())

@dp.message(F.text == "‚ûï –î–æ–±–∞–≤–∏—Ç—å –º–µ–¥–∏–∞")
async def add_media_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_media"):
        return
    await message.answer("–í–≤–µ–¥–∏ –∫–ª—é—á (–Ω–∞–ø—Ä–∏–º–µ—Ä, 'profile', 'casino', 'welcome', 'business_kiosk'):", reply_markup=back_keyboard())
    await state.set_state(AddMedia.key)

@dp.message(AddMedia.key, F.text)
async def add_media_key(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_media_menu(message)
        return
    key = message.text.strip()
    await state.update_data(key=key)
    await message.answer("–û—Ç–ø—Ä–∞–≤—å —Ñ–æ—Ç–æ (–∏–ª–∏ –¥–æ–∫—É–º–µ–Ω—Ç/–≤–∏–¥–µ–æ):")
    await state.set_state(AddMedia.file)

@dp.message(AddMedia.file, F.photo | F.document | F.video)
async def add_media_file(message: Message, state: FSMContext):
    if message.text and message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_media_menu(message)
        return
    file_id = None
    if message.photo:
        file_id = message.photo[-1].file_id
    elif message.document:
        file_id = message.document.file_id
    elif message.video:
        file_id = message.video.file_id
    else:
        await message.answer("‚ùå –û—Ç–ø—Ä–∞–≤—å —Ñ–æ—Ç–æ, –¥–æ–∫—É–º–µ–Ω—Ç –∏–ª–∏ –≤–∏–¥–µ–æ.")
        return
    data = await state.get_data()
    key = data['key']
    try:
        async with db_pool.acquire() as conn:
            await conn.execute(
                "INSERT INTO media (key, file_id, description) VALUES ($1, $2, $3) ON CONFLICT (key) DO UPDATE SET file_id=$2, description=$3",
                key, file_id, f"–ú–µ–¥–∏–∞ –¥–ª—è {key}"
            )
        if redis_client:
            await redis_set(f"media:{key}", file_id, 3600)
        await message.answer(f"‚úÖ –ú–µ–¥–∏–∞ —Å –∫–ª—é—á–æ–º '{key}' —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ.")
    except Exception as e:
        logging.error(f"Add media error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è.")
    await state.clear()
    await admin_media_menu(message)

@dp.message(F.text == "‚ûñ –£–¥–∞–ª–∏—Ç—å –º–µ–¥–∏–∞")
async def remove_media_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_media"):
        return
    await message.answer("–í–≤–µ–¥–∏ –∫–ª—é—á –º–µ–¥–∏–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=back_keyboard())
    await state.set_state(RemoveMedia.key)

@dp.message(RemoveMedia.key, F.text)
async def remove_media_finish(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_media_menu(message)
        return
    key = message.text.strip()
    try:
        async with db_pool.acquire() as conn:
            await conn.execute("DELETE FROM media WHERE key=$1", key)
        if redis_client:
            await redis_delete(f"media:{key}")
        await message.answer(f"‚úÖ –ú–µ–¥–∏–∞ —Å –∫–ª—é—á–æ–º '{key}' —É–¥–∞–ª–µ–Ω–æ, –µ—Å–ª–∏ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–ª–æ.")
    except Exception as e:
        logging.error(f"Remove media error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")
    await state.clear()

@dp.message(F.text == "üìã –°–ø–∏—Å–æ–∫ –º–µ–¥–∏–∞")
async def list_media(message: Message):
    if not await check_admin_permissions(message.from_user.id, "manage_media"):
        return
    async with db_pool.acquire() as conn:
        rows = await conn.fetch("SELECT key, description FROM media ORDER BY key")
    if not rows:
        await message.answer("–ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö –º–µ–¥–∏–∞.")
        return
    text = "üñº –°–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ –º–µ–¥–∏–∞:\n\n"
    for row in rows:
        text += f"‚Ä¢ {row['key']}: {row['description']}\n"
    parts = safe_split_text(text)
    for part in parts:
        await message.answer(part, reply_markup=admin_media_keyboard())

# ==================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ó–ê–î–ê–ù–ò–Ø–ú–ò ====================
@dp.message(F.text == "üìã –ó–∞–¥–∞–Ω–∏—è")
async def admin_tasks_menu(message: Message):
    if not await check_admin_permissions(message.from_user.id, "manage_users"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await send_with_media(message.chat.id, "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è–º–∏:", media_key='admin_tasks', reply_markup=admin_tasks_keyboard())

@dp.message(F.text == "‚ûï –°–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞–Ω–∏–µ")
async def create_task_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_users"):
        return
    await message.answer("–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è:", reply_markup=back_keyboard())
    await state.set_state(CreateTask.name)

@dp.message(CreateTask.name, F.text)
async def create_task_name(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_tasks_menu(message)
        return
    await state.update_data(name=message.text)
    await message.answer("–í–≤–µ–¥–∏ –æ–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è:")
    await state.set_state(CreateTask.description)

@dp.message(CreateTask.description, F.text)
async def create_task_description(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_tasks_menu(message)
        return
    await state.update_data(description=message.text)
    await message.answer("–í–≤–µ–¥–∏ —Ç–∏–ø –∑–∞–¥–∞–Ω–∏—è (subscribe):")
    await state.set_state(CreateTask.task_type)

@dp.message(CreateTask.task_type, F.text)
async def create_task_type(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_tasks_menu(message)
        return
    task_type = message.text.lower()
    if task_type not in ['subscribe']:
        await message.answer("‚ùå –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ —Ç–∏–ø 'subscribe'.")
        return
    await state.update_data(task_type=task_type)
    await message.answer("–í–≤–µ–¥–∏ ID –∫–∞–Ω–∞–ª–∞ –∏–ª–∏ @username –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏:")
    await state.set_state(CreateTask.target_id)

@dp.message(CreateTask.target_id, F.text)
async def create_task_target(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_tasks_menu(message)
        return
    target_id = message.text.strip()
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –±–æ—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º –∫–∞–Ω–∞–ª–∞
    try:
        bot_user = await bot.me()
        chat_member = await bot.get_chat_member(target_id, bot_user.id)
        if chat_member.status not in ['administrator', 'creator']:
            await message.answer("‚ùå –ë–æ—Ç –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º —ç—Ç–æ–≥–æ –∫–∞–Ω–∞–ª–∞. –î–æ–±–∞–≤—å—Ç–µ –±–æ—Ç–∞ –≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ.")
            return
    except Exception as e:
        await message.answer(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–∞–Ω–∞–ª: {e}. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ ID –∫–∞–Ω–∞–ª–∞ –≤–µ—Ä–Ω—ã–π –∏ –±–æ—Ç –¥–æ–±–∞–≤–ª–µ–Ω.")
        return
    await state.update_data(target_id=target_id)
    await message.answer("–í–≤–µ–¥–∏ –Ω–∞–≥—Ä–∞–¥—É –≤ –±–∞–∫—Å–∞—Ö (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω–æ–µ):")
    await state.set_state(CreateTask.reward_coins)

@dp.message(CreateTask.reward_coins, F.text)
async def create_task_reward_coins(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_tasks_menu(message)
        return
    try:
        coins = float(message.text)
        if coins < 0:
            raise ValueError
        coins = round(coins, 2)
        max_input = await get_setting_float("max_input_number")
        if coins > max_input:
            await message.answer(f"‚ùå –ù–∞–≥—Ä–∞–¥–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è (–º–∞–∫—Å–∏–º—É–º {max_input:.2f}).")
            return
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –Ω–µ–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.")
        return
    await state.update_data(reward_coins=coins)
    await message.answer("–í–≤–µ–¥–∏ –Ω–∞–≥—Ä–∞–¥—É –≤ —Ä–µ–ø—É—Ç–∞—Ü–∏–∏ (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ):")
    await state.set_state(CreateTask.reward_reputation)

@dp.message(CreateTask.reward_reputation, F.text)
async def create_task_reward_rep(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_tasks_menu(message)
        return
    try:
        rep = int(message.text)
        if rep < 0:
            raise ValueError
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —Ü–µ–ª–æ–µ –Ω–µ–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.")
        return
    await state.update_data(reward_reputation=rep)
    await message.answer("–í–≤–µ–¥–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–π (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ, 0 - –±–µ–∑ –ª–∏–º–∏—Ç–∞):")
    await state.set_state(CreateTask.max_completions)

@dp.message(CreateTask.max_completions, F.text)
async def create_task_max_completions(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_tasks_menu(message)
        return
    try:
        max_comp = int(message.text)
        if max_comp < 0:
            raise ValueError
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —Ü–µ–ª–æ–µ –Ω–µ–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.")
        return
    await state.update_data(max_completions=max_comp)
    await message.answer("–í–≤–µ–¥–∏ —Å—Å—ã–ª–∫—É –¥–ª—è –∫–Ω–æ–ø–∫–∏ –ø–µ—Ä–µ—Ö–æ–¥–∞ –≤ –∫–∞–Ω–∞–ª (–∏–ª–∏ '–Ω–µ—Ç'):")
    await state.set_state(CreateTask.button_link)

@dp.message(CreateTask.button_link, F.text)
async def create_task_button_link(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_tasks_menu(message)
        return
    button_link = None if message.text.lower() == '–Ω–µ—Ç' else message.text.strip()
    await state.update_data(button_link=button_link)
    await message.answer("–û—Ç–ø—Ä–∞–≤—å –º–µ–¥–∏–∞ –¥–ª—è –∑–∞–¥–∞–Ω–∏—è (–∏–ª–∏ '–Ω–µ—Ç'):")
    await state.set_state(CreateTask.media)

@dp.message(CreateTask.media, F.photo | F.text)
async def create_task_media(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_tasks_menu(message)
        return
    media_file_id = None
    media_type = None
    if message.photo:
        media_file_id = message.photo[-1].file_id
        media_type = 'photo'
    elif message.text and message.text.lower() == '–Ω–µ—Ç':
        pass
    else:
        await message.answer("–û—Ç–ø—Ä–∞–≤—å —Ñ–æ—Ç–æ –∏–ª–∏ '–Ω–µ—Ç'.")
        return
    data = await state.get_data()
    try:
        async with db_pool.acquire() as conn:
            task_id = await conn.fetchval(
                """INSERT INTO tasks 
                   (name, description, task_type, target_id, reward_coins, reward_reputation, 
                    max_completions, media_file_id, media_type, button_link, created_by, created_at, active)
                   VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
                   RETURNING id""",
                data['name'], data['description'], data['task_type'], data['target_id'],
                data['reward_coins'], data['reward_reputation'], data['max_completions'],
                media_file_id, media_type, data['button_link'], message.from_user.id,
                datetime.now().strftime("%Y-%m-%d %H:%M:%S"), True
            )
        await message.answer(f"‚úÖ –ó–∞–¥–∞–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–æ! ID: {task_id}", reply_markup=admin_tasks_keyboard())
    except Exception as e:
        logging.error(f"Create task error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–¥–∞–Ω–∏—è.")
    await state.clear()

# ----- –°–ø–∏—Å–æ–∫ –∑–∞–¥–∞–Ω–∏–π (—Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–π –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π) -----
@dp.message(F.text == "üìã –°–ø–∏—Å–æ–∫ –∑–∞–¥–∞–Ω–∏–π")
async def list_tasks(message: Message, page: int = 1):
    if not await check_admin_permissions(message.from_user.id, "manage_users"):
        return
    
    offset = (page - 1) * ITEMS_PER_PAGE
    try:
        async with db_pool.acquire() as conn:
            total = await conn.fetchval("SELECT COUNT(*) FROM tasks WHERE active=TRUE")
            rows = await conn.fetch(
                "SELECT id, name, description, reward_coins, reward_reputation, max_completions, completed_count, task_type FROM tasks WHERE active=TRUE ORDER BY id LIMIT $1 OFFSET $2",
                ITEMS_PER_PAGE, offset
            )
        if not rows:
            await message.answer("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞–Ω–∏–π.")
            return
        text = f"üìã –ó–∞–¥–∞–Ω–∏—è (—Å—Ç—Ä–∞–Ω–∏—Ü–∞ {page}):\n\n"
        for row in rows:
            text += f"ID {row['id']}: {row['name']}\n"
            text += f"  {row['description']}\n"
            text += f"  –¢–∏–ø: {row['task_type']}\n"
            text += f"  –ù–∞–≥—Ä–∞–¥–∞: {float(row['reward_coins']):.2f} –±–∞–∫—Å–æ–≤, {row['reward_reputation']} —Ä–µ–ø—É—Ç–∞—Ü–∏–∏\n"
            text += f"  –í—ã–ø–æ–ª–Ω–µ–Ω–æ: {row['completed_count']}/{row['max_completions'] if row['max_completions']>0 else '‚àû'}\n\n"
        kb = []
        nav_buttons = []
        if page > 1:
            nav_buttons.append(InlineKeyboardButton(text="‚¨ÖÔ∏è", callback_data=f"tasks_page_{page-1}"))
        if offset + ITEMS_PER_PAGE < total:
            nav_buttons.append(InlineKeyboardButton(text="‚û°Ô∏è", callback_data=f"tasks_page_{page+1}"))
        if nav_buttons:
            kb.append(nav_buttons)
        for row in rows:
            kb.append([InlineKeyboardButton(text=f"‚ùå –£–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞–Ω–∏–µ {row['id']}", callback_data=f"delete_task_{row['id']}")])
        if kb:
            await message.answer(text, reply_markup=InlineKeyboardMarkup(inline_keyboard=kb))
        else:
            await message.answer(text)
    except Exception as e:
        logging.error(f"List tasks error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞.")

@dp.callback_query(F.data.startswith("delete_task_"))
async def delete_task_callback(callback: CallbackQuery):
    if not await check_admin_permissions(callback.from_user.id, "manage_users"):
        await callback.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    task_id = int(callback.data.split("_")[2])
    try:
        async with db_pool.acquire() as conn:
            await conn.execute("DELETE FROM tasks WHERE id=$1", task_id)
            await conn.execute("DELETE FROM user_tasks WHERE task_id=$1", task_id)
        await callback.answer("‚úÖ –ó–∞–¥–∞–Ω–∏–µ —É–¥–∞–ª–µ–Ω–æ.", show_alert=True)
        await list_tasks(callback.message)
    except Exception as e:
        logging.error(f"Delete task error: {e}")
        await callback.answer("‚ùå –û—à–∏–±–∫–∞.", show_alert=True)

@dp.callback_query(F.data.startswith("tasks_page_"))
async def tasks_page_callback(callback: CallbackQuery):
    page = int(callback.data.split("_")[2])
    await list_tasks(callback.message, page=page)
    await callback.answer()

# ==================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –†–û–ó–´–ì–†–´–®–ê–ú–ò (–ê–î–ú–ò–ù–ö–ê) ====================
@dp.message(F.text == "üéÅ –†–æ–∑—ã–≥—Ä—ã—à–∏")
async def admin_giveaway_menu(message: Message):
    if not await check_admin_permissions(message.from_user.id, "manage_giveaways"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await send_with_media(message.chat.id, "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∞–º–∏:", media_key='admin_giveaway', reply_markup=admin_giveaway_keyboard())

@dp.message(F.text == "‚ûï –°–æ–∑–¥–∞—Ç—å —Ä–æ–∑—ã–≥—Ä—ã—à")
async def create_giveaway_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_giveaways"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await message.answer("–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–∏–∑–∞:", reply_markup=back_keyboard())
    await state.set_state(CreateGiveaway.prize)

@dp.message(CreateGiveaway.prize, F.text)
async def create_giveaway_prize(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_giveaway_menu(message)
        return
    await state.update_data(prize=message.text)
    await message.answer("–í–≤–µ–¥–∏ –æ–ø–∏—Å–∞–Ω–∏–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∞:")
    await state.set_state(CreateGiveaway.description)

@dp.message(CreateGiveaway.description, F.text)
async def create_giveaway_description(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_giveaway_menu(message)
        return
    await state.update_data(description=message.text)
    await message.answer("–í—ã–±–µ—Ä–∏ —É—Å–ª–æ–≤–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è:", reply_markup=giveaway_condition_keyboard())
    await state.set_state(CreateGiveaway.condition_type)

@dp.callback_query(CreateGiveaway.condition_type, F.data.startswith("giveaway_cond_"))
async def create_giveaway_condition(callback: CallbackQuery, state: FSMContext):
    cond_type = callback.data.split("_")[2]  # time –∏–ª–∏ participants
    await state.update_data(condition_type=cond_type)
    if cond_type == 'time':
        await callback.message.edit_text("–í–≤–µ–¥–∏ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú (–Ω–∞–ø—Ä–∏–º–µ—Ä, 25.12.2025 18:00):")
        await state.set_state(CreateGiveaway.end_date)
    else:
        await callback.message.edit_text("–í–≤–µ–¥–∏ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ):")
        await state.set_state(CreateGiveaway.min_participants)
    await callback.answer()

@dp.message(CreateGiveaway.min_participants, F.text)
async def create_giveaway_min_participants(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_giveaway_menu(message)
        return
    try:
        min_part = int(message.text)
        if min_part <= 0:
            raise ValueError
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.")
        return
    await state.update_data(min_participants=min_part)
    await message.answer("–í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 1):")
    await state.set_state(CreateGiveaway.winners_count)

@dp.message(CreateGiveaway.end_date, F.text)
async def create_giveaway_end_date(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_giveaway_menu(message)
        return
    try:
        end_date = datetime.strptime(message.text, "%d.%m.%Y %H:%M")
    except:
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π –î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú")
        return
    await state.update_data(end_date=end_date)
    await message.answer("–í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 1):")
    await state.set_state(CreateGiveaway.winners_count)

@dp.message(CreateGiveaway.winners_count, F.text)
async def create_giveaway_winners_count(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_giveaway_menu(message)
        return
    try:
        wc = int(message.text)
        if wc <= 0:
            raise ValueError
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.")
        return
    await state.update_data(winners_count=wc)
    await message.answer("–û—Ç–ø—Ä–∞–≤—å –º–µ–¥–∏–∞ –¥–ª—è —Ä–æ–∑—ã–≥—Ä—ã—à–∞ (–∏–ª–∏ '–Ω–µ—Ç'):")
    await state.set_state(CreateGiveaway.media)

@dp.message(CreateGiveaway.media, F.photo | F.text)
async def create_giveaway_media(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_giveaway_menu(message)
        return
    media_file_id = None
    media_type = None
    if message.photo:
        media_file_id = message.photo[-1].file_id
        media_type = 'photo'
    elif message.text and message.text.lower() == '–Ω–µ—Ç':
        pass
    else:
        await message.answer("–û—Ç–ø—Ä–∞–≤—å —Ñ–æ—Ç–æ –∏–ª–∏ '–Ω–µ—Ç'.")
        return
    data = await state.get_data()
    try:
        async with db_pool.acquire() as conn:
            if data['condition_type'] == 'time':
                end_date = data['end_date']
                min_participants = 0
            else:
                end_date = None
                min_participants = data['min_participants']
            await conn.execute(
                """INSERT INTO giveaways 
                   (prize, description, end_date, media_file_id, media_type, status, winners_count, min_participants, condition_type)
                   VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)""",
                data['prize'], data['description'], end_date, media_file_id, media_type, 'active',
                data.get('winners_count', 1), min_participants, data['condition_type']
            )
        await message.answer("‚úÖ –†–æ–∑—ã–≥—Ä—ã—à —Å–æ–∑–¥–∞–Ω!", reply_markup=admin_giveaway_keyboard())
    except Exception as e:
        logging.error(f"Create giveaway error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Ä–æ–∑—ã–≥—Ä—ã—à–∞.")
    await state.clear()

# ----- –ê–∫—Ç–∏–≤–Ω—ã–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∏ (–∞–¥–º–∏–Ω) —Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–π –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π -----
@dp.message(F.text == "üìã –ê–∫—Ç–∏–≤–Ω—ã–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∏ (–∞–¥–º–∏–Ω)")
async def admin_active_giveaways(message: Message, page: int = 1):
    if not await check_admin_permissions(message.from_user.id, "manage_giveaways"):
        return
    
    offset = (page - 1) * ITEMS_PER_PAGE
    async with db_pool.acquire() as conn:
        total = await conn.fetchval("SELECT COUNT(*) FROM giveaways WHERE status='active'")
        rows = await conn.fetch(
            "SELECT id, prize, description, end_date, media_file_id, media_type, min_participants, condition_type FROM giveaways WHERE status='active' ORDER BY end_date LIMIT $1 OFFSET $2",
            ITEMS_PER_PAGE, offset
        )
    if not rows:
        await message.answer("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π.")
        return
    text = f"üìã –ê–∫—Ç–∏–≤–Ω—ã–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∏ (—Å—Ç—Ä–∞–Ω–∏—Ü–∞ {page}):\n\n"
    kb = []
    for row in rows:
        end_str = row['end_date'].strftime("%Y-%m-%d %H:%M") if row['end_date'] else "–Ω–µ —É–∫–∞–∑–∞–Ω–æ"
        cond = f"‚è∞ {end_str}" if row['condition_type']=='time' else f"üë• {row['min_participants']} —É—á."
        text += f"#{row['id']} - {row['prize']} ({cond})\n"
        kb.append([InlineKeyboardButton(text=f"–ó–∞–≤–µ—Ä—à–∏—Ç—å #{row['id']}", callback_data=f"admin_end_giveaway_{row['id']}")])
        kb.append([InlineKeyboardButton(text=f"–£–¥–∞–ª–∏—Ç—å #{row['id']}", callback_data=f"admin_delete_giveaway_{row['id']}")])
        kb.append([InlineKeyboardButton(text=f"–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å #{row['id']}", callback_data=f"edit_giveaway_{row['id']}")])
    total_pages = (total + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE
    nav = []
    if page > 1:
        nav.append(InlineKeyboardButton("‚¨ÖÔ∏è", callback_data=f"admin_gw_page_{page-1}"))
    if page < total_pages:
        nav.append(InlineKeyboardButton("‚û°Ô∏è", callback_data=f"admin_gw_page_{page+1}"))
    if nav:
        kb.append(nav)
    await message.answer(text, reply_markup=InlineKeyboardMarkup(inline_keyboard=kb))

@dp.callback_query(F.data.startswith("admin_gw_page_"))
async def admin_gw_page_callback(callback: CallbackQuery):
    page = int(callback.data.split("_")[3])
    await admin_active_giveaways(callback.message, page=page)
    await callback.answer()

@dp.callback_query(F.data.startswith("admin_end_giveaway_"))
async def admin_end_giveaway(callback: CallbackQuery):
    if not await check_admin_permissions(callback.from_user.id, "manage_giveaways"):
        await callback.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    gw_id = int(callback.data.split("_")[3])
    async with db_pool.acquire() as conn:
        giveaway = await conn.fetchrow("SELECT * FROM giveaways WHERE id=$1 AND status='active'", gw_id)
        if not giveaway:
            await callback.answer("‚ùå –†–æ–∑—ã–≥—Ä—ã—à –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ —É–∂–µ –∑–∞–≤–µ—Ä—à—ë–Ω.", show_alert=True)
            return
        participants = await conn.fetch("SELECT user_id FROM participants WHERE giveaway_id=$1", gw_id)
        if not participants:
            await callback.answer("‚ùå –ù–µ—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.", show_alert=True)
            return
        winners_count = giveaway['winners_count']
        winners = random.sample([p['user_id'] for p in participants], min(winners_count, len(participants)))
        winners_list = json.dumps(winners)
        await conn.execute(
            "UPDATE giveaways SET status='completed', winners_list=$1 WHERE id=$2",
            winners_list, gw_id
        )
        for uid in [p['user_id'] for p in participants]:
            if uid in winners:
                await safe_send_message(uid, f"üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ –≤ —Ä–æ–∑—ã–≥—Ä—ã—à–µ #{gw_id}! –ü—Ä–∏–∑: {giveaway['prize']}")
            else:
                await safe_send_message(uid, f"üò¢ –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤—ã –Ω–µ –≤—ã–∏–≥—Ä–∞–ª–∏ –≤ —Ä–æ–∑—ã–≥—Ä—ã—à–µ #{gw_id}.")
    await callback.answer("‚úÖ –†–æ–∑—ã–≥—Ä—ã—à –∑–∞–≤–µ—Ä—à—ë–Ω, –ø–æ–±–µ–¥–∏—Ç–µ–ª–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω—ã.")
    await admin_active_giveaways(callback.message)

@dp.callback_query(F.data.startswith("admin_delete_giveaway_"))
async def admin_delete_giveaway(callback: CallbackQuery):
    if not await check_admin_permissions(callback.from_user.id, "manage_giveaways"):
        await callback.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    gw_id = int(callback.data.split("_")[3])
    async with db_pool.acquire() as conn:
        await conn.execute("DELETE FROM participants WHERE giveaway_id=$1", gw_id)
        await conn.execute("DELETE FROM giveaways WHERE id=$1", gw_id)
    await callback.answer("‚úÖ –†–æ–∑—ã–≥—Ä—ã—à —É–¥–∞–ª—ë–Ω.")
    await admin_active_giveaways(callback.message)

# ----- –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π -----
@dp.callback_query(F.data.startswith("edit_giveaway_"))
async def edit_giveaway_start(callback: CallbackQuery, state: FSMContext):
    if not await check_admin_permissions(callback.from_user.id, "manage_giveaways"):
        await callback.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    gw_id = int(callback.data.split("_")[2])
    await state.update_data(giveaway_id=gw_id)
    await callback.message.answer(
        "–ß—Ç–æ –∏–∑–º–µ–Ω–∏—Ç—å?\n1 - –ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–∏–∑–∞\n2 - –û–ø–∏—Å–∞–Ω–∏–µ\n3 - –î–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è (–¥–ª—è time)\n4 - –ú–∏–Ω. —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ (–¥–ª—è participants)\n5 - –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π\n6 - –ú–µ–¥–∏–∞\n–í–≤–µ–¥–∏ –Ω–æ–º–µ—Ä:",
        reply_markup=back_keyboard()
    )
    await state.set_state(EditGiveaway.field)

@dp.message(EditGiveaway.field, F.text)
async def edit_giveaway_field(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_active_giveaways(message)
        return
    option = message.text.strip()
    data = await state.get_data()
    gw_id = data['giveaway_id']
    if option == '1':
        await message.answer("–í–≤–µ–¥–∏ –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–∏–∑–∞:")
        await state.set_state(EditGiveaway.prize)
    elif option == '2':
        await message.answer("–í–≤–µ–¥–∏ –Ω–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ:")
        await state.set_state(EditGiveaway.description)
    elif option == '3':
        await message.answer("–í–≤–µ–¥–∏ –Ω–æ–≤—É—é –¥–∞—Ç—É –æ–∫–æ–Ω—á–∞–Ω–∏—è (–î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú):")
        await state.set_state(EditGiveaway.end_date)
    elif option == '4':
        await message.answer("–í–≤–µ–¥–∏ –Ω–æ–≤–æ–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤:")
        await state.set_state(EditGiveaway.min_participants)
    elif option == '5':
        await message.answer("–í–≤–µ–¥–∏ –Ω–æ–≤–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π:")
        await state.set_state(EditGiveaway.winners_count)
    elif option == '6':
        await message.answer("–û—Ç–ø—Ä–∞–≤—å –Ω–æ–≤–æ–µ –º–µ–¥–∏–∞ (—Ñ–æ—Ç–æ) –∏–ª–∏ '–Ω–µ—Ç':")
        await state.set_state(EditGiveaway.media)
    else:
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä.")
        await state.clear()
        await admin_active_giveaways(message)

@dp.message(EditGiveaway.prize, F.text)
async def edit_giveaway_prize(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_active_giveaways(message)
        return
    data = await state.get_data()
    gw_id = data['giveaway_id']
    async with db_pool.acquire() as conn:
        await conn.execute("UPDATE giveaways SET prize=$1 WHERE id=$2", message.text, gw_id)
    await message.answer("‚úÖ –ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–∏–∑–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–æ.")
    await state.clear()
    await admin_active_giveaways(message)

@dp.message(EditGiveaway.description, F.text)
async def edit_giveaway_description(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_active_giveaways(message)
        return
    data = await state.get_data()
    gw_id = data['giveaway_id']
    async with db_pool.acquire() as conn:
        await conn.execute("UPDATE giveaways SET description=$1 WHERE id=$2", message.text, gw_id)
    await message.answer("‚úÖ –û–ø–∏—Å–∞–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ.")
    await state.clear()
    await admin_active_giveaways(message)

@dp.message(EditGiveaway.end_date, F.text)
async def edit_giveaway_end_date(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_active_giveaways(message)
        return
    try:
        end_date = datetime.strptime(message.text, "%d.%m.%Y %H:%M")
    except:
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π –î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú")
        return
    data = await state.get_data()
    gw_id = data['giveaway_id']
    async with db_pool.acquire() as conn:
        await conn.execute("UPDATE giveaways SET end_date=$1 WHERE id=$2", end_date, gw_id)
    await message.answer("‚úÖ –î–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∞.")
    await state.clear()
    await admin_active_giveaways(message)

@dp.message(EditGiveaway.min_participants, F.text)
async def edit_giveaway_min_participants(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_active_giveaways(message)
        return
    try:
        min_part = int(message.text)
        if min_part <= 0:
            raise ValueError
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.")
        return
    data = await state.get_data()
    gw_id = data['giveaway_id']
    async with db_pool.acquire() as conn:
        await conn.execute("UPDATE giveaways SET min_participants=$1 WHERE id=$2", min_part, gw_id)
    await message.answer("‚úÖ –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –æ–±–Ω–æ–≤–ª–µ–Ω–æ.")
    await state.clear()
    await admin_active_giveaways(message)

@dp.message(EditGiveaway.winners_count, F.text)
async def edit_giveaway_winners_count(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_active_giveaways(message)
        return
    try:
        wc = int(message.text)
        if wc <= 0:
            raise ValueError
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.")
        return
    data = await state.get_data()
    gw_id = data['giveaway_id']
    async with db_pool.acquire() as conn:
        await conn.execute("UPDATE giveaways SET winners_count=$1 WHERE id=$2", wc, gw_id)
    await message.answer("‚úÖ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π –æ–±–Ω–æ–≤–ª–µ–Ω–æ.")
    await state.clear()
    await admin_active_giveaways(message)

@dp.message(EditGiveaway.media, F.photo | F.text)
async def edit_giveaway_media(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_active_giveaways(message)
        return
    media_file_id = None
    media_type = None
    if message.photo:
        media_file_id = message.photo[-1].file_id
        media_type = 'photo'
    elif message.text and message.text.lower() == '–Ω–µ—Ç':
        pass
    else:
        await message.answer("–û—Ç–ø—Ä–∞–≤—å —Ñ–æ—Ç–æ –∏–ª–∏ '–Ω–µ—Ç'.")
        return
    data = await state.get_data()
    gw_id = data['giveaway_id']
    async with db_pool.acquire() as conn:
        await conn.execute("UPDATE giveaways SET media_file_id=$1, media_type=$2 WHERE id=$3", media_file_id, media_type, gw_id)
    await message.answer("‚úÖ –ú–µ–¥–∏–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–æ.")
    await state.clear()
    await admin_active_giveaways(message)

@dp.message(F.text == "‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å —Ä–æ–∑—ã–≥—Ä—ã—à")
async def complete_giveaway_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_giveaways"):
        return
    await message.answer("–í–≤–µ–¥–∏ ID —Ä–æ–∑—ã–≥—Ä—ã—à–∞ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è:", reply_markup=back_keyboard())
    await state.set_state(CompleteGiveaway.giveaway_id)

@dp.message(CompleteGiveaway.giveaway_id, F.text)
async def complete_giveaway_id(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_giveaway_menu(message)
        return
    try:
        gw_id = int(message.text)
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.")
        return
    await state.update_data(giveaway_id=gw_id)
    await message.answer("–í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 1):")
    await state.set_state(CompleteGiveaway.winners_count)

@dp.message(CompleteGiveaway.winners_count, F.text)
async def complete_giveaway_winners(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_giveaway_menu(message)
        return
    try:
        wc = int(message.text)
        if wc <= 0:
            raise ValueError
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.")
        return
    data = await state.get_data()
    gw_id = data['giveaway_id']
    async with db_pool.acquire() as conn:
        giveaway = await conn.fetchrow("SELECT * FROM giveaways WHERE id=$1 AND status='active'", gw_id)
        if not giveaway:
            await message.answer("‚ùå –†–æ–∑—ã–≥—Ä—ã—à –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ —É–∂–µ –∑–∞–≤–µ—Ä—à—ë–Ω.")
            await state.clear()
            return
        participants = await conn.fetch("SELECT user_id FROM participants WHERE giveaway_id=$1", gw_id)
        if not participants:
            await message.answer("‚ùå –ù–µ—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.")
            await state.clear()
            return
        winners = random.sample([p['user_id'] for p in participants], min(wc, len(participants)))
        winners_list = json.dumps(winners)
        await conn.execute(
            "UPDATE giveaways SET status='completed', winners_list=$1 WHERE id=$2",
            winners_list, gw_id
        )
        for uid in [p['user_id'] for p in participants]:
            if uid in winners:
                await safe_send_message(uid, f"üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ –≤ —Ä–æ–∑—ã–≥—Ä—ã—à–µ #{gw_id}! –ü—Ä–∏–∑: {giveaway['prize']}")
            else:
                await safe_send_message(uid, f"üò¢ –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤—ã –Ω–µ –≤—ã–∏–≥—Ä–∞–ª–∏ –≤ —Ä–æ–∑—ã–≥—Ä—ã—à–µ #{gw_id}.")
    await message.answer("‚úÖ –†–æ–∑—ã–≥—Ä—ã—à –∑–∞–≤–µ—Ä—à—ë–Ω.")
    await state.clear()

# ==================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–û–†–ê–ú–ò ====================
@dp.message(F.text == "üëë –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã")
async def admin_admins_menu(message: Message):
    if not await check_admin_permissions(message.from_user.id, "manage_admins"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await send_with_media(message.chat.id, "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º–∏:", media_key='admin', reply_markup=admin_admins_keyboard())

@dp.message(F.text == "‚ûï –î–æ–±–∞–≤–∏—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞")
async def add_admin_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_admins"):
        return
    await message.answer("–í–≤–µ–¥–∏ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä–æ–≥–æ —Ö–æ—Ç–∏—Ç–µ —Å–¥–µ–ª–∞—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º:", reply_markup=back_keyboard())
    await state.set_state(AddJuniorAdmin.user_id)

@dp.message(AddJuniorAdmin.user_id, F.text)
async def add_admin_user(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_admins_menu(message)
        return
    try:
        uid = int(message.text)
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ (ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è).")
        return
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
    user = await find_user_by_input(str(uid))
    if not user:
        await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º ID –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ.")
        await state.clear()
        return
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —É–∂–µ –∞–¥–º–∏–Ω–æ–º
    if await is_admin(uid):
        await message.answer("‚ùå –≠—Ç–æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —è–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")
        await state.clear()
        return
    await state.update_data(user_id=uid, first_name=user.get('first_name', f'ID{uid}'))
    # –í—ã–±–æ—Ä –ø—Ä–∞–≤
    await message.answer(
        "–í—ã–±–µ—Ä–∏ –ø—Ä–∞–≤–∞ –¥–ª—è –Ω–æ–≤–æ–≥–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ (–º–æ–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ, –∑–∞—Ç–µ–º –Ω–∞–∂–∞—Ç—å '–ì–æ—Ç–æ–≤–æ'):\n"
        "–û—Ç–ø—Ä–∞–≤–ª—è–π –Ω–æ–º–µ—Ä–∞ –ø—Ä–∞–≤ —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª –∏–ª–∏ –∑–∞–ø—è—Ç—É—é.\n\n"
        + "\n".join([f"{i+1}. {p}" for i, p in enumerate(PERMISSIONS_LIST)])
    )
    await state.set_state(AddJuniorAdmin.permissions)

@dp.message(AddJuniorAdmin.permissions, F.text)
async def add_admin_permissions(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_admins_menu(message)
        return
    # –ü–∞—Ä—Å–∏–º –≤–≤–µ–¥—ë–Ω–Ω—ã–µ –Ω–æ–º–µ—Ä–∞
    selected = []
    for token in message.text.replace(',', ' ').split():
        try:
            idx = int(token) - 1
            if 0 <= idx < len(PERMISSIONS_LIST):
                selected.append(PERMISSIONS_LIST[idx])
        except:
            pass
    if not selected:
        await message.answer("‚ùå –ù–µ –≤—ã–±—Ä–∞–Ω–æ –Ω–∏ –æ–¥–Ω–æ–≥–æ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –ø—Ä–∞–≤–∞. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
        return
    data = await state.get_data()
    uid = data['user_id']
    first_name = data.get('first_name', str(uid))
    try:
        async with db_pool.acquire() as conn:
            await conn.execute(
                "INSERT INTO admins (user_id, added_by, added_date, permissions) VALUES ($1, $2, $3, $4)",
                uid, message.from_user.id, datetime.now().strftime("%Y-%m-%d %H:%M:%S"), json.dumps(selected)
            )
        await message.answer(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {first_name} (ID: {uid}) —Ç–µ–ø–µ—Ä—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä —Å –ø—Ä–∞–≤–∞–º–∏:\n" + "\n".join(selected))
        await safe_send_message(uid, f"‚úÖ –í–∞–º –Ω–∞–∑–Ω–∞—á–µ–Ω—ã –ø—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –≤ –±–æ—Ç–µ.")
    except Exception as e:
        logging.error(f"Add admin error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.")
    await state.clear()

@dp.message(F.text == "‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∞–≤–∞")
async def edit_admin_permissions_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_admins"):
        return
    await message.answer("–í–≤–µ–¥–∏ ID –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞, —á—å–∏ –ø—Ä–∞–≤–∞ –Ω—É–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å:", reply_markup=back_keyboard())
    await state.set_state(EditAdminPermissions.user_id)

@dp.message(EditAdminPermissions.user_id, F.text)
async def edit_admin_permissions_user(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_admins_menu(message)
        return
    try:
        uid = int(message.text)
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.")
        return
    if not await is_junior_admin(uid):
        await message.answer("‚ùå –≠—Ç–æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")
        await state.clear()
        return
    current_perms = await get_admin_permissions(uid)
    await state.update_data(user_id=uid, current_perms=current_perms)
    await message.answer(
        f"–¢–µ–∫—É—â–∏–µ –ø—Ä–∞–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {uid}:\n" + "\n".join(current_perms) + "\n\n"
        "–í–≤–µ–¥–∏ –Ω–æ–≤—ã–µ –ø—Ä–∞–≤–∞ (–Ω–æ–º–µ—Ä–∞ —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª –∏–ª–∏ –∑–∞–ø—è—Ç—É—é):\n"
        + "\n".join([f"{i+1}. {p}" for i, p in enumerate(PERMISSIONS_LIST)])
    )
    await state.set_state(EditAdminPermissions.selecting_permissions)

@dp.message(EditAdminPermissions.selecting_permissions, F.text)
async def edit_admin_permissions_select(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_admins_menu(message)
        return
    selected = []
    for token in message.text.replace(',', ' ').split():
        try:
            idx = int(token) - 1
            if 0 <= idx < len(PERMISSIONS_LIST):
                selected.append(PERMISSIONS_LIST[idx])
        except:
            pass
    if not selected:
        await message.answer("‚ùå –ù–µ –≤—ã–±—Ä–∞–Ω–æ –Ω–∏ –æ–¥–Ω–æ–≥–æ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –ø—Ä–∞–≤–∞. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
        return
    await state.update_data(new_perms=selected)
    data = await state.get_data()
    uid = data['user_id']
    await message.answer(
        f"–ù–æ–≤—ã–µ –ø—Ä–∞–≤–∞ –¥–ª—è {uid}:\n" + "\n".join(selected) + "\n\n"
        "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–µ (–¥–∞/–Ω–µ—Ç):"
    )
    await state.set_state(EditAdminPermissions.confirm)

@dp.message(EditAdminPermissions.confirm, F.text)
async def edit_admin_permissions_confirm(message: Message, state: FSMContext):
    if message.text.lower() == '–Ω–µ—Ç' or message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_admins_menu(message)
        return
    if message.text.lower() == '–¥–∞':
        data = await state.get_data()
        uid = data['user_id']
        new_perms = data['new_perms']
        try:
            await update_admin_permissions(uid, new_perms)
            await message.answer(f"‚úÖ –ü—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ {uid} –æ–±–Ω–æ–≤–ª–µ–Ω—ã.")
            await safe_send_message(uid, f"‚öôÔ∏è –í–∞—à–∏ –ø—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –∏–∑–º–µ–Ω–µ–Ω—ã.")
        except Exception as e:
            logging.error(f"Edit admin permissions error: {e}")
            await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø—Ä–∞–≤.")
        await state.clear()
    else:
        await message.answer("–í–≤–µ–¥–∏ '–¥–∞' –∏–ª–∏ '–Ω–µ—Ç'.")

@dp.message(F.text == "‚ûñ –£–¥–∞–ª–∏—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞")
async def remove_admin_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "manage_admins"):
        return
    await message.answer("–í–≤–µ–¥–∏ ID –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞, –∫–æ—Ç–æ—Ä–æ–≥–æ –Ω—É–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å:", reply_markup=back_keyboard())
    await state.set_state(RemoveJuniorAdmin.user_id)

@dp.message(RemoveJuniorAdmin.user_id, F.text)
async def remove_admin_finish(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_admins_menu(message)
        return
    try:
        uid = int(message.text)
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ.")
        return
    if not await is_junior_admin(uid):
        await message.answer("‚ùå –≠—Ç–æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")
        await state.clear()
        return
    try:
        async with db_pool.acquire() as conn:
            await conn.execute("DELETE FROM admins WHERE user_id=$1", uid)
        await message.answer(f"‚úÖ –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä {uid} —É–¥–∞–ª—ë–Ω.")
        await safe_send_message(uid, f"‚ùå –í–∞—à–∏ –ø—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –æ—Ç–æ–∑–≤–∞–Ω—ã.")
    except Exception as e:
        logging.error(f"Remove admin error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏.")
    await state.clear()

@dp.message(F.text == "üìã –°–ø–∏—Å–æ–∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤")
async def list_admins(message: Message):
    if not await check_admin_permissions(message.from_user.id, "manage_admins"):
        return
    async with db_pool.acquire() as conn:
        rows = await conn.fetch("SELECT user_id, added_by, added_date, permissions FROM admins ORDER BY added_date")
    if not rows:
        await message.answer("–ù–µ—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤, –∫—Ä–æ–º–µ —Å—É–ø–µ—Ä-–∞–¥–º–∏–Ω–æ–≤.")
        return
    text = "üëë –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã:\n\n"
    for row in rows:
        perms = json.loads(row['permissions'])
        text += f"ID: {row['user_id']}\n"
        text += f"–î–æ–±–∞–≤–ª–µ–Ω: {row['added_by']} ({row['added_date']})\n"
        text += f"–ü—Ä–∞–≤–∞: {', '.join(perms)}\n\n"
    parts = safe_split_text(text)
    for part in parts:
        await message.answer(part)

# ==================== –°–¢–ê–¢–ò–°–¢–ò–ö–ê ====================
@dp.message(F.text == "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")
async def stats_handler(message: Message):
    if not await check_admin_permissions(message.from_user.id, "view_stats"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    try:
        async with db_pool.acquire() as conn:
            users = await conn.fetchval("SELECT COUNT(*) FROM users")
            total_balance = await conn.fetchval("SELECT SUM(balance) FROM users") or 0.0
            total_reputation = await conn.fetchval("SELECT SUM(reputation) FROM users") or 0
            total_spent = await conn.fetchval("SELECT SUM(total_spent) FROM users") or 0.0
            total_bitcoin = await conn.fetchval("SELECT SUM(bitcoin_balance) FROM users") or 0.0
            active_giveaways = await conn.fetchval("SELECT COUNT(*) FROM giveaways WHERE status='active'") or 0
            shop_items = await conn.fetchval("SELECT COUNT(*) FROM shop_items") or 0
            purchases_pending = await conn.fetchval("SELECT COUNT(*) FROM purchases WHERE status='pending'") or 0
            total_thefts = await conn.fetchval("SELECT SUM(theft_attempts) FROM users") or 0
            total_thefts_success = await conn.fetchval("SELECT SUM(theft_success) FROM users") or 0
            promos = await conn.fetchval("SELECT COUNT(*) FROM promocodes") or 0
            banned = await conn.fetchval("SELECT COUNT(*) FROM banned_users") or 0
            total_heists = await conn.fetchval("SELECT COUNT(*) FROM heists") or 0
            active_heists = await conn.fetchval("SELECT COUNT(*) FROM heists WHERE status!='finished'") or 0
            confirmed_chats = await conn.fetchval("SELECT COUNT(*) FROM confirmed_chats") or 0
            active_orders = await conn.fetchval("SELECT COUNT(*) FROM bitcoin_orders WHERE status='active'") or 0
            total_businesses = await conn.fetchval("SELECT COUNT(*) FROM user_businesses") or 0
            total_tasks = await conn.fetchval("SELECT COUNT(*) FROM tasks WHERE active=TRUE") or 0
        text = (
            f"üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>\n"
            f"üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {users}\n"
            f"üí∞ –í—Å–µ–≥–æ –±–∞–∫—Å–æ–≤: {float(total_balance):.2f}\n"
            f"‚Çø –í—Å–µ–≥–æ –±–∏—Ç–∫–æ–∏–Ω–æ–≤: {float(total_bitcoin):.4f}\n"
            f"‚≠êÔ∏è –í—Å–µ–≥–æ —Ä–µ–ø—É—Ç–∞—Ü–∏–∏: {total_reputation}\n"
            f"üí∏ –í—Å–µ–≥–æ –ø–æ—Ç—Ä–∞—á–µ–Ω–æ: {float(total_spent):.2f}\n"
            f"üéÅ –ê–∫—Ç–∏–≤–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π: {active_giveaways}\n"
            f"üõí –¢–æ–≤–∞—Ä–æ–≤ –≤ –º–∞–≥–∞–∑–∏–Ω–µ: {shop_items}\n"
            f"üõçÔ∏è –û–∂–∏–¥–∞—é—â–∏—Ö –ø–æ–∫—É–ø–æ–∫: {purchases_pending}\n"
            f"üî´ –í—Å–µ–≥–æ –æ–≥—Ä–∞–±–ª–µ–Ω–∏–π: {total_thefts} (—É—Å–ø–µ—à–Ω–æ: {total_thefts_success})\n"
            f"üé´ –ü—Ä–æ–º–æ–∫–æ–¥–æ–≤ —Å–æ–∑–¥–∞–Ω–æ: {promos}\n"
            f"‚õî –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ: {banned}\n"
            f"üí∞ –í—Å–µ–≥–æ –Ω–∞–ª—ë—Ç–æ–≤: {total_heists} (–∞–∫—Ç–∏–≤–Ω—ã—Ö: {active_heists})\n"
            f"‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã—Ö —á–∞—Ç–æ–≤: {confirmed_chats}\n"
            f"üíº –ê–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞—è–≤–æ–∫ –Ω–∞ –±–∏—Ä–∂–µ: {active_orders}\n"
            f"üè™ –í—Å–µ–≥–æ –±–∏–∑–Ω–µ—Å–æ–≤ —É –∏–≥—Ä–æ–∫–æ–≤: {total_businesses}\n"
            f"üìã –ê–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞–Ω–∏–π: {total_tasks}"
        )
        permissions = await get_admin_permissions(message.from_user.id)
        await message.answer(text, reply_markup=admin_main_keyboard(permissions))
    except Exception as e:
        logging.error(f"Stats error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.")

# ==================== –†–ê–°–°–´–õ–ö–ê ====================
@dp.message(F.text == "üì¢ –†–∞—Å—Å—ã–ª–∫–∞")
async def broadcast_start(message: Message, state: FSMContext):
    if not await check_admin_permissions(message.from_user.id, "broadcast"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await message.answer("–û—Ç–ø—Ä–∞–≤—å —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏ (—Ç–µ–∫—Å—Ç, —Ñ–æ—Ç–æ, –≤–∏–¥–µ–æ –∏–ª–∏ –¥–æ–∫—É–º–µ–Ω—Ç).", reply_markup=back_keyboard())
    await state.set_state(Broadcast.media)

@dp.message(Broadcast.media, F.text | F.photo | F.video | F.document)
async def broadcast_media(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        permissions = await get_admin_permissions(message.from_user.id)
        await message.answer("–ü–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:", reply_markup=admin_main_keyboard(permissions))
        return

    content = {}
    if message.text:
        content['type'] = 'text'
        content['text'] = message.text
    elif message.photo:
        content['type'] = 'photo'
        content['file_id'] = message.photo[-1].file_id
        content['caption'] = message.caption or ""
    elif message.video:
        content['type'] = 'video'
        content['file_id'] = message.video.file_id
        content['caption'] = message.caption or ""
    elif message.document:
        content['type'] = 'document'
        content['file_id'] = message.document.file_id
        content['caption'] = message.caption or ""
    else:
        await message.answer("–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ç–∏–ø.")
        return

    await state.clear()

    status_msg = await message.answer("‚è≥ –†–∞—Å—Å—ã–ª–∫–∞ –Ω–∞—á–∞—Ç–∞... –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è.")

    async with db_pool.acquire() as conn:
        users = await conn.fetch("SELECT user_id FROM users")
        users = [r['user_id'] for r in users]

    sent = 0
    failed = 0
    total = len(users)

    for i, uid in enumerate(users):
        if await is_banned(uid):
            continue
        try:
            if content['type'] == 'text':
                await bot.send_message(uid, content['text'])
            elif content['type'] == 'photo':
                await bot.send_photo(uid, content['file_id'], caption=content['caption'])
            elif content['type'] == 'video':
                await bot.send_video(uid, content['file_id'], caption=content['caption'])
            elif content['type'] == 'document':
                await bot.send_document(uid, content['file_id'], caption=content['caption'])
            sent += 1
        except (TelegramForbiddenError, TelegramBadRequest):
            failed += 1
        except TelegramRetryAfter as e:
            logging.warning(f"Flood limit, waiting {e.retry_after} seconds")
            await asyncio.sleep(e.retry_after)
            try:
                if content['type'] == 'text':
                    await bot.send_message(uid, content['text'])
                else:
                    if content['type'] == 'photo':
                        await bot.send_photo(uid, content['file_id'], caption=content['caption'])
                    elif content['type'] == 'video':
                        await bot.send_video(uid, content['file_id'], caption=content['caption'])
                    elif content['type'] == 'document':
                        await bot.send_document(uid, content['file_id'], caption=content['caption'])
                sent += 1
            except:
                failed += 1
        except Exception as e:
            failed += 1
            logging.warning(f"Failed to send to {uid}: {e}")

        if (i + 1) % 10 == 0:
            try:
                await status_msg.edit_text(f"‚è≥ –ü—Ä–æ–≥—Ä–µ—Å—Å: {i+1}/{total}\n‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {sent}\n‚ùå –û—à–∏–±–æ–∫: {failed}")
            except:
                pass

        await asyncio.sleep(0.05)

    await status_msg.edit_text(f"‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\nüìä –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {sent}\n‚ùå –û—à–∏–±–æ–∫: {failed}\nüë• –í—Å–µ–≥–æ: {total}")

# ==================== –ù–ê–°–¢–†–û–ô–ö–ò ====================
# –ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ (–æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –∑–¥–µ—Å—å, —Ç–∞–∫ –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ —ç—Ç–æ–π —á–∞—Å—Ç–∏)
SETTINGS_CATEGORIES = {
    "‚öôÔ∏è –ö–∞–∑–∏–Ω–æ": [
        ("casino_win_chance", "üé∞ –û–±—â–∏–π —à–∞–Ω—Å –≤—ã–∏–≥—Ä—ã—à–∞ (%)"),
        ("casino_min_bet", "üí∞ –ú–∏–Ω. —Å—Ç–∞–≤–∫–∞"),
        ("casino_max_bet", "üí∞ –ú–∞–∫—Å. —Å—Ç–∞–≤–∫–∞"),
        ("min_level_casino", "üîí –ú–∏–Ω. —É—Ä–æ–≤–µ–Ω—å –¥–ª—è –∫–∞–∑–∏–Ω–æ"),
        ("slots_win_probability", "üçí –®–∞–Ω—Å –≤—ã–∏–≥—Ä—ã—à–∞ –≤ —Å–ª–æ—Ç–∞—Ö (%)"),
        ("slots_multiplier_three", "üçí –ú–Ω–æ–∂–∏—Ç–µ–ª—å 3 —Å–∏–º–≤–æ–ª–∞"),
        ("slots_multiplier_diamond", "üíé –ú–Ω–æ–∂–∏—Ç–µ–ª—å –±—Ä–∏–ª–ª–∏–∞–Ω—Ç—ã"),
        ("slots_multiplier_seven", "7Ô∏è‚É£ –ú–Ω–æ–∂–∏—Ç–µ–ª—å —Å–µ–º–µ—Ä–∫–∏"),
        ("roulette_win_chance", "üé° –®–∞–Ω—Å –≤—ã–∏–≥—Ä—ã—à–∞ –≤ —Ä—É–ª–µ—Ç–∫–µ (%)"),
        ("roulette_number_multiplier", "üé° –ú–Ω–æ–∂–∏—Ç–µ–ª—å –Ω–∞ —á–∏—Å–ª–æ"),
        ("roulette_green_multiplier", "üé° –ú–Ω–æ–∂–∏—Ç–µ–ª—å –Ω–∞ –∑–µ–ª—ë–Ω–æ–µ"),
        ("roulette_color_multiplier", "üé° –ú–Ω–æ–∂–∏—Ç–µ–ª—å –Ω–∞ —Ü–≤–µ—Ç"),
    ],
    "‚öôÔ∏è –ö—Ä–∞–∂–∞": [
        ("random_attack_cost", "üí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å —Å–ª—É—á–∞–π–Ω–æ–π –∫—Ä–∞–∂–∏"),
        ("targeted_attack_cost", "üéØ –°—Ç–æ–∏–º–æ—Å—Ç—å —Ü–µ–ª–µ–≤–æ–π –∫—Ä–∞–∂–∏"),
        ("theft_cooldown_minutes", "‚è≥ –ö—É–ª–¥–∞—É–Ω –∫—Ä–∞–∂–∏ (–º–∏–Ω—É—Ç—ã)"),
        ("theft_success_chance", "‚úÖ –®–∞–Ω—Å —É—Å–ø–µ—Ö–∞ –∫—Ä–∞–∂–∏ (%)"),
        ("theft_defense_chance", "üõ° –®–∞–Ω—Å –∑–∞—â–∏—Ç—ã –∂–µ—Ä—Ç–≤—ã (%)"),
        ("theft_defense_penalty", "üí∏ –®—Ç—Ä–∞—Ñ –ø—Ä–∏ –∑–∞—â–∏—Ç–µ"),
        ("min_theft_amount", "‚¨áÔ∏è –ú–∏–Ω. —Å—É–º–º–∞ –∫—Ä–∞–∂–∏"),
        ("max_theft_amount", "‚¨ÜÔ∏è –ú–∞–∫—Å. —Å—É–º–º–∞ –∫—Ä–∞–∂–∏"),
    ],
    "‚öôÔ∏è –ö–∏–¥–∞–ª–æ–≤–æ (PVP)": [
        ("betray_base_chance", "üé≤ –ë–∞–∑–æ–≤—ã–π —à–∞–Ω—Å —É—Å–ø–µ—Ö–∞ (%)"),
        ("betray_steal_percent", "üí∏ –ü—Ä–æ—Ü–µ–Ω—Ç –∫—Ä–∞–∂–∏ –ø—Ä–∏ —É—Å–ø–µ—Ö–µ"),
        ("betray_fail_penalty_percent", "üí∏ –®—Ç—Ä–∞—Ñ –ø—Ä–∏ –ø—Ä–æ–≤–∞–ª–µ (%)"),
        ("betray_cooldown_minutes", "‚è≥ –ö—É–ª–¥–∞—É–Ω –º–µ–∂–¥—É –∫–∏–¥–∫–∞–º–∏ (–º–∏–Ω—É—Ç—ã)"),
        ("betray_max_chance", "üìà –ú–∞–∫—Å. —à–∞–Ω—Å —É—Å–ø–µ—Ö–∞ (%)"),
    ],
    "‚öôÔ∏è –ù–∞–ª—ë—Ç—ã": [
        ("heist_min_interval_minutes", "‚è≥ –ú–∏–Ω. –∏–Ω—Ç–µ—Ä–≤–∞–ª –º–µ–∂–¥—É –Ω–∞–ª—ë—Ç–∞–º–∏ (–º–∏–Ω—É—Ç—ã)"),
        ("heist_max_interval_minutes", "‚è≥ –ú–∞–∫—Å. –∏–Ω—Ç–µ—Ä–≤–∞–ª"),
        ("heist_join_minutes", "‚è± –í—Ä–µ–º—è –Ω–∞ —Å–±–æ—Ä (–º–∏–Ω—É—Ç—ã)"),
        ("heist_split_minutes", "‚è± –í—Ä–µ–º—è –Ω–∞ —Ä–∞—Å–ø–∏–ª (–º–∏–Ω—É—Ç—ã)"),
        ("heist_min_pot", "üí∞ –ú–∏–Ω. –±–∞–Ω–∫ (–±–∞–∫—Å—ã)"),
        ("heist_max_pot", "üí∞ –ú–∞–∫—Å. –±–∞–Ω–∫"),
        ("heist_btc_chance", "‚Çø –®–∞–Ω—Å –ø–æ—è–≤–ª–µ–Ω–∏—è BTC (%)"),
        ("heist_min_btc", "‚Çø –ú–∏–Ω. BTC"),
        ("heist_max_btc", "‚Çø –ú–∞–∫—Å. BTC"),
        ("heist_cooldown_minutes", "‚è≥ –ö—É–ª–¥–∞—É–Ω –º–µ–∂–¥—É –Ω–∞–ª—ë—Ç–∞–º–∏ –≤ —á–∞—Ç–µ"),
        ("heist_participant_cooldown_hours", "‚è≥ –ö—É–ª–¥–∞—É–Ω —É—á–∞—Å—Ç–Ω–∏–∫–∞ (—á–∞—Å—ã)"),
        ("heist_share_min", "üçÄ –ú–∏–Ω. –¥–æ–ª—è —É—á–∞—Å—Ç–Ω–∏–∫–∞"),
        ("heist_share_max", "üçÄ –ú–∞–∫—Å. –¥–æ–ª—è —É—á–∞—Å—Ç–Ω–∏–∫–∞"),
    ],
    "‚öôÔ∏è –ë–∏–∑–Ω–µ—Å—ã": [
        ("business_upgrade_cost_per_level", "üìà –ë–∞–∑–∞ —Å—Ç–æ–∏–º–æ—Å—Ç–∏ —É–ª—É—á—à–µ–Ω–∏—è"),
        ("business_collect_interval_minutes", "‚è± –ò–Ω—Ç–µ—Ä–≤–∞–ª —Å–±–æ—Ä–∞ (–º–∏–Ω—É—Ç—ã)"),
        ("business_max_storage_hours", "‚è≥ –ú–∞–∫—Å. –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–µ (—á–∞—Å—ã)"),
        ("business_max_businesses", "üìä –ú–∞–∫—Å. –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–∏–∑–Ω–µ—Å–æ–≤"),
        ("business_lifetime_hours_default", "‚è≥ –°—Ä–æ–∫ –∂–∏–∑–Ω–∏ –±–∏–∑–Ω–µ—Å–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (—á–∞—Å—ã)"),
    ],
    "‚öôÔ∏è –û–ø—ã—Ç –∏ —É—Ä–æ–≤–Ω–∏": [
        ("exp_per_dice_win", "üé≤ –û–ø—ã—Ç –∑–∞ –ø–æ–±–µ–¥—É –≤ –∫–æ—Å—Ç–∏"),
        ("exp_per_dice_lose", "üé≤ –û–ø—ã—Ç –∑–∞ –ø—Ä–æ–∏–≥—Ä—ã—à"),
        ("exp_per_guess_win", "üî¢ –û–ø—ã—Ç –∑–∞ –ø–æ–±–µ–¥—É –≤ —É–≥–∞–¥–∞–π–∫–µ"),
        ("exp_per_guess_lose", "üî¢ –û–ø—ã—Ç –∑–∞ –ø—Ä–æ–∏–≥—Ä—ã—à"),
        ("exp_per_slots_win", "üçí –û–ø—ã—Ç –∑–∞ –ø–æ–±–µ–¥—É –≤ —Å–ª–æ—Ç–∞—Ö"),
        ("exp_per_slots_lose", "üçí –û–ø—ã—Ç –∑–∞ –ø—Ä–æ–∏–≥—Ä—ã—à"),
        ("exp_per_roulette_win", "üé° –û–ø—ã—Ç –∑–∞ –ø–æ–±–µ–¥—É –≤ —Ä—É–ª–µ—Ç–∫–µ"),
        ("exp_per_roulette_lose", "üé° –û–ø—ã—Ç –∑–∞ –ø—Ä–æ–∏–≥—Ä—ã—à"),
        ("exp_per_theft_success", "üî´ –û–ø—ã—Ç –∑–∞ —É—Å–ø–µ—à–Ω—É—é –∫—Ä–∞–∂—É"),
        ("exp_per_theft_fail", "üî´ –û–ø—ã—Ç –∑–∞ –ø—Ä–æ–≤–∞–ª –∫—Ä–∞–∂–∏"),
        ("exp_per_theft_defense", "üõ° –û–ø—ã—Ç –∑–∞ –∑–∞—â–∏—Ç—É"),
        ("exp_per_heist_participation", "üí∞ –û–ø—ã—Ç –∑–∞ —É—á–∞—Å—Ç–∏–µ –≤ –Ω–∞–ª—ë—Ç–µ"),
        ("exp_per_betray_success", "üî™ –û–ø—ã—Ç –∑–∞ —É—Å–ø–µ—à–Ω–æ–µ –∫–∏–¥–∞–ª–æ–≤–æ"),
        ("exp_per_betray_fail", "üî™ –û–ø—ã—Ç –∑–∞ –Ω–µ—É–¥–∞—á–Ω–æ–µ –∫–∏–¥–∞–ª–æ–≤–æ"),
        ("exp_per_smuggle", "üì¶ –û–ø—ã—Ç –∑–∞ –∫–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥—É"),
        ("exp_per_jail", "üèõ –û–ø—ã—Ç –∑–∞ —Ç—é—Ä—å–º—É"),
        ("level_multiplier", "üìä –ú–Ω–æ–∂–∏—Ç–µ–ª—å –æ–ø—ã—Ç–∞ –¥–ª—è —É—Ä–æ–≤–Ω—è"),
        ("level_reward_coins", "üí∞ –ë–∞–∑–∞ –Ω–∞–≥—Ä–∞–¥—ã –∑–∞ —É—Ä–æ–≤–µ–Ω—å"),
        ("level_reward_reputation", "‚≠ê –ë–∞–∑–∞ —Ä–µ–ø—É—Ç–∞—Ü–∏–∏ –∑–∞ —É—Ä–æ–≤–µ–Ω—å"),
        ("level_reward_coins_increment", "üìà –ü—Ä–∏—Ä–æ—Å—Ç –±–∞–∫—Å–æ–≤ –∑–∞ —É—Ä–æ–≤–µ–Ω—å"),
        ("level_reward_reputation_increment", "üìà –ü—Ä–∏—Ä–æ—Å—Ç —Ä–µ–ø—É—Ç–∞—Ü–∏–∏ –∑–∞ —É—Ä–æ–≤–µ–Ω—å"),
    ],
    "‚öôÔ∏è –†–µ—Ñ–µ—Ä–∞–ª—ã": [
        ("referral_bonus", "üí∞ –ë–æ–Ω—É—Å –∑–∞ —Ä–µ—Ñ–µ—Ä–∞–ª–∞"),
        ("referral_reputation", "‚≠ê –†–µ–ø—É—Ç–∞—Ü–∏—è –∑–∞ —Ä–µ—Ñ–µ—Ä–∞–ª–∞"),
        ("referral_required_thefts", "üî´ –¢—Ä–µ–±—É–µ—Ç—Å—è –∫—Ä–∞–∂ –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏"),
    ],
    "‚öôÔ∏è –ü–æ–¥–≥–æ–Ω": [
        ("gift_amount", "üéÅ –°—É–º–º–∞ –ø–æ–¥–≥–æ–Ω–∞"),
        ("gift_limit_per_day", "üìä –õ–∏–º–∏—Ç –ø–æ–¥–≥–æ–Ω–æ–≤ –≤ —á–∞—Ç–µ –≤ –¥–µ–Ω—å"),
        ("gift_global_limit_per_user", "üåê –ì–ª–æ–±–∞–ª—å–Ω—ã–π –ª–∏–º–∏—Ç –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"),
        ("gift_cooldown", "‚è≥ –ö—É–ª–¥–∞—É–Ω –ø–æ–¥–≥–æ–Ω–∞ (–º–∏–Ω—É—Ç—ã)"),
    ],
    "‚öôÔ∏è –ë–∏—Ç–∫–æ–∏–Ω-–±–∏—Ä–∂–∞": [
        ("exchange_min_price", "‚¨áÔ∏è –ú–∏–Ω. —Ü–µ–Ω–∞ BTC"),
        ("exchange_max_price", "‚¨ÜÔ∏è –ú–∞–∫—Å. —Ü–µ–Ω–∞ BTC (0 - –±–µ–∑ –ª–∏–º–∏—Ç–∞)"),
        ("exchange_commission_percent", "üí∏ –ö–æ–º–∏—Å—Å–∏—è –±–∏—Ä–∂–∏ (%)"),
        ("exchange_commission_side", "üîÅ –°—Ç–æ—Ä–æ–Ω–∞ –∫–æ–º–∏—Å—Å–∏–∏ (buyer/seller/both)"),
        ("exchange_commission_destination", "üìç –ö—É–¥–∞ –∏–¥—ë—Ç –∫–æ–º–∏—Å—Å–∏—è (burn/balance)"),
        ("exchange_min_amount_btc", "‚¨áÔ∏è –ú–∏–Ω. —Å—É–º–º–∞ –∑–∞—è–≤–∫–∏ (BTC)"),
    ],
    "‚öôÔ∏è –ê–≤—Ç–æ—É–¥–∞–ª–µ–Ω–∏–µ": [
        ("auto_delete_commands_seconds", "‚è≥ –ê–≤—Ç–æ—É–¥–∞–ª–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥ (—Å–µ–∫—É–Ω–¥)"),
    ],
    "‚öôÔ∏è –ü—Ä–æ–∫–∞—á–∫–∞ –Ω–∞–≤—ã–∫–æ–≤": [
        ("skill_share_cost_per_level", "üéØ –°—Ç–æ–∏–º–æ—Å—Ç—å —É—Ä–æ–≤–Ω—è –î–æ–ª–∏"),
        ("skill_luck_cost_per_level", "üçÄ –°—Ç–æ–∏–º–æ—Å—Ç—å —É—Ä–æ–≤–Ω—è –£–¥–∞—á–∏"),
        ("skill_betray_cost_per_level", "üî™ –°—Ç–æ–∏–º–æ—Å—Ç—å —É—Ä–æ–≤–Ω—è –ö–∏–¥–∞–ª–æ–≤–∞"),
        ("skill_share_bonus_per_level", "üéØ –ë–æ–Ω—É—Å –î–æ–ª–∏ –∑–∞ —É—Ä–æ–≤–µ–Ω—å (%)"),
        ("skill_luck_bonus_per_level", "üçÄ –ë–æ–Ω—É—Å –£–¥–∞—á–∏ –∑–∞ —É—Ä–æ–≤–µ–Ω—å (%)"),
        ("skill_betray_bonus_per_level", "üî™ –ë–æ–Ω—É—Å –ö–∏–¥–∞–ª–æ–≤–∞ –∑–∞ —É—Ä–æ–≤–µ–Ω—å (%)"),
        ("skill_max_level", "üìà –ú–∞–∫—Å. —É—Ä–æ–≤–µ–Ω—å –Ω–∞–≤—ã–∫–æ–≤"),
    ],
    "‚öôÔ∏è –ö–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥–∞": [
        ("smuggle_base_amount", "‚Çø –ë–∞–∑–æ–≤–∞—è –¥–æ–±—ã—á–∞ BTC"),
        ("smuggle_cooldown_minutes", "‚è≥ –ë–∞–∑–æ–≤—ã–π –∫—É–ª–¥–∞—É–Ω (–º–∏–Ω—É—Ç—ã)"),
        ("smuggle_fail_penalty_minutes", "üíî –®—Ç—Ä–∞—Ñ –ø—Ä–∏ –ø—Ä–æ–≤–∞–ª–µ (–º–∏–Ω—É—Ç—ã)"),
        ("smuggle_success_chance", "‚úÖ –®–∞–Ω—Å —É—Å–ø–µ—Ö–∞ (%)"),
        ("smuggle_caught_chance", "üö® –®–∞–Ω—Å –ø–æ–ø–∞—Å—Ç—å—Å—è (%)"),
        ("smuggle_lost_chance", "üí• –®–∞–Ω—Å –ø–æ—Ç–µ—Ä—è—Ç—å –≥—Ä—É–∑ (%)"),
        ("smuggle_min_duration", "‚è± –ú–∏–Ω. –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å (–º–∏–Ω—É—Ç—ã)"),
        ("smuggle_max_duration", "‚è± –ú–∞–∫—Å. –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å (–º–∏–Ω—É—Ç—ã)"),
    ],
    "‚öôÔ∏è –¢—é—Ä—å–º–∞": [
        ("jail_min_duration", "‚è± –ú–∏–Ω. —Å—Ä–æ–∫ (–º–∏–Ω—É—Ç—ã)"),
        ("jail_max_duration", "‚è± –ú–∞–∫—Å. —Å—Ä–æ–∫ (–º–∏–Ω—É—Ç—ã)"),
        ("jail_success_chance", "‚úÖ –®–∞–Ω—Å –ø–æ–ª—É—á–∏—Ç—å –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç (%)"),
        ("jail_auth_min", "‚¨áÔ∏è –ú–∏–Ω. –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç –∑–∞ —É—Å–ø–µ—Ö"),
        ("jail_auth_max", "‚¨ÜÔ∏è –ú–∞–∫—Å. –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç –∑–∞ —É—Å–ø–µ—Ö"),
        ("jail_cooldown_hours", "‚è≥ –ö—É–ª–¥–∞—É–Ω —Ç—é—Ä—å–º—ã (—á–∞—Å—ã)"),
    ],
    "‚öôÔ∏è –ó–∞–¥–∞–Ω–∏—è": [
        ("task_subscribe_check_interval", "‚è± –ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∫–∏ (—Å–µ–∫)"),
    ],
    "‚öôÔ∏è –ü—Ä–æ–º–æ–∫–æ–¥—ã": [
        ("promocode_max_uses_default", "üìä –ú–∞–∫—Å. –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é"),
    ],
}

@dp.message(F.text == "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏")
async def settings_menu(message: Message):
    if not await check_admin_permissions(message.from_user.id, "edit_settings"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await send_with_media(message.chat.id, "–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –Ω–∞—Å—Ç—Ä–æ–µ–∫:", media_key='admin_settings', reply_markup=settings_categories_keyboard())

@dp.message(F.text.in_(SETTINGS_CATEGORIES.keys()))
async def settings_category_handler(message: Message):
    if not await check_admin_permissions(message.from_user.id, "edit_settings"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return

    category = message.text
    params = SETTINGS_CATEGORIES.get(category, [])

    text = f"<b>{category}</b>\n\n"
    kb_params = []
    for key, desc in params:
        value = await get_setting(key)
        text += f"{desc}: <code>{value}</code>\n"
        kb_params.append((key, desc))

    kb = settings_param_keyboard(kb_params, category)
    await message.answer(text, reply_markup=kb)

@dp.callback_query(F.data.startswith("settings_back_"))
async def settings_back_callback(callback: CallbackQuery):
    category = callback.data.split("_", 2)[2]
    await callback.message.delete()
    await settings_menu(callback.message)
    await callback.answer()

@dp.callback_query(F.data.startswith("edit_"))
async def edit_setting_start(callback: CallbackQuery, state: FSMContext):
    if not await check_admin_permissions(callback.from_user.id, "edit_settings"):
        await callback.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return

    key = callback.data[5:]
    current_value = await get_setting(key)

    await state.update_data(key=key)
    await callback.message.answer(
        f"‚öôÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ <b>{key}</b>\n"
        f"–¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: <code>{current_value}</code>\n\n"
        f"–í–≤–µ–¥–∏ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ:",
        reply_markup=back_keyboard()
    )
    await state.set_state(EditSettings.key)
    await callback.answer()

@dp.message(EditSettings.key, F.text)
async def edit_setting_value(message: Message, state: FSMContext):
    if message.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await settings_menu(message)
        return

    data = await state.get_data()
    key = data['key']
    new_value = message.text.strip()

    try:
        await set_setting(key, new_value)
        await message.answer(f"‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∞ <b>{key}</b> –æ–±–Ω–æ–≤–ª–µ–Ω–∞!\n–ù–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: <code>{new_value}</code>")
    except Exception as e:
        logging.error(f"Error setting {key}: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.")

    await state.clear()
    await settings_menu(message)

# ==================== –û–ß–ò–°–¢–ö–ê ====================
@dp.message(F.text == "üßπ –û—á–∏—Å—Ç–∫–∞")
async def cleanup_old_data(message: Message):
    if not await check_admin_permissions(message.from_user.id, "cleanup"):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    await perform_cleanup(manual=True)
    await message.answer("‚úÖ –°—Ç–∞—Ä—ã–µ –∑–∞–ø–∏—Å–∏ –æ—á–∏—â–µ–Ω—ã —Å–æ–≥–ª–∞—Å–Ω–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º.")

# ==================== –û–ë–†–ê–ë–û–¢–ß–ò–ö –î–õ–Ø noop ====================
@dp.callback_query(F.data == "noop")
async def noop_callback(callback: CallbackQuery):
    """–ü—Ä–æ—Å—Ç–æ –æ—Ç–≤–µ—á–∞–µ—Ç –Ω–∞ –Ω–∞–∂–∞—Ç–∏–µ –Ω–µ–∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–π –∫–Ω–æ–ø–∫–∏."""
    await callback.answer()

# ==================== –ö–û–ù–ï–¶ –ß–ê–°–¢–ò 5.2 ====================
# ==================== –ß–ê–°–¢–¨ 6: –§–û–ù–û–í–´–ï –ó–ê–î–ê–ß–ò –ò –ó–ê–ü–£–°–ö (–§–ò–ù–ê–õ–¨–ù–ê–Ø –í–ï–†–°–ò–Ø) ====================
# –ü–æ–ª–Ω–æ—Å—Ç—å—é –ø–µ—Ä–µ–ø–∏—Å–∞–Ω–æ –¥–ª—è aiogram 3.x. –í—Å–µ –æ—à–∏–±–∫–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã.
# - –î–æ–±–∞–≤–ª–µ–Ω—ã –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ Redis –¥–ª—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –∑–∞–¥–∞—á
# - –£–ª—É—á—à–µ–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –≤ —Ñ–æ–Ω–æ–≤—ã—Ö –∑–∞–¥–∞—á–∞—Ö
# - –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –æ–±—ë—Ä–Ω—É—Ç—ã –≤ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
# - –í—Å–µ –≤—ã–∑–æ–≤—ã update_user_balance –∏—Å–ø–æ–ª—å–∑—É—é—Ç allow_negative=False
# - add_exp –≤–Ω—É—Ç—Ä–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ –æ—Ç–ø—Ä–∞–≤–ª—è—é—Ç—Å—è –ø–æ—Å–ª–µ –∫–æ–º–º–∏—Ç–∞
# - –ò—Å–ø—Ä–∞–≤–ª–µ–Ω –∑–∞–ø—É—Å–∫ —á–µ—Ä–µ–∑ main() —Å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–µ–π
# - –î–æ–±–∞–≤–ª–µ–Ω –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–π –∏–º–ø–æ—Ä—Ç json

import asyncio
import logging
import random
import json
from datetime import datetime, timedelta

from aiogram import types

# –í—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ —á–∞—Å—Ç–µ–π 1-5 –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞—é—Ç—Å—è –¥–æ—Å—Ç—É–ø–Ω—ã–º–∏
# (bot, dp, db_pool, redis_client, –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã, —Å–æ—Å—Ç–æ—è–Ω–∏—è)

# ==================== –§–û–ù–û–í–ê–Ø –ó–ê–î–ê–ß–ê: –°–ü–ê–í–ù –ù–ê–õ–Å–¢–û–í ====================
async def heist_spawner():
    """–ö–∞–∂–¥—ã–π —á–∞—Å —Å–æ–∑–¥–∞—ë—Ç –Ω–∞–ª—ë—Ç—ã –≤–æ –≤—Å–µ—Ö –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã—Ö —á–∞—Ç–∞—Ö (—Å —É—á—ë—Ç–æ–º –∫—É–ª–¥–∞—É–Ω–∞)."""
    while True:
        try:
            interval_minutes = await get_setting_int("heist_min_interval_minutes")
            await asyncio.sleep(interval_minutes * 60)

            confirmed = await get_confirmed_chats()
            if not confirmed:
                continue

            for chat_id, chat_data in confirmed.items():
                try:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ—Ç –ª–∏ —É–∂–µ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –Ω–∞–ª—ë—Ç–∞
                    async with db_pool.acquire() as conn:
                        existing = await conn.fetchval(
                            "SELECT 1 FROM heists WHERE chat_id=$1 AND status IN ('joining', 'splitting')",
                            chat_id
                        )
                        if existing:
                            continue

                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –Ω–∞–ª—ë—Ç–∞
                        last_heist = chat_data.get('last_heist_time')
                        if last_heist:
                            if datetime.now() - last_heist < timedelta(minutes=interval_minutes):
                                continue

                    # –°–æ–∑–¥–∞—ë–º –Ω–∞–ª—ë—Ç
                    await spawn_heist(chat_id)

                    # –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –Ω–∞–ª—ë—Ç–∞
                    async with db_pool.acquire() as conn:
                        await conn.execute(
                            "UPDATE confirmed_chats SET last_heist_time=$1 WHERE chat_id=$2",
                            datetime.now(), chat_id
                        )

                    await asyncio.sleep(2)  # –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —á–∞—Ç–∞–º–∏

                except Exception as e:
                    logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –Ω–∞–ª—ë—Ç–∞ –≤ —á–∞—Ç–µ {chat_id}: {e}")
                    continue

        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –≤ heist_spawner: {e}")
            await asyncio.sleep(60)

# ==================== –§–û–ù–û–í–ê–Ø –ó–ê–î–ê–ß–ê: –û–ë–†–ê–ë–û–¢–ö–ê –ö–û–ù–¢–†–ê–ë–ê–ù–î–ù–´–• –†–ï–ô–°–û–í ====================
async def process_smuggle_runs():
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–µ –∫–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥–Ω—ã–µ —Ä–µ–π—Å—ã –∏ –Ω–∞—á–∏—Å–ª—è–µ—Ç –Ω–∞–≥—Ä–∞–¥—É."""
    while True:
        try:
            await asyncio.sleep(30)
            now = datetime.now()
            async with db_pool.acquire() as conn:
                runs = await conn.fetch("""
                    SELECT * FROM smuggle_runs
                    WHERE status = 'in_progress' AND end_time <= $1 AND notified = FALSE
                """, now)

                for run in runs:
                    run_id = run['id']
                    user_id = run['user_id']
                    chat_id = run['chat_id']

                    # –ü–æ–ª—É—á–∞–µ–º –Ω–∞–≤—ã–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                    skills = await get_user_skills(user_id)
                    luck = skills['skill_luck']
                    share = skills['skill_share']

                    # –ë–∞–∑–æ–≤—ã–µ —à–∞–Ω—Å—ã –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫
                    success_chance = await get_setting_int("smuggle_success_chance")
                    caught_chance = await get_setting_int("smuggle_caught_chance")
                    lost_chance = await get_setting_int("smuggle_lost_chance")

                    # –ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä—É–µ–º —É–¥–∞—á–µ–π
                    luck_bonus = luck * await get_setting_int("skill_luck_bonus_per_level")
                    success_chance = min(success_chance + luck_bonus, 90)
                    remaining = 100 - success_chance
                    total_other = caught_chance + lost_chance
                    if total_other > 0:
                        adjusted_caught = int(remaining * caught_chance / total_other)
                        adjusted_lost = remaining - adjusted_caught
                    else:
                        adjusted_caught = 0
                        adjusted_lost = 0

                    rand = random.randint(1, 100)
                    amount = 0.0
                    result_text = ""
                    status = ""
                    penalty = 0
                    media_key = None

                    user_info = await conn.fetchrow("SELECT first_name, username FROM users WHERE user_id=$1", user_id)
                    name = user_info['first_name'] if user_info else f"ID{user_id}"
                    username = user_info['username'] if user_info and user_info['username'] else "–Ω–µ—Ç —é–∑–µ—Ä–Ω–µ–π–º–∞"

                    # –í—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤—ã–ø–æ–ª–Ω—è–µ–º –≤ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
                    async with conn.transaction():
                        if rand <= success_chance:
                            base_amount = await get_setting_float("smuggle_base_amount")
                            share_bonus = share * await get_setting_int("skill_share_bonus_per_level") / 100.0
                            amount = base_amount * (1 + share_bonus)
                            amount = round(amount, 4)
                            success, new_balance = await update_user_bitcoin(user_id, amount, conn=conn)
                            if not success:
                                logging.error(f"Smuggle success: failed to add BTC to user {user_id}")
                            await conn.execute(
                                "UPDATE users SET smuggle_success = smuggle_success + 1 WHERE user_id = $1",
                                user_id
                            )
                            result_text = get_random_phrase(SMUGGLE_SUCCESS_PHRASES, name=name, username=username, amount=amount)
                            status = 'completed'
                            media_key = 'smuggle_success'
                        elif rand <= success_chance + adjusted_caught:
                            penalty = await get_setting_int("smuggle_fail_penalty_minutes")
                            await conn.execute(
                                "UPDATE users SET smuggle_fail = smuggle_fail + 1 WHERE user_id = $1",
                                user_id
                            )
                            result_text = get_random_phrase(SMUGGLE_FAIL_PHRASES, name=name, username=username)
                            status = 'failed'
                            media_key = 'smuggle_fail'
                        else:
                            await conn.execute(
                                "UPDATE users SET smuggle_fail = smuggle_fail + 1 WHERE user_id = $1",
                                user_id
                            )
                            result_text = get_random_phrase(SMUGGLE_FAIL_PHRASES, name=name, username=username)
                            status = 'failed'
                            media_key = 'smuggle_fail'
                            penalty = 0

                        await conn.execute(
                            "UPDATE smuggle_runs SET status = $1, notified = TRUE, result = $2, smuggle_amount = $3 WHERE id = $4",
                            status, result_text, amount, run_id
                        )

                        exp = await get_setting_int("exp_per_smuggle")
                        level_up_msg = await add_exp(user_id, exp, conn=conn)

                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ—Å–ª–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
                    if chat_id:
                        try:
                            await send_with_media(chat_id, result_text, media_key=media_key)
                        except Exception as e:
                            logging.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∫–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥—ã –≤ —á–∞—Ç {chat_id}: {e}")
                            await safe_send_message(user_id, result_text)
                    else:
                        await safe_send_message(user_id, result_text)

                    await set_smuggle_cooldown(user_id, penalty)

                    if level_up_msg:
                        await safe_send_message(user_id, level_up_msg)

        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –≤ process_smuggle_runs: {e}")
            await asyncio.sleep(60)

# ==================== –§–û–ù–û–í–ê–Ø –ó–ê–î–ê–ß–ê: –û–ë–†–ê–ë–û–¢–ö–ê –¢–Æ–†–ï–ú–ù–´–• –°–†–û–ö–û–í ====================
async def process_jail_sentences():
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–µ —Ç—é—Ä–µ–º–Ω—ã–µ —Å—Ä–æ–∫–∏ –∏ –≤—ã–Ω–æ—Å–∏—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç."""
    while True:
        try:
            await asyncio.sleep(30)
            now = datetime.now()
            async with db_pool.acquire() as conn:
                rows = await conn.fetch("""
                    SELECT * FROM jail_sentences
                    WHERE status = 'serving' AND end_time <= $1 AND notified = FALSE
                """, now)

                for row in rows:
                    sentence_id = row['id']
                    user_id = row['user_id']
                    chat_id = row['chat_id']
                    success_chance = await get_setting_int("jail_success_chance")
                    auth_min = await get_setting_int("jail_auth_min")
                    auth_max = await get_setting_int("jail_auth_max")
                    cell = row['cell_number']
                    article = row['article_number']

                    success = random.randint(1, 100) <= success_chance
                    auth_gain = 0
                    media_key = None

                    user_info = await conn.fetchrow("SELECT first_name, username FROM users WHERE user_id=$1", user_id)
                    name = user_info['first_name'] if user_info else f"ID{user_id}"
                    username = user_info['username'] if user_info and user_info['username'] else "–Ω–µ—Ç —é–∑–µ—Ä–Ω–µ–π–º–∞"

                    async with conn.transaction():
                        if success:
                            auth_gain = random.randint(auth_min, auth_max)
                            await update_user_authority(user_id, auth_gain, conn=conn)
                            phrase = get_random_phrase(JAIL_SUCCESS_PHRASES, name=name, username=username, auth=auth_gain, cell=cell, article=article)
                            media_key = 'jail_success'
                        else:
                            phrase = get_random_phrase(JAIL_FAIL_PHRASES, name=name, username=username, cell=cell, article=article)
                            media_key = 'jail_fail'

                        await conn.execute(
                            "UPDATE jail_sentences SET status='completed', notified=TRUE, result=$1, auth_gained=$2 WHERE id=$3",
                            phrase, auth_gain, sentence_id
                        )

                        exp = await get_setting_int("exp_per_jail")
                        level_up_msg = await add_exp(user_id, exp, conn=conn)

                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ—Å–ª–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
                    if chat_id:
                        try:
                            await send_with_media(chat_id, phrase, media_key=media_key)
                        except Exception as e:
                            logging.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ç—é—Ä—å–º—ã –≤ —á–∞—Ç {chat_id}: {e}")
                            await safe_send_message(user_id, phrase)
                    else:
                        await safe_send_message(user_id, phrase)

                    if level_up_msg:
                        await safe_send_message(user_id, level_up_msg)

        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –≤ process_jail_sentences: {e}")
            await asyncio.sleep(60)

# ==================== –§–û–ù–û–í–ê–Ø –ó–ê–î–ê–ß–ê: –ó–ê–í–ï–†–®–ï–ù–ò–ï –†–û–ó–´–ì–†–´–®–ï–ô ====================
async def process_giveaways():
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∏ –∏ –∑–∞–≤–µ—Ä—à–∞–µ—Ç –∏—Ö –ø–æ —É—Å–ª–æ–≤–∏—é."""
    while True:
        try:
            await asyncio.sleep(60)  # –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑ –≤ –º–∏–Ω—É—Ç—É
            now = datetime.now()
            async with db_pool.acquire() as conn:
                # –†–æ–∑—ã–≥—Ä—ã—à–∏, –∑–∞–≤–µ—Ä—à–∞—é—â–∏–µ—Å—è –ø–æ –≤—Ä–µ–º–µ–Ω–∏
                time_giveaways = await conn.fetch("""
                    SELECT * FROM giveaways
                    WHERE status='active' AND condition_type='time' AND end_date <= $1
                """, now)

                for gw in time_giveaways:
                    await complete_giveaway_by_id(conn, gw['id'])

                # –†–æ–∑—ã–≥—Ä—ã—à–∏, –∑–∞–≤–µ—Ä—à–∞—é—â–∏–µ—Å—è –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
                participants_giveaways = await conn.fetch("""
                    SELECT g.*, COUNT(p.user_id) as participants_count
                    FROM giveaways g
                    LEFT JOIN participants p ON g.id = p.giveaway_id
                    WHERE g.status='active' AND g.condition_type='participants'
                    GROUP BY g.id
                    HAVING COUNT(p.user_id) >= g.min_participants
                """)

                for gw in participants_giveaways:
                    await complete_giveaway_by_id(conn, gw['id'])

        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –≤ process_giveaways: {e}")
            await asyncio.sleep(60)

async def complete_giveaway_by_id(conn, giveaway_id: int):
    """–í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ä–æ–∑—ã–≥—Ä—ã—à–∞ (–≤–Ω—É—Ç—Ä–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏)."""
    try:
        async with conn.transaction():
            giveaway = await conn.fetchrow("SELECT * FROM giveaways WHERE id=$1 AND status='active'", giveaway_id)
            if not giveaway:
                return
            participants = await conn.fetch("SELECT user_id FROM participants WHERE giveaway_id=$1", giveaway_id)
            if not participants:
                # –ï—Å–ª–∏ –Ω–µ—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤, –ø—Ä–æ—Å—Ç–æ –ø–æ–º–µ—á–∞–µ–º –∫–∞–∫ –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–π –±–µ–∑ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π
                await conn.execute("UPDATE giveaways SET status='completed', winners_list='[]' WHERE id=$1", giveaway_id)
                return
            winners_count = giveaway['winners_count']
            winners = random.sample([p['user_id'] for p in participants], min(winners_count, len(participants)))
            winners_list = json.dumps(winners)
            await conn.execute(
                "UPDATE giveaways SET status='completed', winners_list=$1 WHERE id=$2",
                winners_list, giveaway_id
            )
        # –£–≤–µ–¥–æ–º–ª—è–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –ø–æ—Å–ª–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        for uid in [p['user_id'] for p in participants]:
            if uid in winners:
                await safe_send_message(uid, f"üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ –≤ —Ä–æ–∑—ã–≥—Ä—ã—à–µ #{giveaway_id}! –ü—Ä–∏–∑: {giveaway['prize']}")
            else:
                await safe_send_message(uid, f"üò¢ –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤—ã –Ω–µ –≤—ã–∏–≥—Ä–∞–ª–∏ –≤ —Ä–æ–∑—ã–≥—Ä—ã—à–µ #{giveaway_id}.")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –≤ complete_giveaway_by_id –¥–ª—è giveaway {giveaway_id}: {e}")

# ==================== –§–û–ù–û–í–ê–Ø –ó–ê–î–ê–ß–ê: –ü–ï–†–ò–û–î–ò–ß–ï–°–ö–ê–Ø –û–ß–ò–°–¢–ö–ê ====================
async def periodic_cleanup():
    """–ó–∞–ø—É—Å–∫–∞–µ—Ç –æ—á–∏—Å—Ç–∫—É —Å—Ç–∞—Ä—ã—Ö –∑–∞–ø–∏—Å–µ–π —Ä–∞–∑ –≤ —Å—É—Ç–∫–∏."""
    while True:
        try:
            await asyncio.sleep(86400)  # 24 —á–∞—Å–∞
            await perform_cleanup(manual=False)
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –≤ periodic_cleanup: {e}")
            await asyncio.sleep(3600)

# ==================== –§–û–ù–û–í–ê–Ø –ó–ê–î–ê–ß–ê: –°–ü–ò–°–ê–ù–ò–ï –ü–†–û–°–†–û–ß–ï–ù–ù–´–• –ë–ò–ó–ù–ï–°–û–í ====================
async def business_expiration_checker():
    """–†–∞–∑ –≤ —á–∞—Å –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –∏—Å—Ç–µ–∫—à–∏–µ –±–∏–∑–Ω–µ—Å—ã –∏ —Å–ø–∏—Å—ã–≤–∞–µ—Ç –∏—Ö."""
    while True:
        try:
            await asyncio.sleep(3600)  # –∫–∞–∂–¥—ã–π —á–∞—Å
            if not await acquire_lock("business_expiration", timeout=60):
                continue  # —É–∂–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è
            try:
                async with db_pool.acquire() as conn:
                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –¥–ª—è —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç–∏
                    async with conn.transaction():
                        expired = await conn.fetch("""
                            SELECT ub.id, ub.user_id, bt.name, bt.emoji
                            FROM user_businesses ub
                            JOIN business_types bt ON ub.business_type_id = bt.id
                            WHERE ub.expires_at IS NOT NULL AND ub.expires_at <= NOW()
                        """)
                        for biz in expired:
                            await conn.execute("DELETE FROM user_businesses WHERE id = $1", biz['id'])
                            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ –∫–æ–º–º–∏—Ç–∞ (—Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å–ø–∏—Å–æ–∫)
                            asyncio.create_task(
                                safe_send_message(
                                    biz['user_id'],
                                    f"‚ö†Ô∏è –í–∞—à –±–∏–∑–Ω–µ—Å {biz['emoji']} {biz['name']} –∏—Å—Ç—ë–∫ –∏ –±—ã–ª —Å–ø–∏—Å–∞–Ω."
                                )
                            )
            finally:
                await release_lock("business_expiration")
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –≤ business_expiration_checker: {e}")
            await asyncio.sleep(60)

# ==================== –ó–ê–ü–£–°–ö –ë–û–¢–ê ====================
async def on_startup():
    """–î–µ–π—Å—Ç–≤–∏—è –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞."""
    # –£–¥–∞–ª—è–µ–º –≤–µ–±—Ö—É–∫ –∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–º–∞–Ω–¥—ã
    await bot.delete_webhook(drop_pending_updates=True)
    await bot.set_my_commands([
        types.BotCommand(command="start", description="üöÄ –ó–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞"),
        types.BotCommand(command="help", description="üìö –ü–æ–º–æ—â—å –∏ –∫–æ–º–∞–Ω–¥—ã"),
        types.BotCommand(command="cancel", description="‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ"),
        types.BotCommand(command="activate_chat", description="üîî –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å —á–∞—Ç"),
        types.BotCommand(command="mlb_smuggle", description="üì¶ –û—Ç–ø—Ä–∞–≤–∏—Ç—å—Å—è –≤ –∫–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥—É"),
        types.BotCommand(command="mlb_jail", description="üèõ –û—Ç–ø—Ä–∞–≤–∏—Ç—å—Å—è –≤ —Ç—é—Ä—å–º—É"),
        types.BotCommand(command="mlb_top", description="üèÜ –¢–æ–ø —á–∞—Ç–∞"),
        types.BotCommand(command="mlb_profile", description="üë§ –ü—Ä–æ—Ñ–∏–ª—å –≤ —á–∞—Ç–µ"),
        types.BotCommand(command="mlb_heist", description="üí∞ –°—Ç–∞—Ç—É—Å –Ω–∞–ª—ë—Ç–∞"),
        types.BotCommand(command="myheist", description="üìä –ú–æ–π —Ç–µ–∫—É—â–∏–π –Ω–∞–ª—ë—Ç"),
    ])
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–∏–Ω–≥ –ë–î
    asyncio.create_task(keep_db_alive())
    
    # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–µ–∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–µ –Ω–∞–ª—ë—Ç—ã
    await recover_heists()
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º —Ñ–æ–Ω–æ–≤—ã–µ –∑–∞–¥–∞—á–∏
    asyncio.create_task(heist_spawner())
    asyncio.create_task(process_smuggle_runs())
    asyncio.create_task(process_jail_sentences())
    asyncio.create_task(process_giveaways())
    asyncio.create_task(periodic_cleanup())
    asyncio.create_task(business_expiration_checker())

    logging.info("‚úÖ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")

async def on_shutdown():
    """–î–µ–π—Å—Ç–≤–∏—è –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ –±–æ—Ç–∞."""
    if db_pool:
        await db_pool.close()
    if redis_client:
        await redis_client.close()
    logging.info("üõë –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∑–∞–∫—Ä—ã—Ç—ã.")

# ==================== –¢–û–ß–ö–ê –í–•–û–î–ê ====================
async def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞"""
    try:
        # –°–æ–∑–¥–∞–µ–º –ø—É–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π —Å –ë–î
        logging.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î...")
        success = await create_db_pool()
        if not success:
            logging.critical("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ –ë–î. –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã.")
            return
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç–∞–±–ª–∏—Ü—ã
        logging.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç–∞–±–ª–∏—Ü –ë–î...")
        await init_db()
        
        # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏–∏ —Å—Ç–∞—Ä—Ç–∞ –∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
        dp.startup.register(on_startup)
        dp.shutdown.register(on_shutdown)
        
        # –ó–∞–ø—É—Å–∫ –ø–æ–ª–ª–∏–Ω–≥–∞
        logging.info("–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞...")
        await dp.start_polling(bot, skip_updates=True)
        
    except asyncpg.exceptions.InvalidCatalogNameError:
        # –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        logging.critical(f"‚ùå –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ DATABASE_URL: {DATABASE_URL}")
        logging.critical("–°–æ–∑–¥–∞–π—Ç–µ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö –≤—Ä—É—á–Ω—É—é –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é.")
    except asyncpg.exceptions.InvalidAuthorizationSpecificationError:
        logging.critical("‚ùå –û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –≤ –ë–î. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏–Ω –∏ –ø–∞—Ä–æ–ª—å.")
    except Exception as e:
        logging.critical(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ: {e}", exc_info=True)

if __name__ == '__main__':
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø—Ä–æ–±–ª–µ–º —Å –ë–î
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
        handlers=[
            logging.StreamHandler(),
            logging.FileHandler('bot.log', encoding='utf-8')
        ]
    )
    
    # –ó–∞–ø—É—Å–∫
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logging.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
    except Exception as e:
        logging.critical(f"–ù–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: {e}", exc_info=True)

# ==================== –ö–û–ù–ï–¶ –ß–ê–°–¢–ò 6 ====================
