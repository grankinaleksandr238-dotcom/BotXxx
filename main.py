# ==================== –ß–ê–°–¢–¨ 1: –ò–ú–ü–û–†–¢–´, –ù–ê–°–¢–†–û–ô–ö–ò, –ë–î, –ö–ï–®–ò–†–û–í–ê–ù–ò–ï, –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ====================
# –ü–æ–ª–Ω–æ—Å—Ç—å—é –ø–µ—Ä–µ–ø–∏—Å–∞–Ω–æ –¥–ª—è aiogram 3.x. –í—Å–µ –æ—à–∏–±–∫–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã.

import asyncio
import logging
import random
import os
import time
import string
import csv
import io
import json
import hashlib
from datetime import datetime, timedelta, date
from typing import Dict, List, Optional, Tuple, Any, Union
from collections import defaultdict
from functools import lru_cache, wraps

import asyncpg
from aiogram import Bot, Dispatcher, types, BaseMiddleware, F
from aiogram.filters import Command, CommandStart
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import (
    ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup,
    InlineKeyboardButton, CallbackQuery, Message, InputFile,
    ChatPermissions, ContentType
)
from aiogram.exceptions import (
    TelegramBadRequest, TelegramForbiddenError, TelegramRetryAfter,
    TelegramAPIError
)
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder
from aiogram.types.error_event import ErrorEvent

# ==================== –ù–ê–°–¢–†–û–ô–ö–ò ====================
BOT_TOKEN = os.getenv("BOT_TOKEN")
if not BOT_TOKEN:
    raise ValueError("BOT_TOKEN –Ω–µ –∑–∞–¥–∞–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")

SUPER_ADMINS_STR = os.getenv("SUPER_ADMINS", "")
SUPER_ADMINS = [int(x.strip()) for x in SUPER_ADMINS_STR.split(",") if x.strip()]

DATABASE_URL = os.getenv("DATABASE_URL")
if not DATABASE_URL:
    raise ValueError("DATABASE_URL –Ω–µ –∑–∞–¥–∞–Ω. –°–æ–∑–¥–∞–π—Ç–µ PostgreSQL –±–∞–∑—É.")

if "sslmode" not in DATABASE_URL:
    DATABASE_URL += "?sslmode=require"

# –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: Redis –¥–ª—è –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
REDIS_URL = os.getenv("REDIS_URL")
if REDIS_URL:
    import aioredis
    redis_client = aioredis.from_url(REDIS_URL, decode_responses=True)
else:
    redis_client = None

# ==================== –°–û–ó–î–ê–ù–ò–ï –ë–û–¢–ê ====================
bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
storage = MemoryStorage()
dp = Dispatcher(storage=storage)

# ==================== –ö–ï–®–ò–†–û–í–ê–ù–ò–ï –° –ü–†–û–í–ï–†–ö–û–ô –ù–ê –ù–ê–õ–ò–ß–ò–ï REDIS ====================
async def redis_get(key: str):
    """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ Redis."""
    if redis_client is None:
        return None
    try:
        return await redis_client.get(key)
    except Exception as e:
        logging.error(f"Redis get error for key {key}: {e}")
        return None

async def redis_set(key: str, value: str, ttl: int = 60):
    """–ë–µ–∑–æ–ø–∞—Å–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–Ω–∞—á–µ–Ω–∏—è –≤ Redis."""
    if redis_client is None:
        return
    try:
        await redis_client.setex(key, ttl, value)
    except Exception as e:
        logging.error(f"Redis set error for key {key}: {e}")

async def redis_delete(key: str):
    """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ –∫–ª—é—á–∞ –∏–∑ Redis."""
    if redis_client is None:
        return
    try:
        await redis_client.delete(key)
    except Exception as e:
        logging.error(f"Redis delete error for key {key}: {e}")

async def acquire_lock(lock_name: str, timeout: int = 10) -> bool:
    """–ü—ã—Ç–∞–µ—Ç—Å—è –∑–∞—Ö–≤–∞—Ç–∏—Ç—å –±–ª–æ–∫–∏—Ä–æ–≤–∫—É –≤ Redis. –ï—Å–ª–∏ Redis –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç True (–æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏)."""
    if redis_client is None:
        return True
    try:
        lock_key = f"lock:{lock_name}"
        result = await redis_client.setnx(lock_key, "1")
        if result:
            await redis_client.expire(lock_key, timeout)
            return True
    except Exception as e:
        logging.error(f"Redis acquire_lock error for {lock_name}: {e}")
    return False

async def release_lock(lock_name: str):
    """–û—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∫—É –≤ Redis."""
    if redis_client is None:
        return
    try:
        await redis_client.delete(f"lock:{lock_name}")
    except Exception as e:
        logging.error(f"Redis release_lock error for {lock_name}: {e}")

# ==================== –ù–ê–°–¢–†–û–ô–ö–ò –ü–û –£–ú–û–õ–ß–ê–ù–ò–Æ ====================
DEFAULT_SETTINGS = {
    # ----- –ö–†–ê–ñ–ê -----
    "random_attack_cost": "0",
    "targeted_attack_cost": "50",
    "theft_cooldown_minutes": "30",
    "theft_success_chance": "40",
    "theft_defense_chance": "20",
    "theft_defense_penalty": "10",
    "min_theft_amount": "5",
    "max_theft_amount": "15",

    # ----- –ö–ê–ó–ò–ù–û -----
    "casino_win_chance": "40.0",
    "casino_min_bet": "1",
    "casino_max_bet": "1000",
    "min_level_casino": "1",
    "slots_win_probability": "25.0",
    "slots_multiplier_three": "3.0",
    "slots_multiplier_diamond": "5.0",
    "slots_multiplier_seven": "10.0",
    "roulette_number_multiplier": "36.0",
    "roulette_green_multiplier": "18.0",
    "roulette_color_multiplier": "2.0",
    "roulette_win_chance": "47.3",

    # ----- –£–í–ï–î–û–ú–õ–ï–ù–ò–Ø -----
    "chat_notify_big_win": "1",
    "chat_notify_big_purchase": "1",
    "chat_notify_giveaway": "1",

    # ----- –ü–û–î–ì–û–ù -----
    "gift_amount": "30",
    "gift_limit_per_day": "3",
    "gift_global_limit_per_user": "4",
    "gift_cooldown": "60",

    # ----- –†–ï–§–ï–†–ê–õ–´ -----
    "referral_bonus": "50",
    "referral_reputation": "2",
    "referral_required_thefts": "15",

    # ----- –û–ü–´–¢ -----
    "exp_per_dice_win": "3",
    "exp_per_dice_lose": "1",
    "exp_per_guess_win": "4",
    "exp_per_guess_lose": "1",
    "exp_per_slots_win": "6",
    "exp_per_slots_lose": "2",
    "exp_per_roulette_win": "5",
    "exp_per_roulette_lose": "1",
    "exp_per_theft_success": "8",
    "exp_per_theft_fail": "2",
    "exp_per_theft_defense": "5",
    "exp_per_heist_participation": "10",
    "exp_per_betray_success": "5",
    "exp_per_betray_fail": "1",
    "exp_per_smuggle": "10",
    "exp_per_jail": "5",

    # ----- –£–†–û–í–ù–ò -----
    "level_multiplier": "100",
    "level_reward_coins": "30",
    "level_reward_reputation": "3",
    "level_reward_coins_increment": "5",
    "level_reward_reputation_increment": "1",

    # ----- –†–ï–ü–£–¢–ê–¶–ò–Ø -----
    "reputation_theft_bonus": "0.5",
    "reputation_defense_bonus": "0.5",
    "reputation_max_bonus_percent": "30",

    # ----- –°–¢–ê–¢–´ –ó–ê –£–†–û–í–ï–ù–¨ -----
    "stat_strength_per_level": "1",
    "stat_agility_per_level": "1",
    "stat_defense_per_level": "1",

    # ----- –ö–ò–î–ê–õ–û–í–û (PVP) -----
    "betray_base_chance": "20",
    "betray_steal_percent": "30",
    "betray_fail_penalty_percent": "10",
    "betray_cooldown_minutes": "60",
    "betray_max_chance": "50",

    # ----- –ù–ê–õ–Å–¢–´ -----
    "heist_min_interval_minutes": "70",
    "heist_max_interval_minutes": "70",
    "heist_join_minutes": "10",
    "heist_split_minutes": "5",
    "heist_min_pot": "50",
    "heist_max_pot": "200",
    "heist_btc_chance": "10",
    "heist_min_btc": "0.001",
    "heist_max_btc": "0.01",
    "heist_cooldown_minutes": "30",
    "heist_participant_cooldown_hours": "1",
    "heist_share_min": "5",
    "heist_share_max": "10",

    # ----- –ë–ò–ó–ù–ï–°–´ -----
    "business_upgrade_cost_per_level": "10",
    "business_collect_interval_minutes": "30",
    "business_max_storage_hours": "24",
    "business_max_businesses": "6",
    "business_lifetime_hours_default": "720",

    # ----- –ë–ò–¢–ö–û–ò–ù–´ -----
    "bitcoin_per_theft": "1",
    "bitcoin_per_heist_participation": "0",
    "bitcoin_per_betray_success": "0",

    # ----- –ë–ò–¢–ö–û–ò–ù-–ë–ò–†–ñ–ê -----
    "exchange_min_price": "1",
    "exchange_max_price": "1000",
    "exchange_commission_percent": "0",
    "exchange_commission_side": "seller",
    "exchange_commission_destination": "burn",
    "exchange_min_amount_btc": "0.001",

    # ----- –ö–û–ù–¢–†–ê–ë–ê–ù–î–ê -----
    "smuggle_base_amount": "0.001",
    "smuggle_cooldown_minutes": "60",
    "smuggle_fail_penalty_minutes": "30",
    "smuggle_success_chance": "55",
    "smuggle_caught_chance": "30",
    "smuggle_lost_chance": "15",
    "smuggle_min_duration": "30",
    "smuggle_max_duration": "120",

    # ----- –¢–Æ–†–¨–ú–ê -----
    "jail_min_duration": "30",
    "jail_max_duration": "90",
    "jail_success_chance": "30",
    "jail_auth_min": "1",
    "jail_auth_max": "3",
    "jail_cooldown_hours": "1",

    # ----- –û–ß–ò–°–¢–ö–ê –õ–û–ì–û–í -----
    "cleanup_days_heists": "30",
    "cleanup_days_purchases": "30",
    "cleanup_days_giveaways": "30",
    "cleanup_days_user_tasks": "30",
    "cleanup_days_smuggle": "30",
    "cleanup_days_bitcoin_orders": "30",

    # ----- –ê–í–¢–û–£–î–ê–õ–ï–ù–ò–ï -----
    "auto_delete_commands_seconds": "30",

    # ----- –°–¢–ê–†–¢–û–í–´–ô –ë–û–ù–£–° -----
    "new_user_bonus": "50",

    # ----- –ì–õ–û–ë–ê–õ–¨–ù–´–ô –ê–ù–¢–ò-–°–ü–ê–ú –ö–£–õ–î–ê–£–ù -----
    "global_cooldown_seconds": "3",
    "global_chat_cooldown_hours": "1",

    # ----- –õ–ò–ú–ò–¢ –ù–ê –í–í–û–î –ß–ò–°–ï–õ -----
    "max_input_number": "1000000",

    # ----- –ü–†–û–ö–ê–ß–ö–ê –ù–ê–í–´–ö–û–í -----
    "skill_share_cost_per_level": "50",
    "skill_luck_cost_per_level": "40",
    "skill_betray_cost_per_level": "60",
    "skill_share_bonus_per_level": "2",
    "skill_luck_bonus_per_level": "3",
    "skill_betray_bonus_per_level": "4",
    "skill_max_level": "10",

    # ----- –ó–ê–î–ê–ù–ò–Ø -----
    "task_subscribe_check_interval": "3600",

    # ----- –ü–†–û–ú–û–ö–û–î–´ -----
    "promocode_max_uses_default": "1",
}

# ==================== –¢–ò–ü–´ –ë–ò–ó–ù–ï–°–û–í ====================
BUSINESS_TYPES = [
    {
        "id": 1,
        "name": "–õ–∞—Ä—ë–∫",
        "emoji": "ü•§",
        "base_price_btc": 50,
        "base_income_per_hour": 0.5,
        "description": "–ú–∞–ª–µ–Ω—å–∫–∏–π –ª–∞—Ä—ë–∫ —É –º–µ—Ç—Ä–æ. –¢–æ—Ä–≥—É–µ—Ç –≥–∞–∑–∏—Ä–æ–≤–∫–æ–π –∏ —á–∏–ø—Å–∞–º–∏.",
        "max_level": 3,
        "image_key": "business_kiosk",
        "lifetime_hours": 720
    },
    {
        "id": 2,
        "name": "–ö–∏–æ—Å–∫",
        "emoji": "üè™",
        "base_price_btc": 120,
        "base_income_per_hour": 1.5,
        "description": "–ü—Ä–æ–¥–∞—ë—Ç –ø—Ä–µ—Å—Å—É, —Å–∏–≥–∞—Ä–µ—Ç—ã –∏ –º–µ–ª–æ—á—ë–≤–∫—É.",
        "max_level": 3,
        "image_key": "business_shop",
        "lifetime_hours": 720
    },
    {
        "id": 3,
        "name": "–ú–∞–≥–∞–∑–∏–Ω",
        "emoji": "üè¨",
        "base_price_btc": 250,
        "base_income_per_hour": 3.0,
        "description": "–ü—Ä–æ–¥—É–∫—Ç–æ–≤—ã–π –º–∞–≥–∞–∑–∏–Ω —Å–æ —Å—Ç–∞–±–∏–ª—å–Ω—ã–º –¥–æ—Ö–æ–¥–æ–º.",
        "max_level": 3,
        "image_key": "business_supermarket",
        "lifetime_hours": 720
    },
    {
        "id": 4,
        "name": "–†–µ—Å—Ç–æ—Ä–∞–Ω",
        "emoji": "üçΩÔ∏è",
        "base_price_btc": 500,
        "base_income_per_hour": 5.0,
        "description": "–≠–ª–∏—Ç–Ω—ã–π —Ä–µ—Å—Ç–æ—Ä–∞–Ω —Å –±–æ–≥–∞—Ç—ã–º–∏ –ø–æ—Å–µ—Ç–∏—Ç–µ–ª—è–º–∏.",
        "max_level": 3,
        "image_key": "business_restaurant",
        "lifetime_hours": 720
    },
    {
        "id": 5,
        "name": "–û—Ç–µ–ª—å",
        "emoji": "üè®",
        "base_price_btc": 800,
        "base_income_per_hour": 7.5,
        "description": "–®–∏–∫–∞—Ä–Ω—ã–π –æ—Ç–µ–ª—å –¥–ª—è —Å–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω—ã—Ö –≥–æ—Å—Ç–µ–π.",
        "max_level": 3,
        "image_key": "business_hotel",
        "lifetime_hours": 720
    },
    {
        "id": 6,
        "name": "–ù–µ—Ñ—Ç—è–Ω–∞—è –≤—ã—à–∫–∞",
        "emoji": "üõ¢Ô∏è",
        "base_price_btc": 1200,
        "base_income_per_hour": 10.0,
        "description": "–°–æ–±—Å—Ç–≤–µ–Ω–Ω–∞—è –Ω–µ—Ñ—Ç—è–Ω–∞—è –≤—ã—à–∫–∞. –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –ø—Ä–æ—Ñ–∏—Ç!",
        "max_level": 3,
        "image_key": "business_oil",
        "lifetime_hours": 720
    }
]

# ==================== –ü–†–ï–î–û–ü–†–ï–î–ï–õ–Å–ù–ù–´–ï –ö–õ–Æ–ß–ò –ú–ï–î–ò–ê ====================
MEDIA_KEYS = [
    "welcome", "profile", "casino", "shop", "theft", "referral", "tasks", "giveaway",
    "exchange", "admin", "admin_users", "admin_shop", "admin_giveaway", "admin_channels",
    "admin_promo", "admin_business", "admin_exchange", "admin_media", "admin_chats",
    "admin_settings", "admin_tasks",
    "heist_incassator", "heist_bank", "heist_crypto", "heist_narko", "heist_weapon",
    "smuggle_start", "smuggle_success", "smuggle_fail",
    "jail_start", "jail_success", "jail_fail",
    "business_kiosk", "business_shop", "business_supermarket", "business_restaurant", "business_hotel", "business_oil"
]

# ==================== –ö–û–ù–°–¢–ê–ù–¢–´ ====================
ITEMS_PER_PAGE = 10
BIG_WIN_THRESHOLD = 100
BIG_PURCHASE_THRESHOLD = 100

PERMISSIONS_LIST = [
    "manage_users",
    "manage_shop",
    "manage_giveaways",
    "manage_channels",
    "manage_chats",
    "manage_promocodes",
    "manage_media",
    "manage_businesses",
    "manage_exchange",
    "view_stats",
    "broadcast",
    "edit_settings",
    "cleanup",
    "manage_admins",
]

# ==================== –¢–ò–ü–´ –°–û–ë–´–¢–ò–ô (–ù–ê–õ–Å–¢–û–í) ====================
HEIST_TYPES = {
    "incassator": {
        "name": "üöê –ò–Ω–∫–∞—Å—Å–∞—Ç–æ—Ä",
        "keyword": "–§–ê–†–¢",
        "phrases_start": [
            "üü° –ò–Ω–∫–∞—Å—Å–∞—Ç–æ—Ä—Å–∫–∞—è –º–∞—à–∏–Ω–∞, –ø–æ–ª–Ω–∞—è –¥–µ–Ω–µ–≥, –ø—Ä–æ–µ–∑–∂–∞–µ—Ç —á–µ—Ä–µ–∑ –≥–æ—Ä–æ–¥! –ö—Ç–æ —Å –Ω–∞–º–∏? –ü–∏—à–∏ **–§–ê–†–¢** –≤ —Ç–µ—á–µ–Ω–∏–µ {minutes} –º–∏–Ω—É—Ç!",
            "üí∞ –ë—Ä–æ–Ω–µ–≤–∏–∫ —Å –¥–µ–Ω—å–≥–∞–º–∏ –Ω–∞–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –∫ —Ü–µ–Ω—Ç—Ä—É! –ì–æ–≤–æ—Ä—è—Ç, —Ç–∞–º —Ü–µ–ª–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ! –ü–∏—à–∏ **–§–ê–†–¢**",
            "üöê –°–ª—ã—à–∞–ª–∏ –Ω–æ–≤–æ—Å—Ç—å? –ò–Ω–∫–∞—Å—Å–∞—Ç–æ—Ä—ã –≤–µ–∑—É—Ç –∑–∞—Ä–ø–ª–∞—Ç—É –¥–ª—è –≤—Å–µ–≥–æ –≥–æ—Ä–æ–¥–∞! –ü–∏—à–∏ **–§–ê–†–¢** –∏ –ø–æ–≥–Ω–∞–ª–∏!",
            "üí∏ –ù–∞—à —á–µ–ª–æ–≤–µ–∫ —Å–ª–∏–ª –º–∞—Ä—à—Ä—É—Ç –∏–Ω–∫–∞—Å—Å–∞—Ç–æ—Ä–æ–≤! –¢–∞–º –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –º–Ω–æ–≥–æ! –ü–∏—à–∏ **–§–ê–†–¢**",
            "üü° –ë—Ä–æ–Ω—è —Å–ª–∞–±–∞—è, –æ—Ö—Ä–∞–Ω–∞ —Å–ª–µ–ø–∞—è! –õ–µ–≥–∫–∏–µ –¥–µ–Ω—å–≥–∏! –ü–∏—à–∏ **–§–ê–†–¢**",
            "üî´ –ò–Ω–∫–∞—Å—Å–∞—Ç–æ—Ä—ã –æ—Å—Ç–∞–Ω–æ–≤–∏–ª–∏—Å—å —É –ª–∞—Ä—å–∫–∞ –∑–∞ –ø–∏—Ä–æ–∂–∫–∞–º–∏. –î–æ–±—ã—á–∞ –±—É–¥–µ—Ç –ª—ë–≥–∫–æ–π! –ü–∏—à–∏ **–§–ê–†–¢**",
            "üöî –ü–æ–ª–∏—Ü–∏—è –∑–∞–Ω—è—Ç–∞ –æ–±–ª–∞–≤–æ–π, —Å–µ–π—á–∞—Å —Å–∞–º–æ–µ –≤—Ä–µ–º—è! –ü–∏—à–∏ **–§–ê–†–¢**"
        ],
        "phrases_join": [
            "‚úÖ {name} –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ –Ω–∞–ª—ë—Ç—É!",
            "üî´ {name} –≤ –¥–µ–ª–µ!",
            "üí™ {name} –∑–∞—Ä—è–¥–∏–ª —Å—Ç–≤–æ–ª –∏ –≥–æ—Ç–æ–≤ —Ä–≤–∞—Ç—å!",
            "üòé {name} –≤—Ç–∏—Ä–∞–µ—Ç—Å—è –≤ –¥–æ–≤–µ—Ä–∏–µ –∫ –æ—Ö—Ä–∞–Ω–µ..."
        ],
        "phrases_split": [
            "üî™ –î–µ–ª–µ–∂ –¥–æ–±—ã—á–∏! –£ —Ç–µ–±—è {minutes} –º–∏–Ω—É—Ç, —á—Ç–æ–±—ã –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è –∫–∏–Ω—É—Ç—å –ø–æ–¥–µ–ª—å–Ω–∏–∫–æ–≤! –ñ–º–∏ –∫–Ω–æ–ø–∫—É –≤ –õ–°!",
            "üí∞ –î–µ–Ω—å–≥–∏ –Ω–∞ —Å—Ç–æ–ª–µ, –∫–∞–∂–¥—ã–π —Ö–æ—á–µ—Ç —É—Ä–≤–∞—Ç—å –∫—É—Å–æ–∫ –ø–æ–∂–∏—Ä–Ω–µ–µ! –í—ã–±–∏—Ä–∞–π –≤ –ª–∏—á–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏—è—Ö!",
            "‚öîÔ∏è –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Ä–∞—Å–ø–∏–ª! –ü—Ä–æ–≤–µ—Ä—å –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –±–æ—Ç–æ–º!"
        ],
        "phrases_betray_attempt": [
            "üî™ {name} —Ä–µ—à–∞–µ—Ç –∫–∏–Ω—É—Ç—å –∫–æ–≥–æ-—Ç–æ –∏–∑ —Å–≤–æ–∏—Ö... –ë–∞—Ä–∞–±–∞–Ω–Ω–∞—è –¥—Ä–æ–±—å...",
            "üòà {name} –∑–∞–¥—É–º–∞–ª –Ω–µ–¥–æ–±—Ä–æ–µ, —Ö–æ—á–µ—Ç –æ–±—á–∏—Å—Ç–∏—Ç—å –∫–∞—Ä–º–∞–Ω—ã –ø–æ–¥–µ–ª—å–Ω–∏–∫–æ–≤!",
            "üÉè {name} –¥–æ—Å—Ç–∞—ë—Ç –∫—Ä–∞–ø–ª—ë–Ω—ã–µ –∫–∞—Ä—Ç—ã –∏ –∏—â–µ—Ç –∂–µ—Ä—Ç–≤—É..."
        ],
        "phrases_betray_success": [
            "üî™ {name} (@{username}) –∫–∏–Ω—É–ª {target} –∏ —É—Ä–≤–∞–ª +{amount}$! –•–∞-—Ö–∞, –±–µ–¥–Ω—è–≥–∞ –¥–∞–∂–µ –Ω–µ –ø–æ–Ω—è–ª, —á—Ç–æ –ø—Ä–æ–∏–∑–æ—à–ª–æ!",
            "üÉè {name} (@{username}) –ø–æ–¥—Å—Ç–∞–≤–∏–ª {target} –ø–æ–¥ –º–µ–Ω—Ç–æ–≤ –∏ –∑–∞–±—Ä–∞–ª –µ–≥–æ –¥–æ–ª—é. +{amount}$! {target} —Ç–µ–ø–µ—Ä—å –≤ –±–µ–≥–∞—Ö!",
            "üòà {name} (@{username}) —É–±–µ–¥–∏–ª {target}, —á—Ç–æ –æ–Ω–∏ —Å–æ—é–∑–Ω–∏–∫–∏, –∏ –æ–±—á–∏—Å—Ç–∏–ª –µ–≥–æ –∫–∞—Ä–º–∞–Ω—ã. +{amount}$! –î–æ–≤–µ—Ä–∏–µ ‚Äî –æ–ø–∞—Å–Ω–∞—è —à—Ç—É–∫–∞!",
            "üí∏ {name} (@{username}) —Å–∫–∞–∑–∞–ª {target}, —á—Ç–æ –¥–µ–Ω—å–≥–∏ –Ω—É–∂–Ω–æ —Å–ø—Ä—è—Ç–∞—Ç—å, –∏‚Ä¶ —Å–ø—Ä—è—Ç–∞–ª –∏—Ö –≤ —Å–≤–æ–π –∫–∞—Ä–º–∞–Ω. +{amount}$!",
            "ü§° {name} (@{username}) –ø–µ—Ä–µ–æ–¥–µ–ª—Å—è –±–∞–±—É—à–∫–æ–π –∏ –≤—ã–ø—Ä–æ—Å–∏–ª —É {target} –µ–≥–æ –¥–æ–ª—é ¬´–Ω–∞ –º–æ–ª–æ—á–∫–æ¬ª. +{amount}$!",
            "üé≠ {name} (@{username}) —Ä–∞–∑—ã–≥—Ä–∞–ª —Ü–µ–ª—ã–π —Å–ø–µ–∫—Ç–∞–∫–ª—å, –∏ {target} —Å–∞–º –æ—Ç–¥–∞–ª –µ–º—É –¥–µ–Ω—å–≥–∏. +{amount}$! –û—Å–∫–∞—Ä –∑–∞ –ª—É—á—à—É—é –º—É–∂—Å–∫—É—é —Ä–æ–ª—å!"
        ],
        "phrases_betray_fail": [
            "üòÖ {name} (@{username}) –ø–æ–ø—ã—Ç–∞–ª—Å—è –∫–∏–Ω—É—Ç—å {target}, –Ω–æ –∑–∞–ø—É—Ç–∞–ª—Å—è –≤ —Å–≤–æ–∏—Ö –∂–µ —à—Ç–∞–Ω–∞—Ö –∏ –ø–æ—Ç–µ—Ä—è–ª {amount}$",
            "ü§° {name} (@{username}) —Ö–æ—Ç–µ–ª –æ–±–º–∞–Ω—É—Ç—å {target}, –Ω–æ —Ç–æ—Ç –æ–∫–∞–∑–∞–ª—Å—è —Ö–∏—Ç—Ä–µ–µ. –®—Ç—Ä–∞—Ñ {amount}$",
            "üíî {name} (@{username}) –Ω–µ—É–¥–∞—á–Ω–æ –ø–æ–¥—Å—Ç–∞–≤–∏–ª—Å—è –∏ —Ç–µ–ø–µ—Ä—å –¥–æ–ª–∂–µ–Ω {target} {amount}$",
            "üòÇ {name} (@{username}) —Å–ø–æ—Ç–∫–Ω—É–ª—Å—è –æ –ø–æ—Ä–æ–≥ –∏ –≤—Å–µ –¥–µ–Ω—å–≥–∏ –≤—ã—Å—ã–ø–∞–ª–∏—Å—å –Ω–∞ –ø–æ–ª. {target} –ø–æ–¥–æ–±—Ä–∞–ª {amount}$!",
            "üêî {name} (@{username}) —Ç–∞–∫ –∏—Å–ø—É–≥–∞–ª—Å—è, —á—Ç–æ –∑–∞–∫—É–¥–∞—Ö—Ç–∞–ª –∏ –ø—Ä–∏–≤–ª—ë–∫ –≤–Ω–∏–º–∞–Ω–∏–µ –ø–æ–ª–∏—Ü–∏–∏. –ü—Ä–∏—à–ª–æ—Å—å –æ—Ç–∫—É–ø–∞—Ç—å—Å—è {amount}$.",
            "üçå {name} (@{username}) –ø–æ—Å–∫–æ–ª—å–∑–Ω—É–ª—Å—è –Ω–∞ –±–∞–Ω–∞–Ω–æ–≤–æ–π –∫–æ–∂—É—Ä–µ –∏ —É—Ä–æ–Ω–∏–ª {amount}$. {target} –ø–æ–¥–æ–±—Ä–∞–ª –∏ –¥–æ–≤–æ–ª—å–Ω–æ —É–ª—ã–±–∞–µ—Ç—Å—è."
        ],
        "phrases_result": [
            "üèÅ –ù–∞–ª—ë—Ç –∑–∞–≤–µ—Ä—à—ë–Ω! –£—á–∞—Å—Ç–Ω–∏–∫–∏ –ø–æ–¥–µ–ª–∏–ª–∏ –¥–æ–±—ã—á—É!\nüèÜ –¢–æ–ø –≤–æ—Ä–æ–≤:\n{top}",
            "üí∞ –í—Å–µ —Ü–µ–ª—ã, –¥–µ–Ω—å–≥–∏ –ø–æ–¥–µ–ª–µ–Ω—ã. –î–æ –Ω–æ–≤—ã—Ö –≤—Å—Ç—Ä–µ—á!\nüëë –õ—É—á—à–∏–µ: {top}",
            "üéâ –£—Ä–∞! –ú—ã —Å–ø—Ä–∞–≤–∏–ª–∏—Å—å! –ö–∞–∂–¥—ã–π –ø–æ–ª—É—á–∏–ª —Å–≤–æ—ë.\nüèÖ –ë–æ–ª—å—à–µ –≤—Å–µ—Ö —É—Ä–≤–∞–ª(–∏): {top}"
        ]
    },
    "bank": {
        "name": "üè¶ –ë–∞–Ω–∫",
        "keyword": "–ì–†–ê–ë–ò–ú",
        "phrases_start": [
            "üî¥ –ë–∞–Ω–∫–æ–≤—Å–∫–∏–π –±—Ä–æ–Ω–µ–≤–∏–∫ –∑–∞—Å—Ç—Ä—è–ª –≤ –ø—Ä–æ–±–∫–µ! –ö—É—á–∞ –¥–µ–Ω–µ–≥ –≤–Ω—É—Ç—Ä–∏! –ü–∏—à–∏ **–ì–†–ê–ë–ò–ú**",
            "üè¶ –û–≥—Ä–∞–±–ª–µ–Ω–∏–µ –≤–µ–∫–∞! –ì–æ–≤–æ—Ä—è—Ç, —Ç–∞–º –º–∏–ª–ª–∏–æ–Ω—ã! –ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Å—è, –ø–∏—à–∏ **–ì–†–ê–ë–ò–ú**",
            "üí∞ –ë–∞–Ω–∫ —Ç–æ–ª—å–∫–æ —á—Ç–æ –ø–æ–ª—É—á–∏–ª –∫—Ä—É–ø–Ω—É—é —Å—É–º–º—É! –£—Å–ø–µ–≤–∞–π! –ü–∏—à–∏ **–ì–†–ê–ë–ò–ú**",
            "üî¥ –°–∏–≥–Ω–∞–ª–∏–∑–∞—Ü–∏—è —Å–ª–æ–º–∞–Ω–∞, –æ—Ö—Ä–∞–Ω–∞ –≤ –æ—Ç–ø—É—Å–∫–µ! –õ–µ–≥–∫–∏–µ –¥–µ–Ω—å–≥–∏! –ü–∏—à–∏ **–ì–†–ê–ë–ò–ú**",
            "üè¶ –î–µ–Ω—å–≥–∏ —Å–∞–º–∏ –ø–ª—ã–≤—É—Ç –≤ —Ä—É–∫–∏! –ü–∏—à–∏ **–ì–†–ê–ë–ò–ú**"
        ],
        "phrases_join": [
            "‚úÖ {name} –≤ –¥–µ–ª–µ!",
            "üî´ {name} –∑–∞—Ä—è–¥–∏–ª –æ–±—Ä–µ–∑ –∏ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è",
            "üïµÔ∏è {name} —É–∂–µ –≤–Ω—É—Ç—Ä–∏!"
        ],
        "phrases_split": [
            "üî™ –î–µ–ª–∏–º –±–∞–±–∫–∏! –£ —Ç–µ–±—è {minutes} –º–∏–Ω—É—Ç –Ω–∞ –∫–∏–¥–∞–ª–æ–≤–æ! –°–º–æ—Ç—Ä–∏ –õ–°!"
        ],
        "phrases_betray_attempt": [
            "üî™ {name} –ø—Ä–∏–º–µ—Ä—è–µ—Ç—Å—è, –∫–æ–≥–æ –±—ã –∫–∏–Ω—É—Ç—å...",
            "üòè {name} —Ö–∏—Ç—Ä–æ —É–ª—ã–±–∞–µ—Ç—Å—è –∏ –∑–∞–Ω–æ—Å–∏—Ç —Ä—É–∫—É –Ω–∞–¥ —á—É–∂–æ–π –¥–æ–ª–µ–π..."
        ],
        "phrases_betray_success": [
            "üî™ {name} (@{username}) –∫–∏–Ω—É–ª {target} –Ω–∞ {amount}$! –¢–æ—Ç –≤ —à–æ–∫–µ!",
            "üíº {name} (@{username}) –ø—Ä–µ–¥–ª–æ–∂–∏–ª {target} ¬´–ø–æ–¥–µ—Ä–∂–∞—Ç—å¬ª –µ–≥–æ –¥–æ–ª—é –∏ –∏—Å—á–µ–∑ —Å {amount}$!",
            "üé© {name} (@{username}) —Ñ–æ–∫—É—Å–Ω–∏–∫! {target} –Ω–µ –∑–∞–º–µ—Ç–∏–ª, –∫–∞–∫ {amount}$ –ø–µ—Ä–µ–∫–æ—á–µ–≤–∞–ª–∏ –≤ —á—É–∂–æ–π –∫–∞—Ä–º–∞–Ω."
        ],
        "phrases_betray_fail": [
            "üòÖ {name} (@{username}) –æ–±–ª–∞–∂–∞–ª—Å—è –∏ –ø–æ—Ç–µ—Ä—è–ª {amount}$",
            "ü§ï {name} (@{username}) –ø–æ–ª—É—á–∏–ª –ø–æ –≥–æ–ª–æ–≤–µ –æ—Ç {target} –∏ –ª–∏—à–∏–ª—Å—è {amount}$",
            "ü´£ {name} (@{username}) —Ç–∞–∫ –¥–æ–ª–≥–æ —Ü–µ–ª–∏–ª—Å—è, —á—Ç–æ {target} —Å–∞–º —É –Ω–µ–≥–æ —É–∫—Ä–∞–ª {amount}$"
        ],
        "phrases_result": [
            "üèÅ –ù–∞–ª—ë—Ç –Ω–∞ –±–∞–Ω–∫ –∑–∞–≤–µ—Ä—à—ë–Ω!\nüèÜ –õ—É—á—à–∏–µ: {top}",
        ]
    },
    "crypto": {
        "name": "‚Çø –ö—Ä–∏–ø—Ç–æ–º–∞—Ç",
        "keyword": "–ö–†–ò–ü–¢–ê",
        "phrases_start": [
            "üü¢ –ù–æ–≤—ã–π –∫—Ä–∏–ø—Ç–æ–º–∞—Ç –≤ –≥–æ—Ä–æ–¥–µ! –ì–æ–≤–æ—Ä—è—Ç, —Ç–∞–º –ø–æ–ª–Ω–æ –±–∏—Ç–∫–æ–∏–Ω–æ–≤! –ö—Ç–æ —É—Å–ø–µ–µ—Ç –≤–≤–µ—Å—Ç–∏ –∫–æ–¥ **–ö–†–ò–ü–¢–ê** - —Å–Ω–∏–º–∞–µ—Ç –±–æ–Ω—É—Å!",
            "‚Çø –ë–∏—Ç–∫–æ–∏–Ω-—Ç–µ—Ä–º–∏–Ω–∞–ª –Ω–µ –∑–∞—â–∏—â—ë–Ω! –ü–∏—à–∏ **–ö–†–ò–ü–¢–ê**, –ø–æ–∫–∞ –µ–≥–æ –Ω–µ –æ–ø—É—Å—Ç–æ—à–∏–ª–∏",
            "üíé –°—Ä–æ—á–Ω–æ! –£—è–∑–≤–∏–º–æ—Å—Ç—å –≤ –∫—Ä–∏–ø—Ç–æ–æ–±–º–µ–Ω–Ω–∏–∫–µ! –ü–∏—à–∏ **–ö–†–ò–ü–¢–ê**",
            "üü¢ –ö—Ä–∏–ø—Ç–æ–ª–æ–º–∫–∞! –£—Å–ø–µ–≤–∞–π –ø–∏—Å–∞—Ç—å **–ö–†–ò–ü–¢–ê**",
            "‚Çø –ë–∏—Ç–∫–æ–∏–Ω—ã —Å–∞–º–∏ –ª–µ–∑—É—Ç –≤ —Ä—É–∫–∏! –ü–∏—à–∏ **–ö–†–ò–ü–¢–ê**"
        ],
        "phrases_join": [
            "‚úÖ {name} –≤ —Ç–µ–º–µ!",
            "üíª {name} –≤–∑–ª–æ–º–∞–ª —Ç–µ—Ä–º–∏–Ω–∞–ª!"
        ],
        "phrases_split": [
            "üî™ –î–µ–ª–∏–º –∫—Ä–∏–ø—Ç—É! –£ —Ç–µ–±—è {minutes} –º–∏–Ω—É—Ç –Ω–∞ –∫–∏–¥–∞–ª–æ–≤–æ! –ñ–¥–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –±–æ—Ç–∞."
        ],
        "phrases_betray_attempt": [
            "üî™ {name} –ø—ã—Ç–∞–µ—Ç—Å—è –ø–µ—Ä–µ–ø–∏—Å–∞—Ç—å —Å–º–∞—Ä—Ç-–∫–æ–Ω—Ç—Ä–∞–∫—Ç –≤ —Å–≤–æ—é –ø–æ–ª—å–∑—É..."
        ],
        "phrases_betray_success": [
            "üî™ {name} (@{username}) –∫–∏–Ω—É–ª {target} –∏ —É—Ä–≤–∞–ª {amount}$ –≤ BTC! –¢–µ–ø–µ—Ä—å —É {target} –æ–¥–Ω–∏ —Å–ª—ë–∑—ã.",
            "üí∏ {name} (@{username}) —É–±–µ–¥–∏–ª {target}, —á—Ç–æ –∫—Ä–∏–ø—Ç–∞ —É–ø–∞–¥–µ—Ç, –∏ —Ç–æ—Ç –ø—Ä–æ–¥–∞–ª —Å–≤–æ–∏ –º–æ–Ω–µ—Ç—ã {name} –∑–∞ –±–µ—Å—Ü–µ–Ω–æ–∫. +{amount}$"
        ],
        "phrases_betray_fail": [
            "üòÖ {name} (@{username}) –ø–æ—Ç–µ—Ä—è–ª {amount}$ –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ –∫–∏–¥–∫–∞",
            "üñ•Ô∏è {name} (@{username}) –∑–∞–±—ã–ª –ø–∞—Ä–æ–ª—å –æ—Ç –∫–æ—à–µ–ª—å–∫–∞ –∏ –ø–æ—Ç–µ—Ä—è–ª {amount}$"
        ],
        "phrases_result": [
            "üèÅ –ö—Ä–∏–ø—Ç–æ–Ω–∞–ª—ë—Ç –∑–∞–≤–µ—Ä—à—ë–Ω!\nüèÜ –õ–∏–¥–µ—Ä—ã: {top}",
        ]
    },
    "narko": {
        "name": "üíä –ù–∞—Ä–∫–æ–ª–∞–±–æ—Ä–∞—Ç–æ—Ä–∏—è",
        "keyword": "–ù–ê–Å–ú",
        "phrases_start": [
            "üü£ –ù–∞–µ—Ö–∞–ª–∏ –Ω–∞ –Ω–∞—Ä–∫–æ–ª–∞–±–æ—Ä–∞—Ç–æ—Ä–∏—é! –¢–∞–º —Ü–µ–ª—ã–π —Å–∫–ª–∞–¥ —Ç–æ–≤–∞—Ä–∞! –ó–∞–±–∏—Ä–∞–µ–º –≤—Å—ë! –ü–∏—à–∏ **–ù–ê–Å–ú**",
            "üíä –ö–æ–Ω–∫—É—Ä–µ–Ω—Ç—ã –æ—Å—Ç–∞–≤–∏–ª–∏ —Å–∫–ª–∞–¥ –±–µ–∑ –æ—Ö—Ä–∞–Ω—ã! –ü–∏—à–∏ **–ù–ê–Å–ú**, –±—ã—Å—Ç—Ä–æ!",
            "üß™ –õ–∞–±–æ—Ä–∞—Ç–æ—Ä–∏—è —Å–∏–Ω—Ç–µ–∑–∞! –ì–æ–≤–æ—Ä—è—Ç, —Ç–∞–º –≥–æ—Ä—ã –¥–µ–Ω–µ–≥! –ö—Ç–æ —É—Å–ø–µ–µ—Ç –Ω–∞–ø–∏—Å–∞—Ç—å **–ù–ê–Å–ú** - –ø–æ–ª—É—á–∏—Ç –¥–æ–ª—é",
            "üü£ –•–∏–º–∏–∫–∏ —Ä–∞–∑–±–µ–∂–∞–ª–∏—Å—å, —Ç–æ–≤–∞—Ä –æ—Å—Ç–∞–ª—Å—è! –ü–∏—à–∏ **–ù–ê–Å–ú**",
            "üíä –ö—Ä–∏—Å—Ç–∞–ª–ª—ã —á–∏—Å—Ç–µ–π—à–∏–µ! –ü–∏—à–∏ **–ù–ê–Å–ú**"
        ],
        "phrases_join": [
            "‚úÖ {name} –Ω—é—Ö–Ω—É–ª –∏ –≤ –¥–µ–ª–µ!",
            "üíâ {name} –ø–æ–¥ –∫–∞–π—Ñ–æ–º, –Ω–æ –≤ –¥–µ–ª–µ!"
        ],
        "phrases_split": [
            "üî™ –î–µ–ª–∏–º —Ç–æ–≤–∞—Ä! –£ —Ç–µ–±—è {minutes} –º–∏–Ω—É—Ç! –ñ–¥–∏ –∫–Ω–æ–ø–∫–∏ –≤ –õ–°."
        ],
        "phrases_betray_attempt": [
            "üî™ {name} –ø–æ–¥–º–µ—à–∏–≤–∞–µ—Ç —á—Ç–æ-—Ç–æ –≤ –∫–æ—Ñ–µ –ø–æ–¥–µ–ª—å–Ω–∏–∫–∞–º..."
        ],
        "phrases_betray_success": [
            "üî™ {name} (@{username}) –ø–æ–¥—Å—Ç–∞–≤–∏–ª {target} –º–µ–Ω—Ç–∞–º –∏ –∑–∞–±—Ä–∞–ª –µ–≥–æ –¥–æ–ª—é +{amount}$",
            "ü•¥ {name} (@{username}) —É–±–µ–¥–∏–ª {target}, —á—Ç–æ —ç—Ç–æ –Ω–µ –µ–≥–æ –¥–æ–ª—è, –∞ –º—É–∫–∞. {target} –ø–æ–≤–µ—Ä–∏–ª –∏ –æ—Ç–¥–∞–ª {amount}$"
        ],
        "phrases_betray_fail": [
            "üòÖ {name} (@{username}) –ø–µ—Ä–µ–ø—É—Ç–∞–ª –º–µ—à–∫–∏ –∏ –ø–æ—Ç–µ—Ä—è–ª {amount}$",
            "ü§¢ {name} (@{username}) —Ç–∞–∫ –Ω–∞–Ω—é—Ö–∞–ª—Å—è, —á—Ç–æ —Å–∞–º –æ—Ç–¥–∞–ª {target} {amount}$"
        ],
        "phrases_result": [
            "üèÅ –õ–∞–±–æ—Ä–∞—Ç–æ—Ä–∏—è —Ä–∞–∑–≥—Ä–∞–±–ª–µ–Ω–∞!\nüèÜ –¢–æ–ø –¥–æ–±—ã—Ç—á–∏–∫–æ–≤: {top}",
        ]
    },
    "weapon": {
        "name": "üî´ –û—Ä—É–∂–µ–π–Ω—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä",
        "keyword": "–°–¢–í–û–õ",
        "phrases_start": [
            "üî´ –û—Ä—É–∂–µ–π–Ω—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —É–ø–∞–ª —Å –≥—Ä—É–∑–æ–≤–∏–∫–∞! –¢–∞–º —Å—Ç–≤–æ–ª–æ–≤ –Ω–∞ –º–∏–ª–ª–∏–æ–Ω! –ö—Ç–æ —É—Å–ø–µ–µ—Ç –Ω–∞–ø–∏—Å–∞—Ç—å **–°–¢–í–û–õ** - –ø–æ–ª—É—á–∏—Ç –≤—Å—ë!",
            "üí• –ö–æ–Ω—Ñ–∏—Å–∫–∞—Ç! –û—Ä—É–∂–∏–µ –±–µ–∑ –ø—Ä–∏—Å–º–æ—Ç—Ä–∞! –ü–∏—à–∏ **–°–¢–í–û–õ**",
            "‚ö°Ô∏è –°—Ä–æ—á–Ω–æ! –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å –æ—Ä—É–∂–∏–µ–º! –ü–∏—à–∏ **–°–¢–í–û–õ**",
            "üî´ –ê–≤—Ç–æ–º–∞—Ç—ã –ø–æ —Ü–µ–Ω–µ –ø–∏—Ä–æ–∂–∫–æ–≤! –ü–∏—à–∏ **–°–¢–í–û–õ**",
            "üí£ –Ø—â–∏–∫ —Å —Ç—Ä–æ—Ç–∏–ª–æ–º! –ü–∏—à–∏ **–°–¢–í–û–õ**, –ø–æ–∫–∞ –Ω–µ –ø–æ–∑–¥–Ω–æ"
        ],
        "phrases_join": [
            "‚úÖ {name} –≤–æ–æ—Ä—É–∂–∏–ª—Å—è –∏ –≥–æ—Ç–æ–≤!",
            "üíÇ {name} –∑–∞—Ö–≤–∞—Ç–∏–ª —è—â–∏–∫ —Å –ø–∞—Ç—Ä–æ–Ω–∞–º–∏!"
        ],
        "phrases_split": [
            "üî™ –î–µ–ª–∏–º —Å—Ç–≤–æ–ª—ã! –£ —Ç–µ–±—è {minutes} –º–∏–Ω—É—Ç! –û—Ç–∫—Ä—ã–≤–∞–π –õ–°."
        ],
        "phrases_betray_attempt": [
            "üî™ {name} –ø–µ—Ä–µ–¥—ë—Ä–≥–∏–≤–∞–µ—Ç –∑–∞—Ç–≤–æ—Ä, —Ü–µ–ª—è—Å—å –≤ –ø–æ–¥–µ–ª—å–Ω–∏–∫–æ–≤..."
        ],
        "phrases_betray_success": [
            "üî™ {name} (@{username}) –∫–∏–Ω—É–ª {target} –Ω–∞ {amount}$ –∏ –¥–∞–ª –µ–º—É –ø–∏–Ω–∫–∞!",
            "üí• {name} (@{username}) –≤—ã—Å—Ç—Ä–µ–ª–∏–ª –≤ –≤–æ–∑–¥—É—Ö, {target} –∏—Å–ø—É–≥–∞–ª—Å—è –∏ –æ—Ç–¥–∞–ª {amount}$"
        ],
        "phrases_betray_fail": [
            "üòÖ {name} (@{username}) –ø—Ä–æ—Å—Ç—Ä–µ–ª–∏–ª —Å–µ–±–µ –Ω–æ–≥—É –∏ –ø–æ—Ç–µ—Ä—è–ª {amount}$",
            "üî´ {name} (@{username}) —Ç–∞–∫ —Ü–µ–ª–∏–ª—Å—è, —á—Ç–æ –≤—ã—Ä–æ–Ω–∏–ª {amount}$ –∏ {target} –ø–æ–¥–æ–±—Ä–∞–ª"
        ],
        "phrases_result": [
            "üèÅ –û—Ä—É–∂–∏–µ –ø—Ä–æ–¥–∞–Ω–æ!\nüèÜ –õ—É—á—à–∏–µ –≤–æ—Ä—ã: {top}",
        ]
    }
}

# ==================== –§–†–ê–ó–´ –î–õ–Ø –ö–û–ù–¢–†–ê–ë–ê–ù–î–´ ====================
SMUGGLE_START_PHRASES = [
    "üõ•Ô∏è {name}, —Ç—ã –æ—Ç–ø—Ä–∞–≤–ª—è–µ—à—å—Å—è –≤ –∫–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥–Ω—ã–π —Ä–µ–π—Å —Å –≥—Ä—É–∑–æ–º {cargo}. –í–µ—Ä–Ω—ë—à—å—Å—è —á–µ—Ä–µ–∑ {duration} –º–∏–Ω. –£–¥–∞—á–∏, –º–æ—Ä—è–∫!",
    "‚õµ {name}, —Ç–≤–æ—è –ª–æ–¥–∫–∞ –≥–æ—Ç–æ–≤–∞. –ì—Ä—É–∑: {cargo}. –í–µ—Ç–µ—Ä –ø–æ–ø—É—Ç–Ω—ã–π, –≤–µ—Ä–Ω—ë—à—å—Å—è —á–µ—Ä–µ–∑ {duration} –º–∏–Ω.",
    "üö§ {name}, —Ç—ã —Ç–∞–π–Ω–æ –≥—Ä—É–∑–∏—à—å {cargo} –Ω–∞ –∫–∞—Ç–µ—Ä. –ü–æ–≥—Ä–∞–Ω–∏—á–Ω–∏–∫–∏ –Ω–µ –¥—Ä–µ–º–ª—é—Ç, –Ω–æ —Ç—ã —Ä–∏—Å–∫–æ–≤—ã–π. –†–µ–∑—É–ª—å—Ç–∞—Ç —á–µ—Ä–µ–∑ {duration} –º–∏–Ω.",
    "üì¶ {name}, —Ç—ã —Å–ø—Ä—è—Ç–∞–ª {cargo} –≤ –¥–≤–æ–π–Ω–æ–º –¥–Ω–µ. –í—ã—Ö–æ–¥–∏ –≤ –º–æ—Ä–µ, —Ä–µ–∑—É–ª—å—Ç–∞—Ç —á–µ—Ä–µ–∑ {duration} –º–∏–Ω.",
    "‚öì {name}, —Ç–≤–æ–π –º–∞—Ä—à—Ä—É—Ç –ø—Ä–æ–ª–µ–≥–∞–µ—Ç —á–µ—Ä–µ–∑ –æ–ø–∞—Å–Ω—ã–µ –≤–æ–¥—ã. –ì—Ä—É–∑: {cargo}. –£–¥–∞—á–∏! –ñ–¥–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —á–µ—Ä–µ–∑ {duration} –º–∏–Ω.",
    "üö£ {name}, —Ç—ã –≤–∑—è–ª –Ω–∞–¥—É–≤–Ω—É—é –ª–æ–¥–∫—É –∏ {cargo}. –ì–ª–∞–≤–Ω–æ–µ ‚Äì –Ω–µ –ø—Ä–æ—Ç–∫–Ω–∏. –í–µ—Ä–Ω—ë—à—å—Å—è —á–µ—Ä–µ–∑ {duration} –º–∏–Ω.",
    "üõ∂ {name}, —Ç—ã –ø—Ä–∏—Ç–≤–æ—Ä–∏–ª—Å—è —Ä—ã–±–∞–∫–æ–º, –∞ –ø–æ–¥ —É–ª–æ–≤–æ–º {cargo}. –í–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ —á–µ—Ä–µ–∑ {duration} –º–∏–Ω.",
    "üöÅ {name}, —É —Ç–µ–±—è –µ—Å—Ç—å –≤–µ—Ä—Ç–æ–ª—ë—Ç! –ì—Ä—É–∑ {cargo} –ø–æ–¥–≤–µ—à–µ–Ω —Å–Ω–∏–∑—É. –ß–µ—Ä–µ–∑ {duration} –º–∏–Ω –±—É–¥–µ—à—å –Ω–∞ –º–µ—Å—Ç–µ."
]

SMUGGLE_SUCCESS_PHRASES = [
    "‚úÖ {name} (@{username}) –≤–∏—Ä—Ç—É–æ–∑–Ω–æ –æ–±–º–∞–Ω—É–ª –ø–æ–≥—Ä–∞–Ω–∏—á–Ω–∏–∫–æ–≤, –ø—Ä–∏—Ç–≤–æ—Ä–∏–≤—à–∏—Å—å —Ä—ã–±–æ–π. –î–æ–±—ã—á–∞: {amount} BTC.",
    "‚úÖ {name} (@{username}) –ø–æ–¥–∫—É–ø–∏–ª –∫–∞–ø–∏—Ç–∞–Ω–∞ —Å—Ç—Ä–∞–∂–∏ –±—É—Ç—ã–ª–∫–æ–π —Ä–æ–º–∞. –ü—Ä–∏–±—ã–ª—å: {amount} BTC.",
    "‚úÖ {name} (@{username}) –ø–µ—Ä–µ–æ–¥–µ–ª—Å—è –≤ –∂–µ–Ω—â–∏–Ω—É –∏ –ø—Ä–æ–Ω—ë—Å {cargo} –≤ –¥–∞–º—Å–∫–æ–π —Å—É–º–æ—á–∫–µ. –ó–∞—Ä–∞–±–æ—Ç–∞–Ω–æ: {amount} BTC.",
    "‚úÖ {name} (@{username}) –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª –ø–æ–¥–≤–æ–¥–Ω—É—é –ª–æ–¥–∫—É –∏–∑ –∫–∞—Ä—Ç–æ–Ω–∞. –ö–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥–∞ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–∞! +{amount} BTC.",
    "‚úÖ {name} (@{username}) –Ω–∞–∫–æ—Ä–º–∏–ª —Ç–∞–º–æ–∂–µ–Ω–Ω–∏–∫–æ–≤ –≥–∞–ª–ª—é—Ü–∏–Ω–æ–≥–µ–Ω–Ω—ã–º–∏ –≥—Ä–∏–±–∞–º–∏, –æ–Ω–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –∑–∞–º–µ—Ç–∏–ª–∏. –í—ã—Ä—É—á–∫–∞: {amount} BTC.",
    "‚úÖ {name} (@{username}) –ø—Ä–∏—Ç–≤–æ—Ä–∏–ª—Å—è –¥–µ–ª—å—Ñ–∏–Ω–æ–º –∏ –ø—Ä–æ–ø–ª—ã–ª –º–∏–º–æ —Ä–∞–¥–∞—Ä–æ–≤. –£–ª–æ–≤: {amount} BTC.",
    "‚úÖ {name} (@{username}) –∑–∞–∫–æ–ø–∞–ª {cargo} –≤ –ø–µ—Å–∫–µ, –∞ —Å–≤–µ—Ä—Ö—É –ø–æ—Å—Ç—Ä–æ–∏–ª –∑–∞–º–æ–∫. –û—Ç–ª–∏—á–Ω–∞—è –º–∞—Å–∫–∏—Ä–æ–≤–∫–∞! +{amount} BTC.",
    "‚úÖ {name} (@{username}) –ø–æ–¥–∫—É–ø–∏–ª –Ω–∞—á–∞–ª—å–Ω–∏–∫–∞ –ø–æ—Ä—Ç–∞ —è—â–∏–∫–æ–º –∫–æ–Ω—å—è–∫–∞. –¢–æ–≤–∞—Ä –Ω–∞ –º–µ—Å—Ç–µ. –ó–∞—Ä–∞–±–æ—Ç–∞–Ω–æ: {amount} BTC.",
    "‚úÖ {name} (@{username}) –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª –¥—Ä–µ—Å—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ç—é–ª–µ–Ω–µ–π –¥–ª—è –ø–µ—Ä–µ–ø—Ä–∞–≤–∫–∏. –¢–∞–º–æ–∂–Ω—è –≤ —à–æ–∫–µ! +{amount} BTC.",
    "‚úÖ {name} (@{username}) –ø—Ä–∏–∫–∏–Ω—É–ª—Å—è —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–º —Å–ø–µ—Ü—Å–≤—è–∑–∏ –∏ –±–µ—Å–ø—Ä–µ–ø—è—Ç—Å—Ç–≤–µ–Ω–Ω–æ –ø—Ä–æ–µ—Ö–∞–ª. –î–æ–±—ã—á–∞: {amount} BTC."
]

SMUGGLE_FAIL_PHRASES = [
    "‚ùå {name} (@{username}) –∑–∞–ø—É—Ç–∞–ª—Å—è –≤ —Å–µ—Ç—è—Ö –∏ –±—ã–ª –ø–æ–π–º–∞–Ω —Ä—ã–±–∞–∫–∞–º–∏. –ì—Ä—É–∑ –∫–æ–Ω—Ñ–∏—Å–∫–æ–≤–∞–Ω.",
    "‚ùå {name} (@{username}) –ø–æ–ø—ã—Ç–∞–ª—Å—è –ø–æ–¥–∫—É–ø–∏—Ç—å –ø–æ–≥—Ä–∞–Ω–∏—á–Ω–∏–∫–∞ –∂–≤–∞—á–∫–æ–π, –Ω–æ —Ç–æ—Ç –æ–∫–∞–∑–∞–ª—Å—è –ø—Ä–∏–Ω—Ü–∏–ø–∏–∞–ª—å–Ω—ã–º. –í—Å—ë –ø—Ä–æ–ø–∞–ª–æ.",
    "‚ùå {name} (@{username}) —É—Å–Ω—É–ª –≤ –ª–æ–¥–∫–µ –∏ –ø—Ä–∏–ø–ª—ã–ª –æ–±—Ä–∞—Ç–Ω–æ –∫ –±–µ—Ä–µ–≥—É. –ì—Ä—É–∑ —É–∫—Ä–∞–ª–∏ —á–∞–π–∫–∏.",
    "‚ùå {name} (@{username}) –ø–µ—Ä–µ–ø—É—Ç–∞–ª –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏ –ø—Ä–∏–ø–ª—ã–ª –≤ –æ—Ç–∫—Ä—ã—Ç–æ–µ –º–æ—Ä–µ –±–µ–∑ –≥–æ—Ä—é—á–µ–≥–æ. –°–ø–∞—Å–∞—Ç–µ–ª–∏ –Ω–∞—à–ª–∏, –Ω–æ –≥—Ä—É–∑ —É—Ç–æ–Ω—É–ª.",
    "‚ùå {name} (@{username}) —Ç–∞–∫ –±–æ—è–ª—Å—è, —á—Ç–æ –Ω–∞–ª–æ–∂–∏–ª –≤ —à—Ç–∞–Ω—ã, –∏ –∑–∞–ø–∞—Ö –ø—Ä–∏–≤–ª—ë–∫ —Å–æ–±–∞–∫-–∏—â–µ–µ–∫. –ö–æ–Ω—Ñ–∏—Å–∫–∞—Ü–∏—è.",
    "‚ùå {name} (@{username}) —Ä–µ—à–∏–ª –ø–ª—ã—Ç—å –Ω–∞ –Ω–∞–¥—É–≤–Ω–æ–π –ª–æ–¥–∫–µ, –Ω–æ –æ–Ω–∞ –ª–æ–ø–Ω—É–ª–∞. –í—Å–µ —É—Ç–æ–Ω—É–ª–æ.",
    "‚ùå {name} (@{username}) –ø–æ–ø—ã—Ç–∞–ª—Å—è –ø—Ä–æ–≤–µ–∑—Ç–∏ {cargo} –≤ –∂–µ–ª—É–¥–∫–µ, –Ω–æ –Ω–µ —Ä–∞—Å—Å—á–∏—Ç–∞–ª –¥–æ–∑—É. –°–∫–æ—Ä–∞—è —É–≤–µ–∑–ª–∞, —Ç–æ–≤–∞—Ä –∏–∑—ä—è—Ç.",
    "‚ùå {name} (@{username}) —Ö–≤–∞—Å—Ç–∞–ª—Å—è –≤ –±–∞—Ä–µ —Å–≤–æ–∏–º –ø–ª–∞–Ω–æ–º, –∏ –µ–≥–æ —Å–¥–∞–ª –±–∞—Ä–º–µ–Ω. –ì—Ä—É–∑ –∫–æ–Ω—Ñ–∏—Å–∫–æ–≤–∞–Ω.",
    "‚ùå {name} (@{username}) –ø–µ—Ä–µ–ø—É—Ç–∞–ª –º–µ—à–∫–∏ –∏ –≤–º–µ—Å—Ç–æ –∫–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥—ã –ø—Ä–∏–≤—ë–∑ –∫–∞—Ä—Ç–æ—à–∫—É. –ü–æ–∑–æ—Ä –∏ —É–±—ã—Ç–∫–∏.",
    "‚ùå {name} (@{username}) –ø–æ–ø–∞–ª –≤ —à—Ç–æ—Ä–º –∏ –≤—ã–±—Ä–æ—Å–∏–ª –≥—Ä—É–∑ –∑–∞ –±–æ—Ä—Ç, —á—Ç–æ–±—ã —Å–ø–∞—Å—Ç–∏—Å—å. –ù–∏—á–µ–≥–æ –Ω–µ –∑–∞—Ä–∞–±–æ—Ç–∞–ª."
]

# ==================== –§–†–ê–ó–´ –î–õ–Ø –¢–Æ–†–¨–ú–´ ====================
JAIL_START_PHRASES = [
    "üöî {name}, —Ç—ã –ø–æ–ø–∞–ª—Å—è –Ω–∞ –∫—Ä–∞–∂–µ –ø–∞—Ä—ã —è–∏—Ü! –°—É–¥—å—è –ø—Ä–∏–≥–æ–≤–æ—Ä–∏–ª —Ç–µ–±—è –∫ {duration} –º–∏–Ω—É—Ç–∞–º —Ç—é—Ä—å–º—ã. –°–∏–¥–∏ –∏ –¥—É–º–∞–π –æ –ø–æ–≤–µ–¥–µ–Ω–∏–∏!",
    "üîí {name}, —Ç—ã –ø–µ—Ä–µ—Ö–æ–¥–∏–ª –¥–æ—Ä–æ–≥—É –≤ –Ω–µ–ø–æ–ª–æ–∂–µ–Ω–Ω–æ–º –º–µ—Å—Ç–µ, –Ω–æ –ø–æ–ª–∏—Ü–µ–π—Å–∫–æ–º—É –Ω–µ –ø–æ–Ω—Ä–∞–≤–∏–ª–∞—Å—å —Ç–≤–æ—è —Ä–æ–∂–∞. {duration} –º–∏–Ω—É—Ç –∑–∞ —Ä–µ—à—ë—Ç–∫–æ–π!",
    "‚õìÔ∏è {name}, —Ç–µ–±—è –∑–∞–º–µ–ª–∏ –∑–∞ —Ä–∞—Å–ø–∏—Ç–∏–µ –ø–∏–≤–∞ —É –º–µ—Ç—Ä–æ. –°—Ä–æ–∫: {duration} –º–∏–Ω—É—Ç.",
    "üèõÔ∏è {name}, —Ç—ã –Ω–µ –∑–∞–ø–ª–∞—Ç–∏–ª –∑–∞ –ø—Ä–æ–µ–∑–¥, –∞ –∫–æ–≥–¥–∞ –∫–æ–Ω—Ç—Ä–æ–ª—ë—Ä —Å–¥–µ–ª–∞–ª –∑–∞–º–µ—á–∞–Ω–∏–µ, –ø–æ—Å–ª–∞–ª –µ–≥–æ. {duration} –º–∏–Ω—É—Ç –≤ –∫–∞–º–µ—Ä–µ.",
    "ü™ë {name}, —Ç–µ–±—è –æ–±–≤–∏–Ω–∏–ª–∏ –≤ –Ω–µ–ø–æ–¥–æ–±–∞—é—â–µ–º –≤–∏–¥–µ. –°—É–¥—å—è –∂–µ–Ω—â–∏–Ω–∞, –µ–π –Ω–µ –ø–æ–Ω—Ä–∞–≤–∏–ª—Å—è —Ç–≤–æ–π –≤–∑–≥–ª—è–¥. {duration} –º–∏–Ω—É—Ç.",
    "üö® {name}, —Ç—ã –ø–æ–ø—ã—Ç–∞–ª—Å—è –¥–∞—Ç—å –≤–∑—è—Ç–∫—É –≥–∞–∏—à–Ω–∏–∫—É –ø–∏—Ä–æ–∂–∫–æ–º. –°—Ä–æ–∫: {duration} –º–∏–Ω—É—Ç.",
    "‚öñÔ∏è {name}, —Ç—ã —É–∫—Ä–∞–ª —É –±–∞–±—É—à–∫–∏ –∫–æ—à–µ–ª—ë–∫, –Ω–æ –±–∞–±—É—à–∫–∞ –æ–∫–∞–∑–∞–ª–∞—Å—å –∂–µ–Ω–æ–π —Å—É–¥—å–∏. {duration} –º–∏–Ω—É—Ç —Ç—é—Ä—å–º—ã.",
    "üöì {name}, —Ç—ã –≥—Ä–æ–º–∫–æ —Å–º–µ—è–ª—Å—è –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫–µ. –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞—Ä—å –≤—ã–∑–≤–∞–ª–∞ –ø–æ–ª–∏—Ü–∏—é. {duration} –º–∏–Ω—É—Ç.",
    "üîê {name}, —Ç—ã –∑–∞–ø—É—Å—Ç–∏–ª —Å–∞–ª—é—Ç –≤–æ –¥–≤–æ—Ä–µ –≤ 3 —á–∞—Å–∞ –Ω–æ—á–∏. –°–æ—Å–µ–¥–∏ –≤—ã–∑–≤–∞–ª–∏ –Ω–∞—Ä—è–¥. {duration} –º–∏–Ω—É—Ç.",
    "ü¶∫ {name}, —Ç–µ–±—è –ø—Ä–∏–Ω—è–ª–∏ –∑–∞ –±–æ–º–∂–∞ –∏ –∑–∞–±—Ä–∞–ª–∏ –≤ –≤—ã—Ç—Ä–µ–∑–≤–∏—Ç–µ–ª—å. {duration} –º–∏–Ω—É—Ç.",
    "üëÆ {name}, —Ç—ã –ø—ã—Ç–∞–ª—Å—è —É–∫—Ä–∞—Å—Ç—å –ø–æ–ª–∏—Ü–µ–π—Å–∫—É—é –º–∞—à–∏–Ω—É, –Ω–æ –∑–∞–±—ã–ª, —á—Ç–æ –æ–Ω–∞ –Ω–∞ —Å–∏–≥–Ω–∞–ª–∏–∑–∞—Ü–∏–∏. –°—Ä–æ–∫ {duration} –º–∏–Ω.",
    "üöî {name}, —Ç–µ–±—è –ø–æ–π–º–∞–ª–∏ –Ω–∞ —Ç–æ—Ä–≥–æ–≤–ª–µ —Ñ–∞–ª—å—à–∏–≤—ã–º–∏ –∞–≤—Ç–æ–≥—Ä–∞—Ñ–∞–º–∏. {duration} –º–∏–Ω—É—Ç."
]

JAIL_SUCCESS_PHRASES = [
    "üéâ {name} (@{username}) —É—Å—Ç—Ä–æ–∏–ª –±—É–Ω—Ç –≤ —Ç—é—Ä—å–º–µ –∏ –∑–∞—Ö–≤–∞—Ç–∏–ª –≤–ª–∞—Å—Ç—å –≤ –∫–∞–º–µ—Ä–µ! –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üëë {name} (@{username}) –ø–æ–¥–∫—É–ø–∏–ª –Ω–∞–¥–∑–∏—Ä–∞—Ç–µ–ª—è –∏ —Ç–µ–ø–µ—Ä—å –∫–æ–º–∞–Ω–¥—É–µ—Ç –º–µ—Å—Ç–Ω—ã–º–∏. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üí™ {name} (@{username}) –Ω–∞–≤–∞–ª—è–ª —Å–º–æ—Ç—Ä—è—â–µ–º—É –∏ —Å—Ç–∞–ª –Ω–æ–≤—ã–º –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–æ–º. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üß† {name} (@{username}) –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞–ª –ø–æ–±–µ–≥, –Ω–æ –µ–≥–æ –ø–æ–π–º–∞–ª–∏, –æ–¥–Ω–∞–∫–æ –≤ —Ç—é—Ä—å–º–µ –µ–≥–æ –∑–∞—É–≤–∞–∂–∞–ª–∏. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üçó {name} (@{username}) –ø–æ–¥–µ–ª–∏–ª—Å—è –ø–∞–π–∫–æ–π —Å –Ω—É–∂–¥–∞—é—â–∏–º–∏—Å—è, —Ç–µ–ø–µ—Ä—å –µ–≥–æ —É–≤–∞–∂–∞—é—Ç. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üìö {name} (@{username}) –Ω–∞—É—á–∏–ª —Å–æ–∫–∞–º–µ—Ä–Ω–∏–∫–æ–≤ —á–∏—Ç–∞—Ç—å –∏ –ø–∏—Å–∞—Ç—å, –≤—Å–µ –≤ –≤–æ—Å—Ç–æ—Ä–≥–µ. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üé§ {name} (@{username}) —Å–ø–µ–ª –≤ —Ç—é—Ä–µ–º–Ω–æ–º —Ö–æ—Ä–µ —Ç–∞–∫, —á—Ç–æ –æ—Ö—Ä–∞–Ω–∞ –ø–ª–∞–∫–∞–ª–∞. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üèãÔ∏è {name} (@{username}) –æ—Ç–∂–∞–ª—Å—è 100 —Ä–∞–∑ –Ω–∞ –≥–ª–∞–∑–∞—Ö —É –≤—Å–µ—Ö, —Ç–µ–ø–µ—Ä—å –µ–≥–æ –±–æ—è—Ç—Å—è. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "‚öîÔ∏è {name} (@{username}) –ø–æ–±–µ–¥–∏–ª –≤ –ø–æ–¥–ø–æ–ª—å–Ω—ã—Ö –±–æ—è—Ö –±–µ–∑ –ø—Ä–∞–≤–∏–ª. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üé≠ {name} (@{username}) –ø–æ—Å—Ç–∞–≤–∏–ª —Å–ø–µ–∫—Ç–∞–∫–ª—å –≤ —Ç—é—Ä—å–º–µ, –≤—Å–µ –∞–ø–ª–æ–¥–∏—Ä–æ–≤–∞–ª–∏. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "ü§ù {name} (@{username}) –ø–æ–¥—Ä—É–∂–∏–ª—Å—è —Å –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞–º–∏, —Ç–µ–ø–µ—Ä—å –∑–∞ –Ω–µ–≥–æ –≥–æ—Ä–æ–π. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üí∞ {name} (@{username}) –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞–ª —Ç—é—Ä–µ–º–Ω—ã–π –±–∏–∑–Ω–µ—Å –ø–æ –ø—Ä–æ–¥–∞–∂–µ —á–∏—Ñ–∏—Ä–∞. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üé≤ {name} (@{username}) –≤—Å–µ—Ö –æ–±—ã–≥—Ä–∞–ª –≤ –∫–∞—Ä—Ç—ã, —Ç–µ–ø–µ—Ä—å –µ–º—É –¥–æ–ª–∂–Ω—ã. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üì¶ {name} (@{username}) –Ω–∞–ª–∞–¥–∏–ª –ø–æ—Å—Ç–∞–≤–∫–∏ –ø–µ—Ä–µ–¥–∞—á, –µ–≥–æ –∑–∞—É–≤–∞–∂–∞–ª–∏. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç +{auth}. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})"
]

JAIL_FAIL_PHRASES = [
    "üò¢ {name} (@{username}) –±—ã–ª –æ–±–æ—Å—Å–∞–Ω —Å–æ–∫–∞–º–µ—Ä–Ω–∏–∫–∞–º–∏ –∑–∞ —Ç–æ, —á—Ç–æ –Ω–µ –ø–æ–¥–µ–ª–∏–ª—Å—è –ø–∞–π–∫–æ–π. –ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç –Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üêî {name} (@{username}) —Å—Ç–∞–ª –≥–ª–∞–≤–Ω—ã–º –ø–µ—Ç—É—Ö–æ–º. –í—Å—è –∑–æ–Ω–∞ —Å–ª—ã—à–∞–ª–∞, –∫–∞–∫ –æ–Ω –∫—É–¥–∞—Ö—Ç–∞–ª. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üßπ {name} (@{username}) –ø—Ä–∏—Å–ª—É–∂–∏–≤–∞–ª –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏–∏, –º—ã–ª —Ç—É–∞–ª–µ—Ç—ã. –£–≤–∞–∂–µ–Ω–∏—è –Ω–µ –∑–∞—Å–ª—É–∂–∏–ª. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "ü•¥ {name} (@{username}) –ø–æ–ø—ã—Ç–∞–ª—Å—è —É–±–µ–∂–∞—Ç—å, –Ω–æ —Å–ø–æ—Ç–∫–Ω—É–ª—Å—è –∏ —É–ø–∞–ª –≤ –≤—ã–≥—Ä–µ–±–Ω—É—é —è–º—É. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "ü§° {name} (@{username}) —Ä–∞—Å—Å–∫–∞–∑—ã–≤–∞–ª –∞–Ω–µ–∫–¥–æ—Ç—ã, –Ω–æ –Ω–∏–∫—Ç–æ –Ω–µ —Å–º–µ—è–ª—Å—è, —Ç–æ–ª—å–∫–æ –±–∏–ª–∏. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üé™ {name} (@{username}) –ø—ã—Ç–∞–ª—Å—è –∏–∑–æ–±—Ä–∞–∂–∞—Ç—å —Ü–∏—Ä–∫, –Ω–æ –µ–≥–æ –∑–∞–∫–∏–¥–∞–ª–∏ —Ç—É—Ö–ª—ã–º–∏ —è–π—Ü–∞–º–∏. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "ü•© {name} (@{username}) —É–∫—Ä–∞–ª —É —Å–º–æ—Ç—Ä—è—â–µ–≥–æ –∫—É—Å–æ–∫ —Å–∞–ª–∞ –∏ –±—ã–ª –∂–µ—Å—Ç–æ–∫–æ –∏–∑–±–∏—Ç. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üìû {name} (@{username}) –∑–≤–æ–Ω–∏–ª –º–∞–º–µ –∏ –ø–ª–∞–∫–∞–ª, –Ω–∞–¥ –Ω–∏–º –≤—Å–µ —Å–º–µ—è–ª–∏—Å—å. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üï≥Ô∏è {name} (@{username}) —Å–ø—Ä—è—Ç–∞–ª—Å—è –≤ —Ç—É–∞–ª–µ—Ç–µ, –Ω–æ –µ–≥–æ –Ω–∞—à–ª–∏ –∏ –Ω–∞–∫–∞–∑–∞–ª–∏. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üé≠ {name} (@{username}) –ø—ã—Ç–∞–ª—Å—è –∏–≥—Ä–∞—Ç—å —Ä–æ–ª—å –∫—Ä—É—Ç–æ–≥–æ, –Ω–æ –µ–≥–æ —Ä–∞–∑–æ–±–ª–∞—á–∏–ª–∏. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üçº {name} (@{username}) —Ä–∞—Å–ø–ª–∞–∫–∞–ª—Å—è, –∫–æ–≥–¥–∞ –æ—Ç–æ–±—Ä–∞–ª–∏ —Ç–µ–ª–µ—Ñ–æ–Ω. –í—Å–µ –Ω–∞–∑—ã–≤–∞—é—Ç –µ–≥–æ –º–∞–ª—ã—à–∫–æ–π. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üöΩ {name} (@{username}) —É—Ä–æ–Ω–∏–ª –º—ã–ª–æ –∏ —Ä–µ—à–∏–ª –Ω–µ –ø–æ–¥–Ω–∏–º–∞—Ç—å, —Ç–µ–ø–µ—Ä—å –æ–Ω –º–µ—Å—Ç–Ω–∞—è –ª–µ–≥–µ–Ω–¥–∞. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üßº {name} (@{username}) –º—ã–ª—Å—è –≤ –¥—É—à–µ –¥–æ–ª—å—à–µ –≤—Å–µ—Ö, –µ–≥–æ –∏–∑–±–∏–ª–∏. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})",
    "üìñ {name} (@{username}) —á–∏—Ç–∞–ª —É–≥–æ–ª–æ–≤–Ω—ã–π –∫–æ–¥–µ–∫—Å –≤—Å–ª—É—Ö, –≤—Å–µ —É—Å–Ω—É–ª–∏. 0 –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞. (–ö–∞–º–µ—Ä–∞ {cell}, —Å—Ç–∞—Ç—å—è {article})"
]

# ==================== –ù–ê–°–¢–†–û–ô–ö–ê –õ–û–ì–ì–ï–†–ê ====================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(name)s - %(message)s"
)

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ —Ñ–∞–π–ª –æ—à–∏–±–æ–∫
import sys
file_handler = logging.FileHandler('bot_errors.log', encoding='utf-8')
file_handler.setLevel(logging.ERROR)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
file_handler.setFormatter(formatter)
logging.getLogger('').addHandler(file_handler)

console_handler = logging.StreamHandler(sys.stdout)
console_handler.setLevel(logging.INFO)
console_handler.setFormatter(formatter)
logging.getLogger('').addHandler(console_handler)

# ==================== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ====================
db_pool = None
settings_cache = {}
last_settings_update = 0
channels_cache = []
last_channels_update = 0
confirmed_chats_cache = {}
last_confirmed_chats_update = 0

# ==================== –î–ï–ö–û–†–ê–¢–û–† –î–õ–Ø –ü–û–í–¢–û–†–ù–´–• –ü–û–ü–´–¢–û–ö –ü–†–ò –û–®–ò–ë–ö–ê–• –ë–î ====================
def db_retry(max_retries=3, delay=1):
    """–î–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–∞ –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å –ë–î."""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            for attempt in range(max_retries):
                try:
                    return await func(*args, **kwargs)
                except (asyncpg.exceptions.ConnectionDoesNotExistError,
                        asyncpg.exceptions.InterfaceError,
                        asyncpg.exceptions.ConnectionFailureError) as e:
                    logging.warning(f"–û—à–∏–±–∫–∞ –ë–î –≤ {func.__name__} (–ø–æ–ø—ã—Ç–∫–∞ {attempt+1}/{max_retries}): {e}")
                    if attempt == max_retries - 1:
                        raise
                    await asyncio.sleep(delay * (2 ** attempt))  # —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
                    await ensure_db_connection()
                except Exception as e:
                    # –î—Ä—É–≥–∏–µ –æ—à–∏–±–∫–∏ –Ω–µ –ø–æ–≤—Ç–æ—Ä—è–µ–º
                    raise
            return None  # –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –¥–æ—Å—Ç–∏–≥–∞–µ—Ç—Å—è
        return wrapper
    return decorator

# ==================== –ú–ò–î–õ–í–ê–†–¨ –î–õ–Ø –õ–ò–ß–ù–´–• –°–û–û–ë–©–ï–ù–ò–ô (–∞–Ω—Ç–∏-—Ñ–ª—É–¥) ====================
class ThrottlingMiddleware(BaseMiddleware):
    def __init__(self, rate_limit=1.0):
        self.rate_limit = rate_limit
        self.user_last_time = defaultdict(float)

    async def __call__(self, handler, event: Message, data: dict):
        if event.chat.type != 'private':
            return await handler(event, data)
        user_id = event.from_user.id
        if await is_super_admin(user_id):
            return await handler(event, data)
        now = time.time()
        if now - self.user_last_time[user_id] < self.rate_limit:
            try:
                await event.reply("‚è≥ –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤. –ü–æ–¥–æ–∂–¥–∏ —Å–µ–∫—É–Ω–¥—É.")
            except Exception:
                pass
            return
        self.user_last_time[user_id] = now
        if len(self.user_last_time) > 1000:
            cutoff = now - 3600
            self.user_last_time = defaultdict(float, {k:v for k,v in self.user_last_time.items() if v > cutoff})
        return await handler(event, data)

# ==================== –ú–ò–î–õ–í–ê–†–¨ –î–õ–Ø –ì–õ–û–ë–ê–õ–¨–ù–û–ì–û –ö–£–õ–î–ê–£–ù–ê –í –ß–ê–¢–ê–• ====================
class GlobalCooldownMiddleware(BaseMiddleware):
    async def __call__(self, handler, event: Message, data: dict):
        if event.chat.type == 'private':
            return await handler(event, data)
        user_id = event.from_user.id
        try:
            cooldown_hours = await get_setting_int("global_chat_cooldown_hours")
            ok, remaining = await check_global_cooldown(user_id, "chat_activity", cooldown_hours * 3600)
            if not ok:
                await auto_delete_command(event, f"‚è≥ –ì–ª–æ–±–∞–ª—å–Ω—ã–π –∫—É–ª–¥–∞—É–Ω! –¢—ã —Å–º–æ–∂–µ—à—å —Å–Ω–æ–≤–∞ —É—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å —á–µ—Ä–µ–∑ {format_time_remaining(remaining)}")
                return
        except Exception as e:
            logging.error(f"GlobalCooldownMiddleware error: {e}")
            # –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–ø—Ä–æ—Å, —á—Ç–æ–±—ã –Ω–µ –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å —Ä–∞–±–æ—Ç—É
            pass
        return await handler(event, data)

# –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –º–∏–¥–ª–≤–∞—Ä–∏
dp.message.middleware(ThrottlingMiddleware(rate_limit=0.5))
dp.message.middleware(GlobalCooldownMiddleware())

# ==================== –§–£–ù–ö–¶–ò–ò –ü–†–û–í–ï–†–ö–ò –ü–†–ê–í ====================
async def is_super_admin(user_id: int) -> bool:
    return user_id in SUPER_ADMINS

@db_retry()
async def is_junior_admin(user_id: int) -> bool:
    async with db_pool.acquire() as conn:
        row = await conn.fetchval("SELECT user_id FROM admins WHERE user_id=$1", user_id)
    return row is not None

async def is_admin(user_id: int) -> bool:
    return await is_super_admin(user_id) or await is_junior_admin(user_id)

@db_retry()
async def has_permission(user_id: int, permission: str) -> bool:
    if await is_super_admin(user_id):
        return True
    async with db_pool.acquire() as conn:
        perms_json = await conn.fetchval("SELECT permissions FROM admins WHERE user_id=$1", user_id)
    if not perms_json:
        return False
    try:
        perms = json.loads(perms_json)
        return permission in perms
    except:
        return False

@db_retry()
async def get_admin_permissions(user_id: int) -> List[str]:
    if await is_super_admin(user_id):
        return PERMISSIONS_LIST.copy()
    async with db_pool.acquire() as conn:
        perms_json = await conn.fetchval("SELECT permissions FROM admins WHERE user_id=$1", user_id)
    if not perms_json:
        return []
    try:
        return json.loads(perms_json)
    except:
        return []

@db_retry()
async def update_admin_permissions(user_id: int, permissions: List[str]):
    async with db_pool.acquire() as conn:
        await conn.execute(
            "UPDATE admins SET permissions=$1 WHERE user_id=$2",
            json.dumps(permissions), user_id
        )

# ==================== –ë–ï–ó–û–ü–ê–°–ù–ê–Ø –û–¢–ü–†–ê–í–ö–ê ====================
async def safe_send_message(user_id: int, text: str, **kwargs):
    try:
        await bot.send_message(user_id, text, **kwargs)
    except TelegramBadRequest as e:
        logging.warning(f"Bad request for user {user_id}: {e}")
    except TelegramForbiddenError:
        logging.warning(f"Bot blocked by user {user_id}")
    except TelegramRetryAfter as e:
        logging.warning(f"Flood limit exceeded. Retry after {e.retry_after} seconds")
        await asyncio.sleep(e.retry_after)
        try:
            await bot.send_message(user_id, text, **kwargs)
        except Exception as ex:
            logging.warning(f"Still failed after retry: {ex}")
    except TelegramAPIError as e:
        logging.warning(f"Telegram API error for user {user_id}: {e}")
    except Exception as e:
        logging.warning(f"Failed to send message to {user_id}: {e}")

def safe_send_message_task(user_id: int, text: str, **kwargs):
    asyncio.create_task(safe_send_message(user_id, text, **kwargs))

async def safe_send_chat(chat_id: int, text: str, **kwargs):
    try:
        await bot.send_message(chat_id, text, **kwargs)
    except Exception as e:
        logging.error(f"Failed to send to chat {chat_id}: {e}")

# ==================== –ê–í–¢–û–£–î–ê–õ–ï–ù–ò–ï ====================
async def can_delete_message(chat_id: int, message: Message) -> bool:
    try:
        if chat_id > 0:
            return message.from_user.id == bot.id
        else:
            member = await bot.get_chat_member(chat_id, bot.id)
            return member.status in ['administrator', 'creator']
    except:
        return False

async def delete_after(message: Message, seconds: int):
    await asyncio.sleep(seconds)
    if await can_delete_message(message.chat.id, message):
        try:
            await message.delete()
        except (TelegramBadRequest, TelegramForbiddenError):
            pass
        except Exception:
            pass

async def auto_delete_reply(message: Message, text: str, delete_seconds: int = None, **kwargs):
    if delete_seconds is None:
        delete_seconds = int(await get_setting("auto_delete_commands_seconds"))
    sent = await message.reply(text, **kwargs)
    if message.chat.type != 'private':
        confirmed = await get_confirmed_chats()
        chat_data = confirmed.get(message.chat.id)
        if chat_data and not chat_data.get('auto_delete_enabled', True):
            return
    asyncio.create_task(delete_after(sent, delete_seconds))

async def auto_delete_message(message: Message, delete_seconds: int = None):
    if message.chat.type == 'private':
        return
    if delete_seconds is None:
        delete_seconds = int(await get_setting("auto_delete_commands_seconds"))
    confirmed = await get_confirmed_chats()
    chat_data = confirmed.get(message.chat.id)
    if chat_data and not chat_data.get('auto_delete_enabled', True):
        return
    asyncio.create_task(delete_after(message, delete_seconds))

async def auto_delete_command(message: Message, text: str = None, **kwargs):
    """–£–¥–∞–ª—è–µ—Ç –∫–æ–º–∞–Ω–¥—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –æ—Ç–≤–µ—Ç —Å –∞–≤—Ç–æ—É–¥–∞–ª–µ–Ω–∏–µ–º"""
    try:
        await message.delete()
    except:
        pass
    if text:
        delete_seconds = int(await get_setting("auto_delete_commands_seconds"))
        sent = await message.answer(text, **kwargs)
        asyncio.create_task(delete_after(sent, delete_seconds))

# ==================== –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï –ö –ë–î ====================
async def create_db_pool(retries: int = 10, delay: int = 5):
    global db_pool
    for attempt in range(1, retries + 1):
        try:
            db_pool = await asyncpg.create_pool(
                DATABASE_URL,
                min_size=2,
                max_size=10,
                command_timeout=600,
                max_queries=50000,
                max_inactive_connection_lifetime=30,
                timeout=60,
                statement_cache_size=0,
                max_cached_statement_lifetime=0
            )
            logging.info(f"‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ PostgreSQL —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ (–ø–æ–ø—ã—Ç–∫–∞ {attempt})")
            return
        except Exception as e:
            logging.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î (–ø–æ–ø—ã—Ç–∫–∞ {attempt}/{retries}): {e}")
            if attempt < retries:
                await asyncio.sleep(delay)
            else:
                raise

async def ensure_db_connection():
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –ë–î –∏ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞–µ—Ç—Å—è –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏"""
    global db_pool
    if db_pool is None:
        await create_db_pool()
        return
    try:
        async with db_pool.acquire() as conn:
            await conn.execute("SELECT 1")
    except Exception as e:
        logging.error(f"–ü–æ—Ç–µ—Ä—è–Ω–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –ë–î: {e}. –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞—é—Å—å...")
        try:
            await db_pool.close()
        except:
            pass
        finally:
            db_pool = None
        await create_db_pool()

# ==================== –ü–ò–ù–ì –ë–î (–¥–µ—Ä–∂–∏—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∂–∏–≤—ã–º) ====================
async def keep_db_alive():
    """–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ –ø–∏–Ω–≥—É–µ—Ç –ë–î, —á—Ç–æ–±—ã —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ –∑–∞–∫—Ä—ã–≤–∞–ª–æ—Å—å, –∏ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞–µ—Ç—Å—è –ø—Ä–∏ —Å–±–æ—è—Ö."""
    while True:
        try:
            await asyncio.sleep(30)  # –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
            if db_pool is None:
                await create_db_pool()
                continue
            async with db_pool.acquire() as conn:
                await conn.execute("SELECT 1")
                logging.debug("–ü–∏–Ω–≥ –ë–î –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ")
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∏–Ω–≥–µ –ë–î: {e}")
            await ensure_db_connection()

# ==================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –¢–ê–ë–õ–ò–¶ ====================
@db_retry()
async def init_db():
    async with db_pool.acquire() as conn:
        # –¢–∞–±–ª–∏—Ü–∞ users
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS users (
                user_id BIGINT PRIMARY KEY,
                username TEXT,
                first_name TEXT,
                joined_date TEXT,
                balance NUMERIC(12,2) DEFAULT 0,
                reputation INTEGER DEFAULT 0,
                total_spent NUMERIC(12,2) DEFAULT 0,
                negative_balance NUMERIC(12,2) DEFAULT 0,
                last_bonus TEXT,
                last_theft_time TEXT,
                theft_attempts INTEGER DEFAULT 0,
                theft_success INTEGER DEFAULT 0,
                theft_failed INTEGER DEFAULT 0,
                theft_protected INTEGER DEFAULT 0,
                casino_wins INTEGER DEFAULT 0,
                casino_losses INTEGER DEFAULT 0,
                dice_wins INTEGER DEFAULT 0,
                dice_losses INTEGER DEFAULT 0,
                guess_wins INTEGER DEFAULT 0,
                guess_losses INTEGER DEFAULT 0,
                slots_wins INTEGER DEFAULT 0,
                slots_losses INTEGER DEFAULT 0,
                roulette_wins INTEGER DEFAULT 0,
                roulette_losses INTEGER DEFAULT 0,
                exp INTEGER DEFAULT 0,
                level INTEGER DEFAULT 1,
                last_gift_time TEXT,
                gift_count_today INTEGER DEFAULT 0,
                global_authority INTEGER DEFAULT 0,
                smuggle_success INTEGER DEFAULT 0,
                smuggle_fail INTEGER DEFAULT 0,
                bitcoin_balance NUMERIC(12,4) DEFAULT 0,
                authority_balance INTEGER DEFAULT 0,
                skill_share INTEGER DEFAULT 0,
                skill_luck INTEGER DEFAULT 0,
                skill_betray INTEGER DEFAULT 0,
                heists_joined INTEGER DEFAULT 0,
                heists_betray_attempts INTEGER DEFAULT 0,
                heists_betray_success INTEGER DEFAULT 0,
                heists_betrayed_count INTEGER DEFAULT 0,
                heists_earned NUMERIC(12,2) DEFAULT 0,
                strength INTEGER DEFAULT 1,
                agility INTEGER DEFAULT 1,
                defense INTEGER DEFAULT 1
            )
        ''')

        # –¢–∞–±–ª–∏—Ü–∞ –±–∏–∑–Ω–µ—Å–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS user_businesses (
                id SERIAL PRIMARY KEY,
                user_id BIGINT NOT NULL,
                business_type_id INTEGER NOT NULL,
                level INTEGER DEFAULT 1,
                last_collection TEXT,
                accumulated INTEGER DEFAULT 0,
                purchased_at TIMESTAMP DEFAULT NOW(),
                expires_at TIMESTAMP,
                UNIQUE(user_id, business_type_id)
            )
        ''')

        # –¢–∞–±–ª–∏—Ü–∞ —Ç–∏–ø–æ–≤ –±–∏–∑–Ω–µ—Å–æ–≤
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS business_types (
                id SERIAL PRIMARY KEY,
                name TEXT UNIQUE NOT NULL,
                emoji TEXT NOT NULL,
                base_price_btc NUMERIC(10,2) NOT NULL,
                base_income_per_hour NUMERIC(10,2) NOT NULL,
                description TEXT,
                max_level INTEGER DEFAULT 3,
                available BOOLEAN DEFAULT TRUE,
                image_key TEXT,
                lifetime_hours INTEGER DEFAULT 720
            )
        ''')

        # –¢–∞–±–ª–∏—Ü–∞ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Å—Ç–∞–≤–æ–∫
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS user_last_bets (
                user_id BIGINT,
                game TEXT,
                bet_amount NUMERIC(12,2),
                bet_data JSONB,
                updated_at TIMESTAMP DEFAULT NOW(),
                PRIMARY KEY (user_id, game)
            )
        ''')

        # –¢–∞–±–ª–∏—Ü–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã—Ö —á–∞—Ç–æ–≤
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS confirmed_chats (
                chat_id BIGINT PRIMARY KEY,
                title TEXT,
                type TEXT,
                joined_date TEXT,
                confirmed_by BIGINT,
                confirmed_date TEXT,
                notify_enabled BOOLEAN DEFAULT TRUE,
                last_gift_date DATE,
                gift_count_today INTEGER DEFAULT 0,
                auto_delete_enabled BOOLEAN DEFAULT TRUE,
                last_heist_time TEXT,
                heist_count_today INTEGER DEFAULT 0
            )
        ''')

        # –ó–∞–ø—Ä–æ—Å—ã –Ω–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —á–∞—Ç–æ–≤
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS chat_confirmation_requests (
                chat_id BIGINT PRIMARY KEY,
                title TEXT,
                type TEXT,
                requested_by BIGINT,
                request_date TEXT,
                status TEXT DEFAULT 'pending'
            )
        ''')

        # –ö–∞–Ω–∞–ª—ã –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS channels (
                id SERIAL PRIMARY KEY,
                chat_id TEXT UNIQUE,
                title TEXT,
                invite_link TEXT
            )
        ''')

        # –†–µ—Ñ–µ—Ä–∞–ª—ã
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS referrals (
                id SERIAL PRIMARY KEY,
                referrer_id BIGINT,
                referred_id BIGINT UNIQUE,
                referred_date TEXT,
                reward_given BOOLEAN DEFAULT FALSE,
                clicks INTEGER DEFAULT 0,
                active BOOLEAN DEFAULT FALSE
            )
        ''')

        # –¢–æ–≤–∞—Ä—ã –º–∞–≥–∞–∑–∏–Ω–∞
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS shop_items (
                id SERIAL PRIMARY KEY,
                name TEXT,
                description TEXT,
                price NUMERIC(12,2),
                stock INTEGER DEFAULT -1,
                photo_file_id TEXT
            )
        ''')

        # –ü–æ–∫—É–ø–∫–∏
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS purchases (
                id SERIAL PRIMARY KEY,
                user_id BIGINT,
                item_id INTEGER,
                purchase_date TEXT,
                status TEXT DEFAULT 'pending',
                admin_comment TEXT
            )
        ''')

        # –ü—Ä–æ–º–æ–∫–æ–¥—ã
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS promocodes (
                code TEXT PRIMARY KEY,
                reward NUMERIC(12,2) NOT NULL,
                reward_type TEXT NOT NULL DEFAULT 'coins' CHECK (reward_type IN ('coins', 'bitcoin')),
                max_uses INTEGER DEFAULT 1,
                used_count INTEGER DEFAULT 0,
                created_at TEXT,
                created_by BIGINT
            )
        ''')

        # –ê–∫—Ç–∏–≤–∞—Ü–∏–∏ –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS promo_activations (
                user_id BIGINT,
                promo_code TEXT,
                activated_at TEXT,
                PRIMARY KEY (user_id, promo_code)
            )
        ''')

        # –†–æ–∑—ã–≥—Ä—ã—à–∏
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS giveaways (
                id SERIAL PRIMARY KEY,
                prize TEXT,
                description TEXT,
                end_date TEXT,
                media_file_id TEXT,
                media_type TEXT,
                status TEXT DEFAULT 'active',
                winner_id BIGINT,
                winners_count INTEGER DEFAULT 1,
                winners_list TEXT,
                notified BOOLEAN DEFAULT FALSE,
                min_participants INTEGER DEFAULT 0,
                condition_type TEXT DEFAULT 'time'  -- 'time' or 'participants'
            )
        ''')

        # –£—á–∞—Å—Ç–Ω–∏–∫–∏ —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS participants (
                user_id BIGINT,
                giveaway_id INTEGER,
                PRIMARY KEY (user_id, giveaway_id)
            )
        ''')

        # –ê–¥–º–∏–Ω—ã
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS admins (
                user_id BIGINT PRIMARY KEY,
                added_by BIGINT,
                added_date TEXT,
                permissions TEXT DEFAULT '[]'
            )
        ''')

        # –ó–∞–±–∞–Ω–µ–Ω–Ω—ã–µ
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS banned_users (
                user_id BIGINT PRIMARY KEY,
                banned_by BIGINT,
                banned_date TEXT,
                reason TEXT
            )
        ''')

        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS settings (
                key TEXT PRIMARY KEY,
                value TEXT
            )
        ''')

        # –ó–∞–¥–∞–Ω–∏—è
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS tasks (
                id SERIAL PRIMARY KEY,
                name TEXT,
                description TEXT,
                task_type TEXT,
                target_id TEXT,
                reward_coins NUMERIC(12,2) DEFAULT 0,
                reward_reputation INTEGER DEFAULT 0,
                required_days INTEGER DEFAULT 0,
                penalty_days INTEGER DEFAULT 0,
                created_by BIGINT,
                created_at TEXT,
                active BOOLEAN DEFAULT TRUE,
                max_completions INTEGER DEFAULT 1,
                completed_count INTEGER DEFAULT 0,
                media_file_id TEXT,
                media_type TEXT,
                button_link TEXT
            )
        ''')

        await conn.execute('''
            CREATE TABLE IF NOT EXISTS user_tasks (
                user_id BIGINT,
                task_id INTEGER,
                completed_at TEXT,
                expires_at TEXT,
                status TEXT DEFAULT 'completed',
                PRIMARY KEY (user_id, task_id)
            )
        ''')

        # –£—Ä–æ–≤–Ω–µ–≤—ã–µ –Ω–∞–≥—Ä–∞–¥—ã
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS level_rewards (
                level INTEGER PRIMARY KEY,
                coins NUMERIC(12,2),
                reputation INTEGER
            )
        ''')

        # –ù–∞–ª—ë—Ç—ã
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS heists (
                id SERIAL PRIMARY KEY,
                chat_id BIGINT NOT NULL,
                event_type TEXT NOT NULL,
                keyword TEXT NOT NULL,
                total_pot NUMERIC(12,2) NOT NULL,
                remaining_pot NUMERIC(12,2) NOT NULL,
                btc_pot NUMERIC(12,4) DEFAULT 0,
                started_at TEXT NOT NULL,
                join_until TEXT NOT NULL,
                split_until TEXT NOT NULL,
                status TEXT DEFAULT 'joining'
            )
        ''')

        await conn.execute('''
            CREATE TABLE IF NOT EXISTS heist_participants (
                heist_id INTEGER REFERENCES heists(id) ON DELETE CASCADE,
                user_id BIGINT NOT NULL,
                base_share NUMERIC(12,2) NOT NULL,
                current_share NUMERIC(12,2) NOT NULL,
                defense_bonus INTEGER DEFAULT 0,
                joined_at TEXT NOT NULL,
                betray_choice TEXT DEFAULT NULL,
                betray_target_id BIGINT DEFAULT NULL,
                PRIMARY KEY (heist_id, user_id)
            )
        ''')

        await conn.execute('''
            CREATE TABLE IF NOT EXISTS heist_betrayals (
                id SERIAL PRIMARY KEY,
                heist_id INTEGER REFERENCES heists(id) ON DELETE CASCADE,
                attacker_id BIGINT NOT NULL,
                target_id BIGINT NOT NULL,
                success BOOLEAN NOT NULL,
                amount NUMERIC(12,2) NOT NULL,
                created_at TEXT NOT NULL
            )
        ''')

        # –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –∫—É–ª–¥–∞—É–Ω—ã
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS global_cooldowns (
                user_id BIGINT,
                command TEXT,
                last_used TIMESTAMP,
                PRIMARY KEY (user_id, command)
            )
        ''')

        # –ö–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥–Ω—ã–µ —Ä–µ–π—Å—ã
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS smuggle_runs (
                id SERIAL PRIMARY KEY,
                user_id BIGINT NOT NULL,
                chat_id BIGINT,
                start_time TEXT NOT NULL,
                end_time TEXT NOT NULL,
                status TEXT DEFAULT 'in_progress',
                result TEXT,
                smuggle_amount NUMERIC(12,4) DEFAULT 0,
                notified BOOLEAN DEFAULT FALSE
            )
        ''')

        await conn.execute('''
            CREATE TABLE IF NOT EXISTS smuggle_cooldowns (
                user_id BIGINT PRIMARY KEY,
                cooldown_until TEXT
            )
        ''')

        # –¢—é—Ä–µ–º–Ω—ã–µ —Å—Ä–æ–∫–∏
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS jail_sentences (
                id SERIAL PRIMARY KEY,
                user_id BIGINT NOT NULL,
                chat_id BIGINT,
                start_time TEXT NOT NULL,
                end_time TEXT NOT NULL,
                status TEXT DEFAULT 'serving',
                result TEXT,
                auth_gained INTEGER DEFAULT 0,
                notified BOOLEAN DEFAULT FALSE,
                cell_number INTEGER DEFAULT NULL,
                article_number INTEGER DEFAULT NULL
            )
        ''')

        # –ë–∏—Ç–∫–æ–∏–Ω-–±–∏—Ä–∂–∏
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS bitcoin_orders (
                id SERIAL PRIMARY KEY,
                user_id BIGINT NOT NULL,
                type TEXT NOT NULL CHECK (type IN ('buy', 'sell')),
                amount NUMERIC(12,4) NOT NULL CHECK (amount > 0),
                price INTEGER NOT NULL CHECK (price >= 1),
                total_locked NUMERIC(12,4) NOT NULL,
                created_at TIMESTAMP DEFAULT NOW(),
                status TEXT DEFAULT 'active' CHECK (status IN ('active', 'completed', 'cancelled'))
            )
        ''')

        await conn.execute('''
            CREATE TABLE IF NOT EXISTS bitcoin_trades (
                id SERIAL PRIMARY KEY,
                buy_order_id INTEGER REFERENCES bitcoin_orders(id),
                sell_order_id INTEGER REFERENCES bitcoin_orders(id),
                amount NUMERIC(12,4) NOT NULL,
                price INTEGER NOT NULL,
                buyer_id BIGINT NOT NULL,
                seller_id BIGINT NOT NULL,
                traded_at TIMESTAMP DEFAULT NOW()
            )
        ''')

        # –ú–µ–¥–∏–∞—Ñ–∞–π–ª—ã
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS media (
                key TEXT PRIMARY KEY,
                file_id TEXT NOT NULL,
                description TEXT,
                updated_at TIMESTAMP DEFAULT NOW()
            )
        ''')

        # –ö–ª—é—á–∏ –¥–ª—è —Å–±—Ä–æ—Å–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS reset_keys (
                key TEXT PRIMARY KEY,
                user_id BIGINT NOT NULL,
                created_at TIMESTAMP DEFAULT NOW(),
                expires_at TIMESTAMP,
                used BOOLEAN DEFAULT FALSE
            )
        ''')

        # –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_users_balance ON users(balance DESC)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_users_username_lower ON users(LOWER(username))")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_purchases_user_id ON purchases(user_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_purchases_status ON purchases(status)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_giveaways_status ON giveaways(status)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_user_tasks_expires ON user_tasks(expires_at)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_tasks_active ON tasks(active)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_referrals_referrer ON referrals(referrer_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_users_level ON users(level)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_confirmed_chats_chat ON confirmed_chats(chat_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_chat_requests_status ON chat_confirmation_requests(status)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_global_cooldowns_user ON global_cooldowns(user_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_global_cooldowns_last_used ON global_cooldowns(last_used)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_bitcoin_orders_user ON bitcoin_orders(user_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_bitcoin_orders_status ON bitcoin_orders(status)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_bitcoin_orders_type ON bitcoin_orders(type)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_smuggle_runs_user ON smuggle_runs(user_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_smuggle_runs_end ON smuggle_runs(end_time)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_user_businesses_user ON user_businesses(user_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_user_businesses_expires ON user_businesses(expires_at)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_heists_chat_status ON heists(chat_id, status)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_heists_join_until ON heists(join_until)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_heists_split_until ON heists(split_until)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_heist_participants_heist ON heist_participants(heist_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_heist_betrayals_heist ON heist_betrayals(heist_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_heist_participants_user ON heist_participants(user_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_jail_sentences_user ON jail_sentences(user_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_jail_sentences_end ON jail_sentences(end_time)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_bitcoin_orders_price ON bitcoin_orders(price, status)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_bitcoin_orders_created ON bitcoin_orders(created_at)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_reset_keys_expires ON reset_keys(expires_at)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_reset_keys_user ON reset_keys(user_id)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_users_reputation ON users(reputation DESC)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_users_bitcoin_balance ON users(bitcoin_balance DESC)")
        await conn.execute("CREATE INDEX IF NOT EXISTS idx_users_level_desc ON users(level DESC)")

    await init_settings()
    await init_level_rewards()
    await init_business_types()
    await init_media_keys()

    logging.info("‚úÖ –¢–∞–±–ª–∏—Ü—ã –≤ PostgreSQL –ø—Ä–æ–≤–µ—Ä–µ–Ω—ã/–æ–±–Ω–æ–≤–ª–µ–Ω—ã")

@db_retry()
async def init_settings():
    async with db_pool.acquire() as conn:
        for key, value in DEFAULT_SETTINGS.items():
            await conn.execute(
                "INSERT INTO settings (key, value) VALUES ($1, $2) ON CONFLICT (key) DO NOTHING",
                key, value
            )

@db_retry()
async def init_level_rewards():
    async with db_pool.acquire() as conn:
        for lvl in range(1, 101):
            exists = await conn.fetchval("SELECT level FROM level_rewards WHERE level=$1", lvl)
            if not exists:
                coins = int(DEFAULT_SETTINGS["level_reward_coins"]) + (lvl-1) * int(DEFAULT_SETTINGS["level_reward_coins_increment"])
                rep = int(DEFAULT_SETTINGS["level_reward_reputation"]) + (lvl-1) * int(DEFAULT_SETTINGS["level_reward_reputation_increment"])
                await conn.execute(
                    "INSERT INTO level_rewards (level, coins, reputation) VALUES ($1, $2, $3)",
                    lvl, float(coins), rep
                )

@db_retry()
async def init_business_types():
    async with db_pool.acquire() as conn:
        for biz in BUSINESS_TYPES:
            await conn.execute(
                """INSERT INTO business_types 
                   (id, name, emoji, base_price_btc, base_income_per_hour, description, max_level, available, image_key, lifetime_hours) 
                   VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                   ON CONFLICT (id) DO UPDATE SET
                   name = EXCLUDED.name,
                   emoji = EXCLUDED.emoji,
                   base_price_btc = EXCLUDED.base_price_btc,
                   base_income_per_hour = EXCLUDED.base_income_per_hour,
                   description = EXCLUDED.description,
                   max_level = EXCLUDED.max_level,
                   available = EXCLUDED.available,
                   image_key = EXCLUDED.image_key,
                   lifetime_hours = EXCLUDED.lifetime_hours""",
                biz["id"], biz["name"], biz["emoji"], biz["base_price_btc"], 
                biz["base_income_per_hour"], biz["description"], biz["max_level"], 
                True, biz.get("image_key"), biz.get("lifetime_hours", 720)
            )

@db_retry()
async def init_media_keys():
    async with db_pool.acquire() as conn:
        for key in MEDIA_KEYS:
            await conn.execute(
                "INSERT INTO media (key, file_id, description) VALUES ($1, $2, $3) ON CONFLICT (key) DO NOTHING",
                key, "", f"–ú–µ–¥–∏–∞ –¥–ª—è {key}"
            )

# ==================== –†–ê–ë–û–¢–ê –° –ù–ê–°–¢–†–û–ô–ö–ê–ú–ò ====================
@db_retry()
async def get_setting(key: str) -> str:
    global settings_cache, last_settings_update
    now = time.time()
    if now - last_settings_update > 60 or not settings_cache:
        async with db_pool.acquire() as conn:
            rows = await conn.fetch("SELECT key, value FROM settings")
            settings_cache = {row['key']: row['value'] for row in rows}
        last_settings_update = now
    value = settings_cache.get(key)
    if value is None:
        value = DEFAULT_SETTINGS.get(key, "")
        if value:
            async with db_pool.acquire() as conn:
                await conn.execute(
                    "INSERT INTO settings (key, value) VALUES ($1, $2) ON CONFLICT (key) DO NOTHING",
                    key, value
                )
            settings_cache[key] = value
    return value

async def get_setting_float(key: str) -> float:
    val = await get_setting(key)
    try:
        return float(val)
    except:
        return 0.0

async def get_setting_int(key: str) -> int:
    val = await get_setting(key)
    try:
        return int(val)
    except:
        return 0

@db_retry()
async def set_setting(key: str, value: str):
    async with db_pool.acquire() as conn:
        await conn.execute("UPDATE settings SET value=$1 WHERE key=$2", value, key)
    settings_cache[key] = value
    global last_settings_update
    last_settings_update = 0

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ß–ê–¢–û–í –ò –ö–ê–ù–ê–õ–û–í ====================
@db_retry()
async def get_channels():
    global channels_cache, last_channels_update
    now = time.time()
    if now - last_channels_update > 300 or not channels_cache:
        async with db_pool.acquire() as conn:
            rows = await conn.fetch("SELECT chat_id, title, invite_link FROM channels")
            channels_cache = [(r['chat_id'], r['title'], r['invite_link']) for r in rows]
        last_channels_update = now
    return channels_cache

@db_retry()
async def get_confirmed_chats(force_update=False) -> Dict[int, dict]:
    global confirmed_chats_cache, last_confirmed_chats_update
    now = time.time()
    if force_update or now - last_confirmed_chats_update > 300 or not confirmed_chats_cache:
        async with db_pool.acquire() as conn:
            rows = await conn.fetch("SELECT * FROM confirmed_chats")
            confirmed_chats_cache = {row['chat_id']: dict(row) for row in rows}
        last_confirmed_chats_update = now
    return confirmed_chats_cache

async def is_chat_confirmed(chat_id: int) -> bool:
    confirmed = await get_confirmed_chats()
    return chat_id in confirmed

@db_retry()
async def add_confirmed_chat(chat_id: int, title: str, chat_type: str, confirmed_by: int):
    async with db_pool.acquire() as conn:
        await conn.execute(
            "INSERT INTO confirmed_chats (chat_id, title, type, joined_date, confirmed_by, confirmed_date) VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT (chat_id) DO UPDATE SET confirmed_by=$5, confirmed_date=$6",
            chat_id, title, chat_type, datetime.now().strftime("%Y-%m-%d %H:%M:%S"), confirmed_by, datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        )
    await get_confirmed_chats(force_update=True)

@db_retry()
async def remove_confirmed_chat(chat_id: int):
    async with db_pool.acquire() as conn:
        await conn.execute("DELETE FROM confirmed_chats WHERE chat_id=$1", chat_id)
    await get_confirmed_chats(force_update=True)

@db_retry()
async def create_chat_confirmation_request(chat_id: int, title: str, chat_type: str, requested_by: int):
    async with db_pool.acquire() as conn:
        await conn.execute(
            "INSERT INTO chat_confirmation_requests (chat_id, title, type, requested_by, request_date, status) VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT (chat_id) DO UPDATE SET status='pending', requested_by=$4, request_date=$5",
            chat_id, title, chat_type, requested_by, datetime.now().strftime("%Y-%m-%d %H:%M:%S"), 'pending'
        )

@db_retry()
async def get_pending_chat_requests() -> List[dict]:
    async with db_pool.acquire() as conn:
        rows = await conn.fetch("SELECT * FROM chat_confirmation_requests WHERE status='pending' ORDER BY request_date")
        return [dict(r) for r in rows]

@db_retry()
async def update_chat_request_status(chat_id: int, status: str):
    async with db_pool.acquire() as conn:
        await conn.execute("UPDATE chat_confirmation_requests SET status=$1 WHERE chat_id=$2", status, chat_id)

# ==================== –ü–†–û–í–ï–†–ö–ê –ü–û–î–ü–ò–°–ö–ò ====================
async def check_subscription(user_id: int):
    channels = await get_channels()
    if not channels:
        return True, []
    not_subscribed = []
    for chat_id, title, link in channels:
        try:
            member = await bot.get_chat_member(chat_id=chat_id, user_id=user_id)
            if member.status in ['left', 'kicked']:
                not_subscribed.append((title, link))
        except Exception:
            not_subscribed.append((title, link))
    return len(not_subscribed) == 0, not_subscribed

# ==================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ====================
def progress_bar(current, total, length=10):
    if total <= 0:
        return "‚¨ú" * length
    filled = int(current / total * length)
    return "üü©" * filled + "‚¨ú" * (length - filled)

def format_time_remaining(seconds: int) -> str:
    if seconds < 60:
        return f"{seconds} —Å–µ–∫"
    minutes = seconds // 60
    if minutes < 60:
        return f"{minutes} –º–∏–Ω"
    hours = minutes // 60
    minutes %= 60
    if minutes == 0:
        return f"{hours} —á"
    return f"{hours} —á {minutes} –º–∏–Ω"

def get_random_phrase(phrase_list: List[str], **kwargs) -> str:
    if not phrase_list:
        return ""
    phrase = random.choice(phrase_list)
    return phrase.format(**kwargs)

async def notify_chats(message_text: str):
    confirmed = await get_confirmed_chats()
    for chat_id, data in confirmed.items():
        if not data.get('notify_enabled', True):
            continue
        await safe_send_chat(chat_id, message_text)

@db_retry()
async def is_banned(user_id: int) -> bool:
    async with db_pool.acquire() as conn:
        row = await conn.fetchval("SELECT user_id FROM banned_users WHERE user_id=$1", user_id)
    return row is not None

@db_retry()
async def find_user_by_input(input_str: str) -> Optional[Dict]:
    input_str = input_str.strip()
    try:
        uid = int(input_str)
        async with db_pool.acquire() as conn:
            row = await conn.fetchrow("SELECT * FROM users WHERE user_id=$1", uid)
            return dict(row) if row else None
    except ValueError:
        username = input_str.lower()
        if username.startswith('@'):
            username = username[1:]
        async with db_pool.acquire() as conn:
            row = await conn.fetchrow("SELECT * FROM users WHERE LOWER(username)=$1", username)
            return dict(row) if row else None

async def get_media_file_id(key: str) -> Optional[str]:
    if redis_client:
        cached = await redis_get(f"media:{key}")
        if cached:
            return cached
    async with db_pool.acquire() as conn:
        file_id = await conn.fetchval("SELECT file_id FROM media WHERE key=$1", key)
        if file_id and redis_client:
            await redis_set(f"media:{key}", file_id, 3600)
        return file_id

@db_retry()
async def set_media_file_id(key: str, file_id: str, description: str = ""):
    async with db_pool.acquire() as conn:
        await conn.execute(
            "INSERT INTO media (key, file_id, description) VALUES ($1, $2, $3) ON CONFLICT (key) DO UPDATE SET file_id=$2, description=$3, updated_at=NOW()",
            key, file_id, description
        )
    if redis_client:
        await redis_set(f"media:{key}", file_id, 3600)

async def send_with_media(chat_id: int, text: str, media_key: str = None, **kwargs):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–∞—Ä—Ç–∏–Ω–∫–æ–π –∏–∑ –º–µ–¥–∏–∞-—Ç–∞–±–ª–∏—Ü—ã, –µ—Å–ª–∏ –∫–ª—é—á –Ω–∞–π–¥–µ–Ω."""
    if media_key:
        file_id = await get_media_file_id(media_key)
        if file_id:
            try:
                await bot.send_photo(chat_id, file_id, caption=text, **kwargs)
                return
            except Exception as e:
                logging.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–æ—Ç–æ —Å –∫–ª—é—á–æ–º {media_key}: {e}")
    await safe_send_message(chat_id, text, **kwargs)

@db_retry()
async def save_last_bet(user_id: int, game: str, amount: float, bet_data: dict = None):
    async with db_pool.acquire() as conn:
        await conn.execute("""
            INSERT INTO user_last_bets (user_id, game, bet_amount, bet_data, updated_at)
            VALUES ($1, $2, $3, $4, NOW())
            ON CONFLICT (user_id, game) DO UPDATE SET
                bet_amount = EXCLUDED.bet_amount,
                bet_data = EXCLUDED.bet_data,
                updated_at = NOW()
        """, user_id, game, amount, json.dumps(bet_data) if bet_data else None)

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ï–ô ====================
@db_retry()
async def ensure_user_exists(user_id: int, username: str = None, first_name: str = None):
    async with db_pool.acquire() as conn:
        exists = await conn.fetchval("SELECT 1 FROM users WHERE user_id=$1", user_id)
        if not exists:
            bonus = await get_setting_float("new_user_bonus")
            await conn.execute(
                "INSERT INTO users (user_id, username, first_name, joined_date, balance, reputation, total_spent, negative_balance, exp, level, bitcoin_balance, authority_balance, skill_share, skill_luck, skill_betray) "
                "VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)",
                user_id, username, first_name, datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                bonus, 0, 0, 0, 0, 1, 0.0, 0, 0, 0, 0
            )
            return True, bonus
    return False, 0

@db_retry()
async def get_user_balance(user_id: int) -> float:
    async with db_pool.acquire() as conn:
        balance = await conn.fetchval("SELECT balance FROM users WHERE user_id=$1", user_id)
        return float(balance) if balance is not None else 0.0

@db_retry()
async def update_user_balance(user_id: int, delta: float, conn=None):
    delta = float(delta)
    async def _update(conn):
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–∞—É—Ç –Ω–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
        await conn.execute("SET LOCAL statement_timeout = '5s'")
        row = await conn.fetchrow("SELECT balance, negative_balance FROM users WHERE user_id=$1 FOR UPDATE", user_id)
        if not row:
            await ensure_user_exists(user_id)
            row = {'balance': 0.0, 'negative_balance': 0.0}
        balance = float(row['balance'])
        negative = float(row['negative_balance']) if row['negative_balance'] else 0.0

        new_balance = balance + delta
        if new_balance < 0:
            negative += abs(new_balance)
            new_balance = 0.0
        new_balance = round(new_balance, 2)
        negative = round(negative, 2)
        await conn.execute(
            "UPDATE users SET balance=$1, negative_balance=$2 WHERE user_id=$3",
            new_balance, negative, user_id
        )
    if conn:
        await _update(conn)
    else:
        async with db_pool.acquire() as new_conn:
            async with new_conn.transaction():
                await _update(new_conn)

@db_retry()
async def get_user_bitcoin(user_id: int) -> float:
    async with db_pool.acquire() as conn:
        btc = await conn.fetchval("SELECT bitcoin_balance FROM users WHERE user_id=$1", user_id)
        return float(btc) if btc is not None else 0.0

@db_retry()
async def update_user_bitcoin(user_id: int, delta: float, conn=None):
    delta = float(delta)
    async def _update(conn):
        await conn.execute("SET LOCAL statement_timeout = '5s'")
        row = await conn.fetchrow("SELECT bitcoin_balance FROM users WHERE user_id=$1 FOR UPDATE", user_id)
        if not row:
            await ensure_user_exists(user_id)
            row = {'bitcoin_balance': 0.0}
        current = float(row['bitcoin_balance'])
        new_balance = current + delta
        if new_balance < 0:
            raise ValueError("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∏—Ç–∫–æ–∏–Ω–æ–≤")
        new_balance = round(new_balance, 4)
        await conn.execute(
            "UPDATE users SET bitcoin_balance=$1 WHERE user_id=$2",
            new_balance, user_id
        )
    if conn:
        await _update(conn)
    else:
        async with db_pool.acquire() as new_conn:
            async with new_conn.transaction():
                await _update(new_conn)

@db_retry()
async def get_user_authority(user_id: int) -> int:
    async with db_pool.acquire() as conn:
        auth = await conn.fetchval("SELECT authority_balance FROM users WHERE user_id=$1", user_id)
        return auth if auth is not None else 0

@db_retry()
async def update_user_authority(user_id: int, delta: int, conn=None):
    async def _update(conn):
        await conn.execute(
            "UPDATE users SET authority_balance = authority_balance + $1 WHERE user_id=$2",
            delta, user_id
        )
    if conn:
        await _update(conn)
    else:
        async with db_pool.acquire() as new_conn:
            await _update(new_conn)

@db_retry()
async def get_user_reputation(user_id: int) -> int:
    async with db_pool.acquire() as conn:
        rep = await conn.fetchval("SELECT reputation FROM users WHERE user_id=$1", user_id)
        return rep if rep is not None else 0

@db_retry()
async def update_user_reputation(user_id: int, delta: int):
    async with db_pool.acquire() as conn:
        await conn.execute("UPDATE users SET reputation = reputation + $1 WHERE user_id=$2", delta, user_id)

@db_retry()
async def get_user_skills(user_id: int) -> dict:
    async with db_pool.acquire() as conn:
        row = await conn.fetchrow(
            "SELECT skill_share, skill_luck, skill_betray FROM users WHERE user_id=$1",
            user_id
        )
        if row:
            return dict(row)
        return {'skill_share': 0, 'skill_luck': 0, 'skill_betray': 0}

@db_retry()
async def update_user_skill(user_id: int, skill: str, delta: int = 1, conn=None):
    allowed = ['skill_share', 'skill_luck', 'skill_betray']
    if skill not in allowed:
        raise ValueError("Invalid skill")
    async def _update(conn):
        await conn.execute(f"UPDATE users SET {skill} = {skill} + $1 WHERE user_id=$2", delta, user_id)
    if conn:
        await _update(conn)
    else:
        async with db_pool.acquire() as conn2:
            await _update(conn2)

@db_retry()
async def get_user_stats(user_id: int) -> dict:
    async with db_pool.acquire() as conn:
        row = await conn.fetchrow("SELECT level, exp, strength, agility, defense FROM users WHERE user_id=$1", user_id)
        if row:
            return dict(row)
        return {'level': 1, 'exp': 0, 'strength': 1, 'agility': 1, 'defense': 1}

@db_retry()
async def update_user_game_stats(user_id: int, game: str, win: bool, conn=None):
    async def _update(conn):
        if win:
            if game == 'dice':
                await conn.execute("UPDATE users SET dice_wins = dice_wins + 1 WHERE user_id=$1", user_id)
            elif game == 'guess':
                await conn.execute("UPDATE users SET guess_wins = guess_wins + 1 WHERE user_id=$1", user_id)
            elif game == 'slots':
                await conn.execute("UPDATE users SET slots_wins = slots_wins + 1 WHERE user_id=$1", user_id)
            elif game == 'roulette':
                await conn.execute("UPDATE users SET roulette_wins = roulette_wins + 1 WHERE user_id=$1", user_id)
        else:
            if game == 'dice':
                await conn.execute("UPDATE users SET dice_losses = dice_losses + 1 WHERE user_id=$1", user_id)
            elif game == 'guess':
                await conn.execute("UPDATE users SET guess_losses = guess_losses + 1 WHERE user_id=$1", user_id)
            elif game == 'slots':
                await conn.execute("UPDATE users SET slots_losses = slots_losses + 1 WHERE user_id=$1", user_id)
            elif game == 'roulette':
                await conn.execute("UPDATE users SET roulette_losses = roulette_losses + 1 WHERE user_id=$1", user_id)
    if conn:
        await _update(conn)
    else:
        async with db_pool.acquire() as new_conn:
            await _update(new_conn)

@db_retry()
async def add_exp(user_id: int, exp: int, conn=None):
    async def _add(conn):
        await conn.execute("SET LOCAL statement_timeout = '5s'")
        user = await conn.fetchrow("SELECT exp, level FROM users WHERE user_id=$1 FOR UPDATE", user_id)
        if not user:
            return
        new_exp = user['exp'] + exp
        level = user['level']
        level_mult = await get_setting_int("level_multiplier")
        levels_gained = 0
        rewards = []
        while new_exp >= level * level_mult and level < 100:
            new_exp -= level * level_mult
            level += 1
            levels_gained += 1
            rewards.append(level)
        await conn.execute(
            "UPDATE users SET exp=$1, level=$2 WHERE user_id=$3",
            new_exp, level, user_id
        )
        if levels_gained > 0:
            str_inc = await get_setting_int("stat_strength_per_level") * levels_gained
            agi_inc = await get_setting_int("stat_agility_per_level") * levels_gained
            def_inc = await get_setting_int("stat_defense_per_level") * levels_gained
            await conn.execute(
                "UPDATE users SET strength = strength + $1, agility = agility + $2, defense = defense + $3 WHERE user_id=$4",
                str_inc, agi_inc, def_inc, user_id
            )
            reward_summary = []
            for lvl in rewards:
                reward = await conn.fetchrow(
                    "SELECT coins, reputation FROM level_rewards WHERE level=$1",
                    lvl
                )
                if reward:
                    reward_summary.append(f"–£—Ä–æ–≤–µ–Ω—å {lvl}: +{float(reward['coins']):.2f} –±–∞–∫—Å–æ–≤, +{reward['reputation']} —Ä–µ–ø—É—Ç–∞—Ü–∏–∏")
            if reward_summary:
                await safe_send_message(
                    user_id,
                    f"üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –¢—ã –¥–æ—Å—Ç–∏–≥ –Ω–æ–≤—ã—Ö —É—Ä–æ–≤–Ω–µ–π!\n" + "\n".join(reward_summary) +
                    f"\n–¢–≤–æ–∏ —Å—Ç–∞—Ç—ã —É–≤–µ–ª–∏—á–µ–Ω—ã: —Å–∏–ª–∞ +{str_inc}, –ª–æ–≤–∫–æ—Å—Ç—å +{agi_inc}, –∑–∞—â–∏—Ç–∞ +{def_inc}."
                )
    if conn:
        await _add(conn)
    else:
        async with db_pool.acquire() as conn2:
            async with conn2.transaction():
                await _add(conn2)

async def get_user_level(user_id: int) -> int:
    return (await get_user_stats(user_id))['level']

async def get_user_exp(user_id: int) -> int:
    return (await get_user_stats(user_id))['exp']

@db_retry()
async def update_user_total_spent(user_id: int, amount: float):
    async with db_pool.acquire() as conn:
        await conn.execute("UPDATE users SET total_spent = total_spent + $1 WHERE user_id=$2", amount, user_id)

@db_retry()
async def get_random_user(exclude_id: int):
    async with db_pool.acquire() as conn:
        row = await conn.fetchrow("""
            SELECT user_id FROM users 
            WHERE user_id != $1 AND user_id NOT IN (SELECT user_id FROM banned_users)
            ORDER BY random() LIMIT 1
        """, exclude_id)
        return row['user_id'] if row else None

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ì–õ–û–ë–ê–õ–¨–ù–û–ì–û –ö–£–õ–î–ê–£–ù–ê ====================
@db_retry()
async def check_global_cooldown(user_id: int, command: str, cooldown_seconds: int = None) -> Tuple[bool, int]:
    if cooldown_seconds is None:
        cooldown_seconds = await get_setting_int("global_cooldown_seconds")
    async with db_pool.acquire() as conn:
        row = await conn.fetchrow("SELECT last_used FROM global_cooldowns WHERE user_id=$1 AND command=$2", user_id, command)
        if row and row['last_used']:
            diff = datetime.now() - row['last_used']
            remaining = cooldown_seconds - diff.total_seconds()
            if remaining > 0:
                return False, int(remaining)
    return True, 0

@db_retry()
async def set_global_cooldown(user_id: int, command: str, cooldown_seconds: int = None):
    if cooldown_seconds is None:
        cooldown_seconds = await get_setting_int("global_cooldown_seconds")
    async with db_pool.acquire() as conn:
        await conn.execute('''
            INSERT INTO global_cooldowns (user_id, command, last_used)
            VALUES ($1, $2, $3)
            ON CONFLICT (user_id, command) DO UPDATE SET last_used = $3
        ''', user_id, command, datetime.now())

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ë–ò–ó–ù–ï–°–û–í ====================
@db_retry()
async def get_business_type_list(only_available: bool = True) -> List[dict]:
    async with db_pool.acquire() as conn:
        if only_available:
            rows = await conn.fetch("SELECT * FROM business_types WHERE available = TRUE ORDER BY base_price_btc")
        else:
            rows = await conn.fetch("SELECT * FROM business_types ORDER BY base_price_btc")
        result = []
        for r in rows:
            d = dict(r)
            d['base_price_btc'] = float(d['base_price_btc'])
            d['base_income_per_hour'] = float(d['base_income_per_hour'])
            result.append(d)
        return result

@db_retry()
async def get_business_type(business_type_id: int) -> Optional[dict]:
    async with db_pool.acquire() as conn:
        row = await conn.fetchrow("SELECT * FROM business_types WHERE id=$1", business_type_id)
        if row:
            d = dict(row)
            d['base_price_btc'] = float(d['base_price_btc'])
            d['base_income_per_hour'] = float(d['base_income_per_hour'])
            return d
        return None

@db_retry()
async def get_user_businesses(user_id: int) -> List[dict]:
    async with db_pool.acquire() as conn:
        rows = await conn.fetch("""
            SELECT ub.*, bt.name, bt.emoji, bt.base_price_btc, bt.base_income_per_hour, bt.max_level, bt.image_key, bt.lifetime_hours
            FROM user_businesses ub
            JOIN business_types bt ON ub.business_type_id = bt.id
            WHERE ub.user_id = $1
            ORDER BY bt.base_price_btc
        """, user_id)
        result = []
        for r in rows:
            d = dict(r)
            d['base_price_btc'] = float(d['base_price_btc'])
            d['base_income_per_hour'] = float(d['base_income_per_hour'])
            result.append(d)
        return result

@db_retry()
async def get_user_business(user_id: int, business_type_id: int) -> Optional[dict]:
    async with db_pool.acquire() as conn:
        row = await conn.fetchrow("""
            SELECT ub.*, bt.name, bt.emoji, bt.base_price_btc, bt.base_income_per_hour, bt.max_level, bt.image_key
            FROM user_businesses ub
            JOIN business_types bt ON ub.business_type_id = bt.id
            WHERE ub.user_id = $1 AND ub.business_type_id = $2
        """, user_id, business_type_id)
        if row:
            d = dict(row)
            d['base_price_btc'] = float(d['base_price_btc'])
            d['base_income_per_hour'] = float(d['base_income_per_hour'])
            return d
        return None

async def get_business_price(business_type: dict, level: int) -> float:
    base_price = business_type['base_price_btc']
    if level == 1:
        return base_price
    else:
        upgrade_base = await get_setting_float("business_upgrade_cost_per_level")
        cost = base_price + upgrade_base * (level ** 1.5)
        return round(cost, 2)

async def get_business_income(business_type: dict, level: int) -> float:
    return business_type['base_income_per_hour'] * level

@db_retry()
async def create_user_business(user_id: int, business_type_id: int, lifetime_hours: int):
    async with db_pool.acquire() as conn:
        now = datetime.now()
        expires_at = now + timedelta(hours=lifetime_hours) if lifetime_hours > 0 else None
        await conn.execute(
            "INSERT INTO user_businesses (user_id, business_type_id, level, last_collection, purchased_at, expires_at) VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT (user_id, business_type_id) DO NOTHING",
            user_id, business_type_id, 1, now.strftime("%Y-%m-%d %H:%M:%S"), now, expires_at
        )

@db_retry()
async def collect_business_income(user_id: int, business_id: int) -> Tuple[bool, str, float]:
    async with db_pool.acquire() as conn:
        async with conn.transaction():
            await conn.execute("SET LOCAL statement_timeout = '5s'")
            biz = await conn.fetchrow("SELECT * FROM user_businesses WHERE id=$1 AND user_id=$2 FOR UPDATE", business_id, user_id)
            if not biz:
                return False, "‚ùå –ë–∏–∑–Ω–µ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω.", 0
            last_col = biz['last_collection']
            if last_col:
                try:
                    last_date = datetime.strptime(last_col, "%Y-%m-%d %H:%M:%S")
                except:
                    last_date = datetime.now() - timedelta(days=365)
            else:
                last_date = datetime.now() - timedelta(days=365)
            now = datetime.now()
            minutes_passed = int((now - last_date).total_seconds() / 60)

            collect_interval = await get_setting_int("business_collect_interval_minutes")
            if minutes_passed < collect_interval:
                next_collect = last_date + timedelta(minutes=collect_interval)
                wait_minutes = int((next_collect - now).total_seconds() / 60)
                return False, f"‚è≥ –°–ª–µ–¥—É—é—â–∏–π —Å–±–æ—Ä —á–µ—Ä–µ–∑ {wait_minutes} –º–∏–Ω.", 0

            max_storage_hours = await get_setting_int("business_max_storage_hours")
            max_storage_minutes = max_storage_hours * 60
            collectable_minutes = min(minutes_passed, max_storage_minutes)

            biz_type = await conn.fetchrow("SELECT * FROM business_types WHERE id = (SELECT business_type_id FROM user_businesses WHERE id=$1)", business_id)
            if not biz_type:
                return False, "‚ùå –¢–∏–ø –±–∏–∑–Ω–µ—Å–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω.", 0
            income_per_hour = float(biz_type['base_income_per_hour']) * biz['level']
            income = income_per_hour * (collectable_minutes / 60)
            income = round(income, 2)

            if income <= 0:
                return False, "‚ùå –î–æ—Ö–æ–¥ –µ—â—ë –Ω–µ –Ω–∞–∫–æ–ø–∏–ª—Å—è.", 0

            await update_user_balance(user_id, income, conn=conn)
            await conn.execute(
                "UPDATE user_businesses SET last_collection=$1 WHERE id=$2",
                now.strftime("%Y-%m-%d %H:%M:%S"), business_id
            )
            return True, f"üí∞ –°–æ–±—Ä–∞–Ω–æ {income} –±–∞–∫—Å–æ–≤ —Å –±–∏–∑–Ω–µ—Å–∞ {biz_type['emoji']} {biz_type['name']}!", income

@db_retry()
async def upgrade_business(user_id: int, business_id: int) -> Tuple[bool, str]:
    async with db_pool.acquire() as conn:
        async with conn.transaction():
            await conn.execute("SET LOCAL statement_timeout = '5s'")
            biz = await conn.fetchrow("""
                SELECT ub.*, bt.base_price_btc, bt.base_income_per_hour, bt.max_level, bt.emoji, bt.name
                FROM user_businesses ub 
                JOIN business_types bt ON ub.business_type_id = bt.id 
                WHERE ub.id=$1 AND ub.user_id=$2
            """, business_id, user_id)
            if not biz:
                return False, "‚ùå –ë–∏–∑–Ω–µ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω."
            if biz['level'] >= biz['max_level']:
                return False, f"‚ùå –ë–∏–∑–Ω–µ—Å —É–∂–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è ({biz['max_level']})."
            
            await collect_business_income(user_id, business_id)

            base_price = float(biz['base_price_btc'])
            cost = await get_business_price({'base_price_btc': base_price}, biz['level'] + 1)
            btc_balance = await get_user_bitcoin(user_id)
            if btc_balance < cost - 0.0001:
                return False, f"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∏—Ç–∫–æ–∏–Ω–æ–≤. –ù—É–∂–Ω–æ {cost:.2f} BTC, —É –≤–∞—Å {btc_balance:.4f}."
            await update_user_bitcoin(user_id, -cost, conn=conn)
            await conn.execute(
                "UPDATE user_businesses SET level = level + 1 WHERE id=$1",
                business_id
            )
            return True, f"‚úÖ –ë–∏–∑–Ω–µ—Å {biz['emoji']} {biz['name']} —É–ª—É—á—à–µ–Ω –¥–æ —É—Ä–æ–≤–Ω—è {biz['level'] + 1}! –ü–æ—Ç—Ä–∞—á–µ–Ω–æ {cost:.2f} BTC."

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ù–ê–õ–Å–¢–û–í ====================
@db_retry()
async def spawn_heist(chat_id: int):
    """–°–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—ã–π –Ω–∞–ª—ë—Ç –≤ —á–∞—Ç–µ."""
    heist_type = random.choice(list(HEIST_TYPES.keys()))
    config = HEIST_TYPES[heist_type]
    keyword = config['keyword']
    join_minutes = await get_setting_int("heist_join_minutes")
    split_minutes = await get_setting_int("heist_split_minutes")
    now = datetime.now()
    join_until = now + timedelta(minutes=join_minutes)
    split_until = join_until + timedelta(minutes=split_minutes)

    total_pot = 0
    btc_pot = 0

    async with db_pool.acquire() as conn:
        heist_id = await conn.fetchval(
            "INSERT INTO heists (chat_id, event_type, keyword, total_pot, remaining_pot, btc_pot, started_at, join_until, split_until, status) "
            "VALUES ($1, $2, $3, $4, $4, $5, $6, $7, $8, $9) RETURNING id",
            chat_id, heist_type, keyword, total_pot, btc_pot,
            now.strftime("%Y-%m-%d %H:%M:%S"),
            join_until.strftime("%Y-%m-%d %H:%M:%S"),
            split_until.strftime("%Y-%m-%d %H:%M:%S"),
            'joining'
        )
    text = get_random_phrase(config['phrases_start'], minutes=join_minutes)
    text += f"\n\nüìù –ß—Ç–æ–±—ã —É—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å, –Ω–∞–ø–∏—à–∏ **{keyword}** –≤ —Ç–µ—á–µ–Ω–∏–µ {join_minutes} –º–∏–Ω—É—Ç!"
    
    media_key = f"heist_{heist_type}"
    file_id = await get_media_file_id(media_key)
    if file_id:
        await bot.send_photo(chat_id, file_id, caption=text)
    else:
        await safe_send_chat(chat_id, text)
    asyncio.create_task(finish_heist_joining(heist_id, join_until))

async def finish_heist_joining(heist_id: int, join_until: datetime):
    """–ó–∞–≤–µ—Ä—à–∞–µ—Ç —ç—Ç–∞–ø —Å–±–æ—Ä–∞ –∏ –∑–∞–ø—É—Å–∫–∞–µ—Ç —ç—Ç–∞–ø —Ä–∞—Å–ø–∏–ª–∞."""
    delay = max(0, (join_until - datetime.now()).total_seconds())
    await asyncio.sleep(delay)
    async with db_pool.acquire() as conn:
        heist = await conn.fetchrow("SELECT * FROM heists WHERE id=$1 AND status='joining'", heist_id)
        if not heist:
            return
        await conn.execute(
            "UPDATE heists SET status='splitting' WHERE id=$1",
            heist_id
        )
        participants = await conn.fetch("SELECT user_id FROM heist_participants WHERE heist_id=$1", heist_id)
        if not participants:
            await conn.execute("UPDATE heists SET status='finished' WHERE id=$1", heist_id)
            await safe_send_chat(heist['chat_id'], "‚ùå –ù–∏–∫—Ç–æ –Ω–µ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ –Ω–∞–ª—ë—Ç—É. –û–Ω –æ—Ç–º–µ–Ω—ë–Ω.")
            return

        config = HEIST_TYPES[heist['event_type']]
        split_minutes = await get_setting_int("heist_split_minutes")
        text = get_random_phrase(config.get('phrases_split', ["üî™ –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Ä–∞—Å–ø–∏–ª! –£ —Ç–µ–±—è {minutes} –º–∏–Ω—É—Ç."]), minutes=split_minutes)
        await safe_send_chat(heist['chat_id'], text)

        split_until = datetime.strptime(heist['split_until'], "%Y-%m-%d %H:%M:%S")
        await ask_betray_choice(heist_id, split_until)

async def ask_betray_choice(heist_id: int, split_until: datetime):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∫–∞–∂–¥–æ–º—É —É—á–∞—Å—Ç–Ω–∏–∫—É –Ω–∞–ª—ë—Ç–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –≤—ã–±–æ—Ä–æ–º: —É–∫—Ä–∞—Å—Ç—å –∏–ª–∏ –æ—Ç–∫–∞–∑–∞—Ç—å—Å—è."""
    async with db_pool.acquire() as conn:
        participants = await conn.fetch("SELECT user_id FROM heist_participants WHERE heist_id=$1", heist_id)
        if not participants:
            return
        for p in participants:
            user_id = p['user_id']
            kb = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="üî™ –£–∫—Ä–∞—Å—Ç—å —É –ø–æ–¥–µ–ª—å–Ω–∏–∫–æ–≤", callback_data=f"betray_choice_yes_{heist_id}")],
                [InlineKeyboardButton(text="‚ùå –û—Ç–∫–∞–∑–∞—Ç—å—Å—è", callback_data=f"betray_choice_no_{heist_id}")]
            ])
            await safe_send_message(user_id,
                "üî™ –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Ä–∞—Å–ø–∏–ª! –¢—ã –º–æ–∂–µ—à—å –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è —É–∫—Ä–∞—Å—Ç—å —á–∞—Å—Ç—å –¥–æ–±—ã—á–∏ —É –¥—Ä—É–≥–∏—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.\n"
                "–ï—Å–ª–∏ –æ—Ç–∫–∞–∂–µ—à—å—Å—è, –æ—Å—Ç–∞–Ω–µ—à—å—Å—è —Å–æ —Å–≤–æ–µ–π –¥–æ–ª–µ–π, –Ω–æ –º–æ–∂–µ—à—å —Å—Ç–∞—Ç—å –∂–µ—Ä—Ç–≤–æ–π.\n"
                "–£ —Ç–µ–±—è –µ—Å—Ç—å 5 –º–∏–Ω—É—Ç –Ω–∞ –≤—ã–±–æ—Ä.",
                reply_markup=kb
            )
    asyncio.create_task(process_betray_results(heist_id, split_until))

async def process_betray_results(heist_id: int, split_until: datetime):
    """–°–æ–±–∏—Ä–∞–µ—Ç –æ—Ç–≤–µ—Ç—ã —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –∏ –ø—Ä–æ–≤–æ–¥–∏—Ç –∫–∏–¥–∞–ª–æ–≤–æ."""
    delay = max(0, (split_until - datetime.now()).total_seconds())
    await asyncio.sleep(delay)

    async with db_pool.acquire() as conn:
        async with conn.transaction():
            heist = await conn.fetchrow("SELECT * FROM heists WHERE id=$1 AND status='splitting' FOR UPDATE", heist_id)
            if not heist:
                return

            participants = await conn.fetch(
                "SELECT * FROM heist_participants WHERE heist_id=$1",
                heist_id
            )
            if not participants:
                await conn.execute("UPDATE heists SET status='finished' WHERE id=$1", heist_id)
                return

            # –†–∞–∑–¥–µ–ª—è–µ–º –Ω–∞ —Ç–µ—Ö, –∫—Ç–æ —Ö–æ—á–µ—Ç —É–∫—Ä–∞—Å—Ç—å, –∏ —Ç–µ—Ö, –∫—Ç–æ –æ—Ç–∫–∞–∑–∞–ª—Å—è
            attackers = [p for p in participants if p['betray_choice'] == 'yes']
            victims_pool = [p for p in participants]  # –≤—Å–µ, –≤–∫–ª—é—á–∞—è –∞—Ç–∞–∫—É—é—â–∏—Ö, –º–æ–≥—É—Ç –±—ã—Ç—å —Ü–µ–ª—è–º–∏ (–∫—Ä–æ–º–µ —Å–µ–±—è)

            # –°–ª—É—á–∞–π–Ω–æ–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –∞—Ç–∞–∫—É—é—â–∏—Ö —Å —Ü–µ–ª—è–º–∏ (–∫–∞–∂–¥—ã–π –∞—Ç–∞–∫—É—é—â–∏–π –ø–æ–ª—É—á–∞–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—É—é —Ü–µ–ª—å)
            import random
            random.shuffle(attackers)
            assigned = {}
            # –ò–Ω–¥–µ–∫—Å—ã —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
            participants_indices = {p['user_id']: i for i, p in enumerate(participants)}
            # –ú–Ω–æ–∂–µ—Å—Ç–≤–æ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∂–µ—Ä—Ç–≤ (–∏–Ω–¥–µ–∫—Å—ã)
            available_targets = set(range(len(participants)))
            for attacker in attackers:
                attacker_index = participants_indices[attacker['user_id']]
                possible = [i for i in available_targets if i != attacker_index]
                if not possible:
                    continue
                target_index = random.choice(possible)
                target_id = participants[target_index]['user_id']
                assigned[attacker['user_id']] = target_id
                available_targets.remove(target_index)

            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–µ —Ü–µ–ª–∏ –≤ –ë–î
            for attacker_id, target_id in assigned.items():
                await conn.execute(
                    "UPDATE heist_participants SET betray_target_id=$1 WHERE heist_id=$2 AND user_id=$3",
                    target_id, heist_id, attacker_id
                )

            # –¢–µ–ø–µ—Ä—å –≤—ã–ø–æ–ª–Ω—è–µ–º –ø–æ–ø—ã—Ç–∫–∏
            betrayals_log = []  # –¥–ª—è –∏—Ç–æ–≥–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
            for attacker_id, target_id in assigned.items():
                attacker = next(p for p in participants if p['user_id'] == attacker_id)
                target = next(p for p in participants if p['user_id'] == target_id)

                # –ü–æ–ª—É—á–∞–µ–º –Ω–∞–≤—ã–∫–∏
                skills = await get_user_skills(attacker_id)
                betray_bonus = skills['skill_betray'] * await get_setting_int("skill_betray_bonus_per_level")
                base_chance = await get_setting_int("betray_base_chance")
                max_chance = await get_setting_int("betray_max_chance")
                chance = min(base_chance + betray_bonus, max_chance)

                success = random.randint(1, 100) <= chance

                steal_percent = await get_setting_int("betray_steal_percent")
                fail_penalty_percent = await get_setting_int("betray_fail_penalty_percent")

                attacker_share = float(attacker['current_share'])
                target_share = float(target['current_share'])

                if success:
                    steal_amount = target_share * steal_percent / 100
                    new_attacker_share = attacker_share + steal_amount
                    new_target_share = target_share - steal_amount
                    exp = await get_setting_int("exp_per_betray_success")
                    # –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤ –ª–æ–≥
                    betrayals_log.append((attacker_id, target_id, steal_amount, True))
                else:
                    penalty = attacker_share * fail_penalty_percent / 100
                    new_attacker_share = attacker_share - penalty
                    new_target_share = target_share + penalty
                    exp = await get_setting_int("exp_per_betray_fail")
                    betrayals_log.append((attacker_id, target_id, penalty, False))

                # –û–±–Ω–æ–≤–ª—è–µ–º –¥–æ–ª–∏
                await conn.execute(
                    "UPDATE heist_participants SET current_share=$1 WHERE heist_id=$2 AND user_id=$3",
                    new_attacker_share, heist_id, attacker_id
                )
                await conn.execute(
                    "UPDATE heist_participants SET current_share=$1 WHERE heist_id=$2 AND user_id=$3",
                    new_target_share, heist_id, target_id
                )
                # –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤ heist_betrayals
                await conn.execute(
                    "INSERT INTO heist_betrayals (heist_id, attacker_id, target_id, success, amount, created_at) VALUES ($1, $2, $3, $4, $5, $6)",
                    heist_id, attacker_id, target_id, success, abs(attacker_share - new_attacker_share), datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                )
                await add_exp(attacker_id, exp, conn=conn)
                await set_global_cooldown(attacker_id, "betray")
                await conn.execute(
                    "UPDATE users SET heists_betray_attempts = heists_betray_attempts + 1, heists_betray_success = heists_betray_success + $1 WHERE user_id=$2",
                    1 if success else 0, attacker_id
                )
                await conn.execute(
                    "UPDATE users SET heists_betrayed_count = heists_betrayed_count + 1 WHERE user_id=$1",
                    target_id
                )

            # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–æ–ø –ø–æ –∏—Ç–æ–≥–æ–≤–æ–π –¥–æ–ª–µ (–±–µ–∑ —Å—É–º–º)
            final_participants = await conn.fetch(
                "SELECT user_id, current_share FROM heist_participants WHERE heist_id=$1 ORDER BY current_share DESC",
                heist_id
            )
            top_list = []
            for idx, p in enumerate(final_participants[:3], 1):
                user_info = await conn.fetchrow("SELECT first_name FROM users WHERE user_id=$1", p['user_id'])
                name = user_info['first_name'] if user_info else f"ID{p['user_id']}"
                top_list.append(f"{idx}. {name}")

            top_str = "\n".join(top_list)

            # –ò—Ç–æ–≥–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ (–±–µ–∑ —Å—É–º–º—ã)
            config = HEIST_TYPES[heist['event_type']]
            text = get_random_phrase(config.get('phrases_result', ["üèÅ –ù–∞–ª—ë—Ç –∑–∞–≤–µ—Ä—à—ë–Ω!\nüèÜ –¢–æ–ø –≤–æ—Ä–æ–≤:\n{top}"]), top=top_str)
            await safe_send_chat(heist['chat_id'], text)

            # –ù–∞—á–∏—Å–ª—è–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–µ –¥–æ–ª–∏
            for p in final_participants:
                await update_user_balance(p['user_id'], float(p['current_share']), conn=conn)

            await conn.execute("UPDATE heists SET status='finished' WHERE id=$1", heist_id)

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ö–û–ù–¢–†–ê–ë–ê–ù–î–´ ====================
@db_retry()
async def check_smuggle_cooldown(user_id: int) -> Tuple[bool, int]:
    async with db_pool.acquire() as conn:
        row = await conn.fetchrow("SELECT cooldown_until FROM smuggle_cooldowns WHERE user_id=$1", user_id)
        if row and row['cooldown_until']:
            try:
                cooldown_until = datetime.strptime(row['cooldown_until'], "%Y-%m-%d %H:%M:%S")
                remaining = (cooldown_until - datetime.now()).total_seconds()
                if remaining > 0:
                    return False, int(remaining)
            except:
                return True, 0
    return True, 0

@db_retry()
async def set_smuggle_cooldown(user_id: int, penalty: int = 0):
    base = await get_setting_int("smuggle_cooldown_minutes")
    cooldown_until = datetime.now() + timedelta(minutes=base + penalty)
    async with db_pool.acquire() as conn:
        await conn.execute('''
            INSERT INTO smuggle_cooldowns (user_id, cooldown_until)
            VALUES ($1, $2)
            ON CONFLICT (user_id) DO UPDATE SET cooldown_until = $2
        ''', user_id, cooldown_until.strftime("%Y-%m-%d %H:%M:%S"))

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –¢–Æ–†–¨–ú–´ ====================
@db_retry()
async def start_jail_sentence(user_id: int, chat_id: int, duration_minutes: int, cell: int, article: int):
    now = datetime.now()
    end_time = now + timedelta(minutes=duration_minutes)
    async with db_pool.acquire() as conn:
        await conn.execute(
            "INSERT INTO jail_sentences (user_id, chat_id, start_time, end_time, cell_number, article_number) VALUES ($1, $2, $3, $4, $5, $6)",
            user_id, chat_id, now.strftime("%Y-%m-%d %H:%M:%S"), end_time.strftime("%Y-%m-%d %H:%M:%S"), cell, article
        )
    return end_time

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –†–ê–°–ß–Å–¢–ê –®–ê–ù–°–û–í (–î–õ–Ø –ö–†–ê–ñ) ====================
async def get_theft_success_chance(attacker_id: int) -> float:
    base = await get_setting_float("theft_success_chance")
    rep = await get_user_reputation(attacker_id)
    bonus = float(await get_setting_float("reputation_theft_bonus")) * rep
    max_bonus = await get_setting_float("reputation_max_bonus_percent")
    bonus = min(bonus, max_bonus)
    return base + bonus

async def get_defense_chance(victim_id: int) -> float:
    base = await get_setting_float("theft_defense_chance")
    rep = await get_user_reputation(victim_id)
    bonus = float(await get_setting_float("reputation_defense_bonus")) * rep
    max_bonus = await get_setting_float("reputation_max_bonus_percent")
    bonus = min(bonus, max_bonus)
    return base + bonus

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –û–ß–ò–°–¢–ö–ò ====================
@db_retry()
async def perform_cleanup(manual=False):
    days_heists = await get_setting_int("cleanup_days_heists")
    days_purchases = await get_setting_int("cleanup_days_purchases")
    days_giveaways = await get_setting_int("cleanup_days_giveaways")
    days_tasks = await get_setting_int("cleanup_days_user_tasks")
    days_smuggle = await get_setting_int("cleanup_days_smuggle")
    days_orders = await get_setting_int("cleanup_days_bitcoin_orders")
    days_jail = 30

    now = datetime.now()
    cutoff_heists = now - timedelta(days=days_heists)
    cutoff_purchases = (now - timedelta(days=days_purchases)).strftime("%Y-%m-%d %H:%M:%S")
    cutoff_giveaways = (now - timedelta(days=days_giveaways)).strftime("%Y-%m-%d %H:%M:%S")
    cutoff_tasks = (now - timedelta(days=days_tasks)).strftime("%Y-%m-%d %H:%M:%S")
    cutoff_smuggle = (now - timedelta(days=days_smuggle)).strftime("%Y-%m-%d %H:%M:%S")
    cutoff_orders = now - timedelta(days=days_orders)
    cutoff_jail = now - timedelta(days=days_jail)

    async with db_pool.acquire() as conn:
        await conn.execute("DELETE FROM heists WHERE status='finished' AND split_until < $1", cutoff_heists.strftime("%Y-%m-%d %H:%M:%S"))
        await conn.execute("DELETE FROM purchases WHERE status IN ('completed','rejected') AND purchase_date < $1", cutoff_purchases)
        await conn.execute("DELETE FROM giveaways WHERE status='completed' AND end_date < $1", cutoff_giveaways)
        await conn.execute("DELETE FROM user_tasks WHERE expires_at IS NOT NULL AND expires_at < $1", cutoff_tasks)
        await conn.execute("DELETE FROM smuggle_runs WHERE status IN ('completed', 'failed') AND end_time < $1", cutoff_smuggle)
        await conn.execute("DELETE FROM bitcoin_orders WHERE status IN ('completed', 'cancelled') AND created_at < $1", cutoff_orders)
        await conn.execute("DELETE FROM jail_sentences WHERE status='completed' AND end_time < $1", cutoff_jail.strftime("%Y-%m-%d %H:%M:%S"))

        cutoff_cooldown = now - timedelta(days=1)
        await conn.execute("DELETE FROM global_cooldowns WHERE last_used < $1", cutoff_cooldown)

    if manual:
        logging.info("–†—É—á–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞.")
    else:
        logging.info("–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞.")

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –≠–ö–°–ü–û–†–¢–ê ====================
@db_retry()
async def export_users_to_csv() -> bytes:
    async with db_pool.acquire() as conn:
        rows = await conn.fetch("SELECT * FROM users ORDER BY user_id")
    if not rows:
        return b""
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow(dict(rows[0]).keys())
    for row in rows:
        writer.writerow(dict(row).values())
    return output.getvalue().encode('utf-8')

ALLOWED_TABLES = ['users', 'purchases', 'heists', 'giveaways', 'tasks', 'bitcoin_orders']
@db_retry()
async def export_table_to_csv(table: str) -> Optional[bytes]:
    if table not in ALLOWED_TABLES:
        return None
    # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —ç–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–º–µ–Ω–∏ —Ç–∞–±–ª–∏—Ü—ã –¥–≤–æ–π–Ω—ã–º–∏ –∫–∞–≤—ã—á–∫–∞–º–∏
    table_escaped = table.replace('"', '""')
    async with db_pool.acquire() as conn:
        query = f'SELECT * FROM "{table_escaped}" ORDER BY id'
        try:
            rows = await conn.fetch(query)
        except Exception:
            return None
        if not rows:
            return None
        output = io.StringIO()
        writer = csv.writer(output)
        writer.writerow(dict(rows[0]).keys())
        for row in rows:
            writer.writerow(dict(row).values())
        return output.getvalue().encode('utf-8')

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ë–ò–¢–ö–û–ò–ù-–ë–ò–†–ñ–ò ====================
@db_retry()
async def get_order_book() -> Dict[str, List[Dict]]:
    async with db_pool.acquire() as conn:
        buy_orders = await conn.fetch("""
            SELECT price, SUM(amount) as total_amount, COUNT(*) as count
            FROM bitcoin_orders
            WHERE type='buy' AND status='active'
            GROUP BY price
            ORDER BY price DESC
        """)
        sell_orders = await conn.fetch("""
            SELECT price, SUM(amount) as total_amount, COUNT(*) as count
            FROM bitcoin_orders
            WHERE type='sell' AND status='active'
            GROUP BY price
            ORDER BY price ASC
        """)
        bids = []
        for r in buy_orders:
            bids.append({
                'price': r['price'],
                'total_amount': float(r['total_amount']),
                'count': r['count']
            })
        asks = []
        for r in sell_orders:
            asks.append({
                'price': r['price'],
                'total_amount': float(r['total_amount']),
                'count': r['count']
            })
        return {'bids': bids, 'asks': asks}

@db_retry()
async def get_active_orders(order_type: str = None) -> List[dict]:
    async with db_pool.acquire() as conn:
        if order_type == 'buy':
            rows = await conn.fetch("SELECT * FROM bitcoin_orders WHERE type='buy' AND status='active' ORDER BY price DESC, created_at ASC")
        elif order_type == 'sell':
            rows = await conn.fetch("SELECT * FROM bitcoin_orders WHERE type='sell' AND status='active' ORDER BY price ASC, created_at ASC")
        else:
            rows = await conn.fetch("SELECT * FROM bitcoin_orders WHERE status='active' ORDER BY created_at DESC")
        result = []
        for r in rows:
            d = dict(r)
            d['amount'] = float(d['amount'])
            d['total_locked'] = float(d['total_locked'])
            result.append(d)
        return result

@db_retry()
async def create_bitcoin_order(user_id: int, order_type: str, amount: float, price: int) -> int:
    async with db_pool.acquire() as conn:
        async with conn.transaction():
            await conn.execute("SET LOCAL statement_timeout = '5s'")
            if order_type == 'sell':
                current_btc = await conn.fetchval("SELECT bitcoin_balance FROM users WHERE user_id=$1 FOR UPDATE", user_id)
                if current_btc is None:
                    await ensure_user_exists(user_id)
                    current_btc = 0.0
                if current_btc < amount - 0.0001:
                    raise ValueError("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ BTC")
                result = await conn.execute(
                    "UPDATE users SET bitcoin_balance = bitcoin_balance - $1 WHERE user_id = $2 AND bitcoin_balance >= $1",
                    amount, user_id
                )
                if result == "UPDATE 0":
                    raise ValueError("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ BTC")
                total_locked = amount
            else:  # buy
                total_cost = amount * price
                current_balance = await conn.fetchval("SELECT balance FROM users WHERE user_id=$1 FOR UPDATE", user_id)
                if current_balance is None:
                    await ensure_user_exists(user_id)
                    current_balance = 0.0
                if current_balance < total_cost - 0.01:
                    raise ValueError("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∞–∫—Å–æ–≤")
                result = await conn.execute(
                    "UPDATE users SET balance = balance - $1 WHERE user_id = $2 AND balance >= $1",
                    total_cost, user_id
                )
                if result == "UPDATE 0":
                    raise ValueError("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∞–∫—Å–æ–≤")
                total_locked = total_cost

            order_id = await conn.fetchval(
                "INSERT INTO bitcoin_orders (user_id, type, amount, price, total_locked) VALUES ($1, $2, $3, $4, $5) RETURNING id",
                user_id, order_type, amount, price, total_locked
            )
            await match_orders(conn)
            return order_id

@db_retry()
async def cancel_bitcoin_order(order_id: int, user_id: int) -> bool:
    async with db_pool.acquire() as conn:
        async with conn.transaction():
            await conn.execute("SET LOCAL statement_timeout = '5s'")
            order = await conn.fetchrow("SELECT * FROM bitcoin_orders WHERE id=$1 AND user_id=$2 AND status='active' FOR UPDATE", order_id, user_id)
            if not order:
                return False
            total_locked = float(order['total_locked'])
            if order['type'] == 'sell':
                await update_user_bitcoin(user_id, total_locked, conn=conn)
            else:
                await update_user_balance(user_id, total_locked, conn=conn)
            await conn.execute("UPDATE bitcoin_orders SET status='cancelled' WHERE id=$1", order_id)
            return True

async def match_orders(conn):
    while True:
        buy = await conn.fetchrow("""
            SELECT id, user_id, price, amount, total_locked
            FROM bitcoin_orders
            WHERE type='buy' AND status='active'
            ORDER BY price DESC, created_at ASC
            LIMIT 1
            FOR UPDATE SKIP LOCKED
        """)
        sell = await conn.fetchrow("""
            SELECT id, user_id, price, amount, total_locked
            FROM bitcoin_orders
            WHERE type='sell' AND status='active'
            ORDER BY price ASC, created_at ASC
            LIMIT 1
            FOR UPDATE SKIP LOCKED
        """)
        if not buy or not sell or buy['price'] < sell['price']:
            break

        buy_amount = float(buy['amount'])
        buy_total_locked = float(buy['total_locked'])
        sell_amount = float(sell['amount'])
        sell_total_locked = float(sell['total_locked'])
        trade_price = sell['price']

        trade_amount = min(buy_amount, sell_amount)
        total_cost = trade_amount * trade_price

        buyer_id = buy['user_id']
        seller_id = sell['user_id']

        await update_user_balance(seller_id, total_cost, conn=conn)
        await update_user_bitcoin(buyer_id, trade_amount, conn=conn)

        new_buy_amount = buy_amount - trade_amount
        new_sell_amount = sell_amount - trade_amount
        new_buy_locked = buy_total_locked - total_cost
        new_sell_locked = sell_total_locked - trade_amount

        if new_buy_amount <= 0.0001:
            await conn.execute("UPDATE bitcoin_orders SET status='completed', amount=0, total_locked=0 WHERE id=$1", buy['id'])
        else:
            await conn.execute("UPDATE bitcoin_orders SET amount=$1, total_locked=$2 WHERE id=$3", new_buy_amount, new_buy_locked, buy['id'])

        if new_sell_amount <= 0.0001:
            await conn.execute("UPDATE bitcoin_orders SET status='completed', amount=0, total_locked=0 WHERE id=$1", sell['id'])
        else:
            await conn.execute("UPDATE bitcoin_orders SET amount=$1, total_locked=$2 WHERE id=$3", new_sell_amount, new_sell_locked, sell['id'])

        await conn.execute(
            "INSERT INTO bitcoin_trades (buy_order_id, sell_order_id, amount, price, buyer_id, seller_id) VALUES ($1, $2, $3, $4, $5, $6)",
            buy['id'], sell['id'], trade_amount, trade_price, buyer_id, seller_id
        )

# ==================== –ù–û–í–´–ï –§–£–ù–ö–¶–ò–ò –î–õ–Ø –°–ë–†–û–°–ê –°–¢–ê–¢–ò–°–¢–ò–ö–ò ====================
@db_retry()
async def generate_reset_key(user_id: int, expire_minutes: int = 10) -> str:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–π 6-–∑–Ω–∞—á–Ω—ã–π –∫–ª—é—á –¥–ª—è —Å–±—Ä–æ—Å–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∞–¥–º–∏–Ω–æ–º)"""
    import random
    import string
    key = ''.join(random.choices(string.digits, k=6))
    expires_at = datetime.now() + timedelta(minutes=expire_minutes)
    async with db_pool.acquire() as conn:
        await conn.execute(
            "INSERT INTO reset_keys (key, user_id, expires_at) VALUES ($1, $2, $3)",
            key, user_id, expires_at
        )
    return key

@db_retry()
async def verify_reset_key(key: str, user_id: int) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∫–ª—é—á —Å–±—Ä–æ—Å–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∞–¥–º–∏–Ω–æ–º –∏–ª–∏ —Å–∞–º–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ)"""
    async with db_pool.acquire() as conn:
        row = await conn.fetchrow(
            "SELECT * FROM reset_keys WHERE key=$1 AND user_id=$2 AND used=FALSE AND expires_at > NOW()",
            key, user_id
        )
        if row:
            await conn.execute("UPDATE reset_keys SET used=TRUE WHERE key=$1", key)
            return True
    return False

@db_retry()
async def reset_user_stats(user_id: int):
    """–°–±—Ä–∞—Å—ã–≤–∞–µ—Ç –≤—Å—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–∫—Ä–æ–º–µ –±–∞–ª–∞–Ω—Å–∞ –∏ –±–∏–∑–Ω–µ—Å–æ–≤). –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∞–¥–º–∏–Ω–æ–º."""
    async with db_pool.acquire() as conn:
        await conn.execute("""
            UPDATE users SET
                reputation = 0,
                total_spent = 0,
                negative_balance = 0,
                last_bonus = NULL,
                last_theft_time = NULL,
                theft_attempts = 0,
                theft_success = 0,
                theft_failed = 0,
                theft_protected = 0,
                casino_wins = 0,
                casino_losses = 0,
                dice_wins = 0,
                dice_losses = 0,
                guess_wins = 0,
                guess_losses = 0,
                slots_wins = 0,
                slots_losses = 0,
                roulette_wins = 0,
                roulette_losses = 0,
                exp = 0,
                level = 1,
                last_gift_time = NULL,
                gift_count_today = 0,
                global_authority = 0,
                smuggle_success = 0,
                smuggle_fail = 0,
                authority_balance = 0,
                skill_share = 0,
                skill_luck = 0,
                skill_betray = 0,
                heists_joined = 0,
                heists_betray_attempts = 0,
                heists_betray_success = 0,
                heists_betrayed_count = 0,
                heists_earned = 0,
                strength = 1,
                agility = 1,
                defense = 1
            WHERE user_id = $1
        """, user_id)
        # –£–¥–∞–ª—è–µ–º –≤—Å–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –∑–∞–¥–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        await conn.execute("DELETE FROM user_tasks WHERE user_id = $1", user_id)
        # –û—Ç–º–µ–Ω—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–∞—è–≤–∫–∏ –Ω–∞ –±–∏—Ä–∂–µ
        await conn.execute("UPDATE bitcoin_orders SET status='cancelled' WHERE user_id=$1 AND status='active'", user_id)
        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∫—É–ª–¥–∞—É–Ω—ã
        await conn.execute("DELETE FROM global_cooldowns WHERE user_id=$1", user_id)

# ==================== –ù–û–í–´–ï –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ó–ê–î–ê–ù–ò–ô ====================
@db_retry()
async def create_subscribe_task(name: str, description: str, channel_id: str, 
                                reward_coins: float, reward_reputation: int, 
                                max_completions: int, media_file_id: str = None, 
                                media_type: str = None, button_link: str = None,
                                created_by: int = None) -> int:
    async with db_pool.acquire() as conn:
        task_id = await conn.fetchval("""
            INSERT INTO tasks 
                (name, description, task_type, target_id, reward_coins, reward_reputation, 
                 max_completions, media_file_id, media_type, button_link, created_by, created_at, active)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
            RETURNING id
        """, name, description, 'subscribe', channel_id, reward_coins, reward_reputation,
            max_completions, media_file_id, media_type, button_link, created_by, 
            datetime.now().strftime("%Y-%m-%d %H:%M:%S"), True)
        return task_id

async def check_user_subscription(user_id: int, channel_id: str) -> bool:
    try:
        member = await bot.get_chat_member(channel_id, user_id)
        return member.status not in ['left', 'kicked']
    except Exception as e:
        logging.error(f"Error checking subscription for {user_id} to {channel_id}: {e}")
        return False

@db_retry()
async def complete_task(user_id: int, task_id: int):
    async with db_pool.acquire() as conn:
        async with conn.transaction():
            await conn.execute("SET LOCAL statement_timeout = '5s'")
            existing = await conn.fetchval(
                "SELECT 1 FROM user_tasks WHERE user_id=$1 AND task_id=$2",
                user_id, task_id
            )
            if existing:
                return False, "–í—ã —É–∂–µ –≤—ã–ø–æ–ª–Ω–∏–ª–∏ —ç—Ç–æ –∑–∞–¥–∞–Ω–∏–µ"
            
            task = await conn.fetchrow("SELECT * FROM tasks WHERE id=$1 AND active=TRUE", task_id)
            if not task:
                return False, "–ó–∞–¥–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ"
            
            if task['max_completions'] > 0 and task['completed_count'] >= task['max_completions']:
                return False, "–õ–∏–º–∏—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–π –∑–∞–¥–∞–Ω–∏—è –∏—Å—á–µ—Ä–ø–∞–Ω"
            
            if float(task['reward_coins']) > 0:
                await update_user_balance(user_id, float(task['reward_coins']), conn=conn)
            if task['reward_reputation'] > 0:
                await update_user_reputation(user_id, task['reward_reputation'])
            
            await conn.execute(
                "INSERT INTO user_tasks (user_id, task_id, completed_at) VALUES ($1, $2, $3)",
                user_id, task_id, datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            )
            await conn.execute(
                "UPDATE tasks SET completed_count = completed_count + 1 WHERE id=$1",
                task_id
            )
            return True, f"‚úÖ –ó–∞–¥–∞–Ω–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ! +{float(task['reward_coins']):.2f} –±–∞–∫—Å–æ–≤, +{task['reward_reputation']} —Ä–µ–ø—É—Ç–∞—Ü–∏–∏"

# ==================== –ù–û–í–´–ï –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ü–†–û–ú–û–ö–û–î–û–í ====================
@db_retry()
async def create_promocode(code: str, reward: float, reward_type: str, max_uses: int, created_by: int = None):
    async with db_pool.acquire() as conn:
        await conn.execute(
            "INSERT INTO promocodes (code, reward, reward_type, max_uses, created_at, created_by) VALUES ($1, $2, $3, $4, $5, $6)",
            code, reward, reward_type, max_uses, datetime.now().strftime("%Y-%m-%d %H:%M:%S"), created_by
        )

@db_retry()
async def activate_promocode(user_id: int, code: str) -> Tuple[bool, str]:
    async with db_pool.acquire() as conn:
        async with conn.transaction():
            await conn.execute("SET LOCAL statement_timeout = '5s'")
            used = await conn.fetchval(
                "SELECT 1 FROM promo_activations WHERE user_id=$1 AND promo_code=$2",
                user_id, code
            )
            if used:
                return False, "–í—ã —É–∂–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–ª–∏ —ç—Ç–æ—Ç –ø—Ä–æ–º–æ–∫–æ–¥"
            
            promo = await conn.fetchrow("SELECT * FROM promocodes WHERE code=$1", code)
            if not promo:
                return False, "–ü—Ä–æ–º–æ–∫–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω"
            
            if promo['used_count'] >= promo['max_uses']:
                return False, "–ü—Ä–æ–º–æ–∫–æ–¥ —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞–∑"
            
            reward = float(promo['reward'])
            if promo['reward_type'] == 'bitcoin':
                await update_user_bitcoin(user_id, reward, conn=conn)
                reward_text = f"{reward:.4f} BTC"
            else:
                await update_user_balance(user_id, reward, conn=conn)
                reward_text = f"{reward:.2f} –±–∞–∫—Å–æ–≤"
            
            await conn.execute(
                "UPDATE promocodes SET used_count = used_count + 1 WHERE code=$1",
                code
            )
            await conn.execute(
                "INSERT INTO promo_activations (user_id, promo_code, activated_at) VALUES ($1, $2, $3)",
                user_id, code, datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            )
            return True, f"‚úÖ –ü—Ä–æ–º–æ–∫–æ–¥ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω! –í—ã –ø–æ–ª—É—á–∏–ª–∏ {reward_text}"

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ò–Ø –ù–ê–õ–Å–¢–û–í ====================
@db_retry()
async def recover_heists():
    """–í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –Ω–µ–∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–µ –Ω–∞–ª—ë—Ç—ã –ø–æ—Å–ª–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞."""
    async with db_pool.acquire() as conn:
        joining_heists = await conn.fetch(
            "SELECT id, join_until FROM heists WHERE status='joining' AND join_until > NOW()"
        )
        for h in joining_heists:
            join_until = datetime.strptime(h['join_until'], "%Y-%m-%d %H:%M:%S")
            asyncio.create_task(finish_heist_joining(h['id'], join_until))

        splitting_heists = await conn.fetch(
            "SELECT id, split_until FROM heists WHERE status='splitting' AND split_until > NOW()"
        )
        for h in splitting_heists:
            split_until = datetime.strptime(h['split_until'], "%Y-%m-%d %H:%M:%S")
            asyncio.create_task(process_betray_results(h['id'], split_until))

    logging.info(f"–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ {len(joining_heists)} –Ω–∞–ª—ë—Ç–æ–≤ –≤ —Å–±–æ—Ä–µ –∏ {len(splitting_heists)} –≤ —Ä–∞—Å–ø–∏–ª–µ.")

# ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ü–û–õ–£–ß–ï–ù–ò–Ø –ò–ù–§–û–†–ú–ê–¶–ò–ò –û –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ï ====================
@db_retry()
async def get_user_name(user_id: int) -> str:
    async with db_pool.acquire() as conn:
        name = await conn.fetchval("SELECT first_name FROM users WHERE user_id=$1", user_id)
        return name or f"ID{user_id}"

@db_retry()
async def get_user_username(user_id: int) -> str:
    async with db_pool.acquire() as conn:
        username = await conn.fetchval("SELECT username FROM users WHERE user_id=$1", user_id)
        return username or "–Ω–µ—Ç —é–∑–µ—Ä–Ω–µ–π–º–∞"

# ==================== –ö–û–ù–ï–¶ –ß–ê–°–¢–ò 1 ====================
